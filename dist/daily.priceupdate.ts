// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

class EventEmitter {
    listeners = new Map();
    on(event, fn) {
        if (this.listeners.has(event)) {
            this.listeners.get(event)?.push(fn);
        } else {
            this.listeners.set(event, [
                fn
            ]);
        }
    }
    off(event, fn) {
        const existingFns = this.listeners.get(event);
        if (existingFns) {
            this.listeners.set(event, existingFns.filter((existingFn)=>existingFn !== fn));
        }
    }
    emit(event, eventData) {
        const fns = this.listeners.get(event);
        if (fns) {
            for (const fn of fns){
                fn(eventData);
            }
        }
    }
}
class AssertionError extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new AssertionError(msg);
    }
}
const { hasOwn } = Object;
const osType = (()=>{
    const { Deno: Deno1 } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator: navigator1 } = globalThis;
    if (navigator1?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const CHAR_FORWARD_SLASH = 47;
function assertPath(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (base === sep) return dir;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
function lastPathSegment(path, isSep, start = 0) {
    let matchedNonSeparator = false;
    let end = path.length;
    for(let i = path.length - 1; i >= start; --i){
        if (isSep(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                start = i + 1;
                break;
            }
        } else if (!matchedNonSeparator) {
            matchedNonSeparator = true;
            end = i + 1;
        }
    }
    return path.slice(start, end);
}
function stripTrailingSeparators(segment, isSep) {
    if (segment.length <= 1) {
        return segment;
    }
    let end = segment.length;
    for(let i = segment.length - 1; i > 0; i--){
        if (isSep(segment.charCodeAt(i))) {
            end = i;
        } else {
            break;
        }
    }
    return segment.slice(0, end);
}
function stripSuffix(name, suffix) {
    if (suffix.length >= name.length) {
        return name;
    }
    const lenDiff = name.length - suffix.length;
    for(let i = suffix.length - 1; i >= 0; --i){
        if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
            return name;
        }
    }
    return name.slice(0, -suffix.length);
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1 } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);
}
function basename(path, suffix = "") {
    assertPath(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    let start = 0;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    const lastSegment = lastPathSegment(path, isPathSeparator, start);
    const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);
    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function extname(path) {
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            ret.base = "\\";
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        ret.base = "\\";
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    ret.base = ret.base || "\\";
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl(path) {
    if (!isAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1 } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = isPosixPathSeparator(path.charCodeAt(0));
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));
    const trailingSeparator = isPosixPathSeparator(path.charCodeAt(path.length - 1));
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute1(path) {
    assertPath(path);
    return path.length > 0 && isPosixPathSeparator(path.charCodeAt(0));
}
function join1(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (!isPosixPathSeparator(from.charCodeAt(fromStart))) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (!isPosixPathSeparator(to.charCodeAt(toStart))) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (isPosixPathSeparator(to.charCodeAt(toStart + i))) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (isPosixPathSeparator(from.charCodeAt(fromStart + i))) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (isPosixPathSeparator(fromCode)) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || isPosixPathSeparator(from.charCodeAt(i))) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (isPosixPathSeparator(to.charCodeAt(toStart))) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path) {
    return path;
}
function dirname1(path) {
    if (path.length === 0) return ".";
    let end = -1;
    let matchedNonSeparator = false;
    for(let i = path.length - 1; i >= 1; --i){
        if (isPosixPathSeparator(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                end = i;
                break;
            }
        } else {
            matchedNonSeparator = true;
        }
    }
    if (end === -1) {
        return isPosixPathSeparator(path.charCodeAt(0)) ? "/" : ".";
    }
    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);
}
function basename1(path, suffix = "") {
    assertPath(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    const lastSegment = lastPathSegment(path, isPosixPathSeparator);
    const strippedSegment = stripTrailingSeparators(lastSegment, isPosixPathSeparator);
    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function extname1(path) {
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse1(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        ret.base = ret.base || "/";
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) {
        ret.dir = stripTrailingSeparators(path.slice(0, startPart - 1), isPosixPathSeparator);
    } else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path) {
    if (!isAbsolute1(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod1 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join1,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format1,
    parse: parse1,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const path = isWindows ? mod : mod1;
const { join: join2, normalize: normalize2 } = path;
const path1 = isWindows ? mod : mod1;
const { basename: basename2, delimiter: delimiter2, dirname: dirname2, extname: extname2, format: format2, fromFileUrl: fromFileUrl2, isAbsolute: isAbsolute2, join: join3, normalize: normalize3, parse: parse2, relative: relative2, resolve: resolve2, toFileUrl: toFileUrl2, toNamespacedPath: toNamespacedPath2 } = path1;
let wasm;
const heap = new Array(32).fill(undefined);
heap.push(undefined, null, true, false);
function getObject(idx) {
    return heap[idx];
}
let heap_next = heap.length;
function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}
function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}
function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
}
const cachedTextDecoder = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
});
cachedTextDecoder.decode();
let cachedUint8Memory0 = new Uint8Array();
function getUint8Memory0() {
    if (cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
let WASM_VECTOR_LEN = 0;
const cachedTextEncoder = new TextEncoder("utf-8");
const encodeString = function(arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }
    let len = arg.length;
    let ptr = malloc(len);
    const mem = getUint8Memory0();
    let offset = 0;
    for(; offset < len; offset++){
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }
    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
    }
    WASM_VECTOR_LEN = offset;
    return ptr;
}
function isLikeNone(x) {
    return x === undefined || x === null;
}
let cachedInt32Memory0 = new Int32Array();
function getInt32Memory0() {
    if (cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function digest(algorithm, data, length) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.digest(retptr, ptr0, len0, addHeapObject(data), !isLikeNone(length), isLikeNone(length) ? 0 : length);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
            throw takeObject(r2);
        }
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
        return v1;
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}
const DigestContextFinalization = new FinalizationRegistry((ptr)=>wasm.__wbg_digestcontext_free(ptr));
class DigestContext {
    static __wrap(ptr) {
        const obj = Object.create(DigestContext.prototype);
        obj.ptr = ptr;
        DigestContextFinalization.register(obj, obj.ptr, obj);
        return obj;
    }
    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DigestContextFinalization.unregister(this);
        return ptr;
    }
    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_digestcontext_free(ptr);
    }
    constructor(algorithm){
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.digestcontext_new(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DigestContext.__wrap(r0);
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    update(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_update(retptr, this.ptr, addHeapObject(data));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digest(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digest(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndReset(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndReset(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndDrop(length) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndDrop(retptr, ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    reset() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_reset(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    clone() {
        const ret = wasm.digestcontext_clone(this.ptr);
        return DigestContext.__wrap(ret);
    }
}
const imports = {
    __wbindgen_placeholder__: {
        __wbg_new_db254ae0a1bb0ff5: function(arg0, arg1) {
            const ret = new TypeError(getStringFromWasm0(arg0, arg1));
            return addHeapObject(ret);
        },
        __wbindgen_object_drop_ref: function(arg0) {
            takeObject(arg0);
        },
        __wbg_byteLength_87a0436a74adc26c: function(arg0) {
            const ret = getObject(arg0).byteLength;
            return ret;
        },
        __wbg_byteOffset_4477d54710af6f9b: function(arg0) {
            const ret = getObject(arg0).byteOffset;
            return ret;
        },
        __wbg_buffer_21310ea17257b0b4: function(arg0) {
            const ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_newwithbyteoffsetandlength_d9aa266703cb98be: function(arg0, arg1, arg2) {
            const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
            return addHeapObject(ret);
        },
        __wbg_length_9e1ae1900cb0fbd5: function(arg0) {
            const ret = getObject(arg0).length;
            return ret;
        },
        __wbindgen_memory: function() {
            const ret = wasm.memory;
            return addHeapObject(ret);
        },
        __wbg_buffer_3f3d764d4747d564: function(arg0) {
            const ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_new_8c3f0052272a457a: function(arg0) {
            const ret = new Uint8Array(getObject(arg0));
            return addHeapObject(ret);
        },
        __wbg_set_83db9690f9353e79: function(arg0, arg1, arg2) {
            getObject(arg0).set(getObject(arg1), arg2 >>> 0);
        },
        __wbindgen_throw: function(arg0, arg1) {
            throw new Error(getStringFromWasm0(arg0, arg1));
        }
    }
};
function instantiate() {
    return instantiateWithInstance().exports;
}
let instanceWithExports;
function instantiateWithInstance() {
    if (instanceWithExports == null) {
        const instance = instantiateInstance();
        wasm = instance.exports;
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        instanceWithExports = {
            instance,
            exports: {
                digest,
                DigestContext
            }
        };
    }
    return instanceWithExports;
}
function instantiateInstance() {
    const wasmBytes = base64decode("\
AGFzbQEAAAABrIGAgAAZYAAAYAABf2ABfwBgAX8Bf2ABfwF+YAJ/fwBgAn9/AX9gA39/fwBgA39/fw\
F/YAR/f39/AGAEf39/fwF/YAV/f39/fwBgBX9/f39/AX9gBn9/f39/fwBgBn9/f39/fwF/YAV/f39+\
fwBgB39/f35/f38Bf2ADf39+AGAFf39+f38AYAV/f31/fwBgBX9/fH9/AGACf34AYAR/fn9/AGAEf3\
1/fwBgBH98f38AAqSFgIAADBhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmdfbmV3X2RiMjU0\
YWUwYTFiYjBmZjUABhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9vYmplY3RfZH\
JvcF9yZWYAAhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18hX193YmdfYnl0ZUxlbmd0aF84N2EwNDM2\
YTc0YWRjMjZjAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fIV9fd2JnX2J5dGVPZmZzZXRfNDQ3N2\
Q1NDcxMGFmNmY5YgADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfMjEzMTBl\
YTE3MjU3YjBiNAADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXzFfX3diZ19uZXd3aXRoYnl0ZW9mZn\
NldGFuZGxlbmd0aF9kOWFhMjY2NzAzY2I5OGJlAAgYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9f\
d2JnX2xlbmd0aF85ZTFhZTE5MDBjYjBmYmQ1AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEV9fd2\
JpbmRnZW5fbWVtb3J5AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2J1ZmZlcl8zZjNk\
NzY0ZDQ3NDdkNTY0AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld184YzNmMDA1Mj\
I3MmE0NTdhAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF84M2RiOTY5MGY5MzUz\
ZTc5AAcYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABQOQgYCAAI4BCw\
cLBwMJEQUHBwUHDwMHBQgFEAUFBwIHBQIGBwYHFQgHDgcHBwYBAQEBBwgHBwcBBwcHAQgHBwcHBwUC\
BwcHBwcBAQcHBQ0IBwkHCQEBAQEBBQEJDQsJBQUFBQUFBgYHBwcHAgIIBwcFAgoABQIDAgIODAsMCw\
sTFBIJCAgGBgUHBwAGAwAABQgICAQAAgSFgICAAAFwARUVBYOAgIAAAQARBomAgIAAAX8BQYCAwAAL\
B7mCgIAADgZtZW1vcnkCAAZkaWdlc3QAUhhfX3diZ19kaWdlc3Rjb250ZXh0X2ZyZWUAbxFkaWdlc3\
Rjb250ZXh0X25ldwBWFGRpZ2VzdGNvbnRleHRfdXBkYXRlAHIUZGlnZXN0Y29udGV4dF9kaWdlc3QA\
VRxkaWdlc3Rjb250ZXh0X2RpZ2VzdEFuZFJlc2V0AFcbZGlnZXN0Y29udGV4dF9kaWdlc3RBbmREcm\
9wAF8TZGlnZXN0Y29udGV4dF9yZXNldAAgE2RpZ2VzdGNvbnRleHRfY2xvbmUAEB9fX3diaW5kZ2Vu\
X2FkZF90b19zdGFja19wb2ludGVyAJABEV9fd2JpbmRnZW5fbWFsbG9jAHoSX193YmluZGdlbl9yZW\
FsbG9jAIcBD19fd2JpbmRnZW5fZnJlZQCLAQmngICAAAEAQQELFIkBigEojwF+YH+AAX2IAYYBgQGC\
AYMBhAGFAZkBammXAQqchImAAI4BhX0CEX8CfiMAQYApayIFJAACQAJAAkACQAJAAkACQAJAAkACQA\
JAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAQ4ZAAECAwQFBgcICQoLDA0O\
DxAREhMUFRYXGAALQdABEBkiBkUNGSAFQZAUakE4aiACQThqKQMANwMAIAVBkBRqQTBqIAJBMGopAw\
A3AwAgBUGQFGpBKGogAkEoaikDADcDACAFQZAUakEgaiACQSBqKQMANwMAIAVBkBRqQRhqIAJBGGop\
AwA3AwAgBUGQFGpBEGogAkEQaikDADcDACAFQZAUakEIaiACQQhqKQMANwMAIAUgAikDADcDkBQgAi\
kDQCEWIAVBkBRqQcgAaiACQcgAahBjIAUgFjcD0BQgBiAFQZAUakHQARCVARoMGAtB0AEQGSIGRQ0Y\
IAVBkBRqQThqIAJBOGopAwA3AwAgBUGQFGpBMGogAkEwaikDADcDACAFQZAUakEoaiACQShqKQMANw\
MAIAVBkBRqQSBqIAJBIGopAwA3AwAgBUGQFGpBGGogAkEYaikDADcDACAFQZAUakEQaiACQRBqKQMA\
NwMAIAVBkBRqQQhqIAJBCGopAwA3AwAgBSACKQMANwOQFCACKQNAIRYgBUGQFGpByABqIAJByABqEG\
MgBSAWNwPQFCAGIAVBkBRqQdABEJUBGgwXC0HQARAZIgZFDRcgBUGQFGpBOGogAkE4aikDADcDACAF\
QZAUakEwaiACQTBqKQMANwMAIAVBkBRqQShqIAJBKGopAwA3AwAgBUGQFGpBIGogAkEgaikDADcDAC\
AFQZAUakEYaiACQRhqKQMANwMAIAVBkBRqQRBqIAJBEGopAwA3AwAgBUGQFGpBCGogAkEIaikDADcD\
ACAFIAIpAwA3A5AUIAIpA0AhFiAFQZAUakHIAGogAkHIAGoQYyAFIBY3A9AUIAYgBUGQFGpB0AEQlQ\
EaDBYLQdABEBkiBkUNFiAFQZAUakE4aiACQThqKQMANwMAIAVBkBRqQTBqIAJBMGopAwA3AwAgBUGQ\
FGpBKGogAkEoaikDADcDACAFQZAUakEgaiACQSBqKQMANwMAIAVBkBRqQRhqIAJBGGopAwA3AwAgBU\
GQFGpBEGogAkEQaikDADcDACAFQZAUakEIaiACQQhqKQMANwMAIAUgAikDADcDkBQgAikDQCEWIAVB\
kBRqQcgAaiACQcgAahBjIAUgFjcD0BQgBiAFQZAUakHQARCVARoMFQtB8AAQGSIGRQ0VIAVBkBRqQS\
BqIAJBIGopAwA3AwAgBUGQFGpBGGogAkEYaikDADcDACAFQZAUakEQaiACQRBqKQMANwMAIAUgAikD\
CDcDmBQgAikDACEWIAVBkBRqQShqIAJBKGoQUSAFIBY3A5AUIAYgBUGQFGpB8AAQlQEaDBQLQfgOEB\
kiBkUNFCAFQZAUakGIAWogAkGIAWopAwA3AwAgBUGQFGpBgAFqIAJBgAFqKQMANwMAIAVBkBRqQfgA\
aiACQfgAaikDADcDACAFQZAUakEQaiACQRBqKQMANwMAIAVBkBRqQRhqIAJBGGopAwA3AwAgBUGQFG\
pBIGogAkEgaikDADcDACAFQZAUakEwaiACQTBqKQMANwMAIAVBkBRqQThqIAJBOGopAwA3AwAgBUGQ\
FGpBwABqIAJBwABqKQMANwMAIAVBkBRqQcgAaiACQcgAaikDADcDACAFQZAUakHQAGogAkHQAGopAw\
A3AwAgBUGQFGpB2ABqIAJB2ABqKQMANwMAIAVBkBRqQeAAaiACQeAAaikDADcDACAFIAIpA3A3A4AV\
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\
akEkakIANwIAIARB+A5qQSxqQgA3AgAgBEH4DmpBNGpCADcCACAEQfgOakE8akIANwIAIARCADcC/A\
4gBEEANgL4DiAEQfgOaiAEQfgOakEEckF/c2pBxABqQQdJGiAEQcAANgL4DiAEQZAUaiAEQfgOakHE\
ABCVARogBEG4J2pBOGoiCSAEQZAUakE8aikCADcDACAEQbgnakEwaiIDIARBkBRqQTRqKQIANwMAIA\
RBuCdqQShqIgggBEGQFGpBLGopAgA3AwAgBEG4J2pBIGoiByAEQZAUakEkaikCADcDACAEQbgnakEY\
aiIMIARBkBRqQRxqKQIANwMAIARBuCdqQRBqIgsgBEGQFGpBFGopAgA3AwAgBEG4J2pBCGoiDSAEQZ\
AUakEMaikCADcDACAEIAQpApQUNwO4JyAEQZAUaiAEQdABEJUBGiAEIAQpA9AUIARB2BVqLQAAIgKt\
fDcD0BQgBEHYFGohAQJAIAJBgAFGDQAgASACakEAQYABIAJrEJQBGgsgBEEAOgDYFSAEQZAUaiABQn\
8QEiAEQfgOakEIaiICIARBkBRqQQhqKQMANwMAIARB+A5qQRBqIgEgBEGQFGpBEGopAwA3AwAgBEH4\
DmpBGGoiCiAEQZAUakEYaikDADcDACAEQfgOakEgaiIOIAQpA7AUNwMAIARB+A5qQShqIg8gBEGQFG\
pBKGopAwA3AwAgBEH4DmpBMGoiECAEQZAUakEwaikDADcDACAEQfgOakE4aiIRIARBkBRqQThqKQMA\
NwMAIAQgBCkDkBQ3A/gOIA0gAikDADcDACALIAEpAwA3AwAgDCAKKQMANwMAIAcgDikDADcDACAIIA\
8pAwA3AwAgAyAQKQMANwMAIAkgESkDADcDACAEIAQpA/gONwO4J0HAABAZIgJFDR4gAiAEKQO4JzcA\
ACACQThqIARBuCdqQThqKQMANwAAIAJBMGogBEG4J2pBMGopAwA3AAAgAkEoaiAEQbgnakEoaikDAD\
cAACACQSBqIARBuCdqQSBqKQMANwAAIAJBGGogBEG4J2pBGGopAwA3AAAgAkEQaiAEQbgnakEQaikD\
ADcAACACQQhqIARBuCdqQQhqKQMANwAAIAYQIkHAACEEDCALIAUgBkHQARCVASIEQYQPakIANwIAIA\
RBjA9qQgA3AgAgBEGUD2pBADYCACAEQgA3AvwOIARBADYC+A5BBCECIARB+A5qIARB+A5qQQRyQX9z\
akEgaiEBA0AgAkF/aiICDQALAkAgAUEHSQ0AQRghAgNAIAJBeGoiAg0ACwsgBEEcNgL4DiAEQZAUak\
EQaiIHIARB+A5qQRBqIgIpAwA3AwAgBEGQFGpBCGoiDCAEQfgOakEIaiIBKQMANwMAIARBkBRqQRhq\
IgsgBEH4DmpBGGoiCSkDADcDACAEQbgnakEIaiINIARBnBRqKQIANwMAIARBuCdqQRBqIgogBEGkFG\
opAgA3AwAgBEG4J2pBGGoiDiAEQZAUakEcaigCADYCACAEIAQpA/gONwOQFCAEIAQpApQUNwO4JyAE\
QZAUaiAEQdABEJUBGiAEIAQpA9AUIARB2BVqLQAAIgOtfDcD0BQgBEHYFGohCAJAIANBgAFGDQAgCC\
ADakEAQYABIANrEJQBGgsgBEEAOgDYFSAEQZAUaiAIQn8QEiABIAwpAwA3AwAgAiAHKQMANwMAIAkg\
CykDADcDACAEQZgPaiAEKQOwFDcDACAEQfgOakEoaiAEQZAUakEoaikDADcDACAEQfgOakEwaiAEQZ\
AUakEwaikDADcDACAEQfgOakE4aiAEQZAUakE4aikDADcDACAEIAQpA5AUNwP4DiANIAEpAwA3AwAg\
CiACKQMANwMAIA4gCSgCADYCACAEIAQpA/gONwO4J0EcEBkiAkUNHSACIAQpA7gnNwAAIAJBGGogBE\
G4J2pBGGooAgA2AAAgAkEQaiAEQbgnakEQaikDADcAACACQQhqIARBuCdqQQhqKQMANwAADBELIAUg\
BkHQARCVASIEQfgOakEMakIANwIAIARB+A5qQRRqQgA3AgAgBEH4DmpBHGpCADcCACAEQgA3AvwOIA\
RBADYC+A4gBEH4DmogBEH4DmpBBHJBf3NqQSRqQQdJGiAEQSA2AvgOIARBkBRqQRBqIgcgBEH4DmpB\
EGoiASkDADcDACAEQZAUakEIaiIMIARB+A5qQQhqIgkpAwA3AwAgBEGQFGpBGGoiCyAEQfgOakEYai\
IDKQMANwMAIARBkBRqQSBqIARB+A5qQSBqIg0oAgA2AgAgBEG4J2pBCGoiCiAEQZAUakEMaikCADcD\
ACAEQbgnakEQaiIOIARBkBRqQRRqKQIANwMAIARBuCdqQRhqIg8gBEGQFGpBHGopAgA3AwAgBCAEKQ\
P4DjcDkBQgBCAEKQKUFDcDuCcgBEGQFGogBEHQARCVARogBCAEKQPQFCAEQdgVai0AACICrXw3A9AU\
IARB2BRqIQgCQCACQYABRg0AIAggAmpBAEGAASACaxCUARoLIARBADoA2BUgBEGQFGogCEJ/EBIgCS\
AMKQMANwMAIAEgBykDADcDACADIAspAwA3AwAgDSAEKQOwFDcDACAEQfgOakEoaiAEQZAUakEoaikD\
ADcDACAEQfgOakEwaiAEQZAUakEwaikDADcDACAEQfgOakE4aiAEQZAUakE4aikDADcDACAEIAQpA5\
AUNwP4DiAKIAkpAwA3AwAgDiABKQMANwMAIA8gAykDADcDACAEIAQpA/gONwO4J0EgEBkiAkUNHCAC\
IAQpA7gnNwAAIAJBGGogBEG4J2pBGGopAwA3AAAgAkEQaiAEQbgnakEQaikDADcAACACQQhqIARBuC\
dqQQhqKQMANwAADB0LIAUgBkHQARCVASIEQfgOakEMakIANwIAIARB+A5qQRRqQgA3AgAgBEH4DmpB\
HGpCADcCACAEQfgOakEkakIANwIAIARB+A5qQSxqQgA3AgAgBEIANwL8DiAEQQA2AvgOIARB+A5qIA\
RB+A5qQQRyQX9zakE0akEHSRogBEEwNgL4DiAEQZAUakEQaiILIARB+A5qQRBqIgIpAwA3AwAgBEGQ\
FGpBCGoiDSAEQfgOakEIaiIBKQMANwMAIARBkBRqQRhqIgogBEH4DmpBGGoiCSkDADcDACAEQZAUak\
EgaiAEQfgOakEgaiIDKQMANwMAIARBkBRqQShqIg4gBEH4DmpBKGoiCCkDADcDACAEQZAUakEwaiIP\
IARB+A5qQTBqIhAoAgA2AgAgBEG4J2pBCGoiESAEQZAUakEMaikCADcDACAEQbgnakEQaiISIARBkB\
RqQRRqKQIANwMAIARBuCdqQRhqIhMgBEGQFGpBHGopAgA3AwAgBEG4J2pBIGoiFCAEQZAUakEkaikC\
ADcDACAEQbgnakEoaiIVIARBkBRqQSxqKQIANwMAIAQgBCkD+A43A5AUIAQgBCkClBQ3A7gnIARBkB\
RqIARB0AEQlQEaIAQgBCkD0BQgBEHYFWotAAAiB618NwPQFCAEQdgUaiEMAkAgB0GAAUYNACAMIAdq\
QQBBgAEgB2sQlAEaCyAEQQA6ANgVIARBkBRqIAxCfxASIAEgDSkDADcDACACIAspAwA3AwAgCSAKKQ\
MANwMAIAMgBCkDsBQ3AwAgCCAOKQMANwMAIBAgDykDADcDACAEQfgOakE4aiAEQZAUakE4aikDADcD\
ACAEIAQpA5AUNwP4DiARIAEpAwA3AwAgEiACKQMANwMAIBMgCSkDADcDACAUIAMpAwA3AwAgFSAIKQ\
MANwMAIAQgBCkD+A43A7gnQTAQGSICRQ0bIAIgBCkDuCc3AAAgAkEoaiAEQbgnakEoaikDADcAACAC\
QSBqIARBuCdqQSBqKQMANwAAIAJBGGogBEG4J2pBGGopAwA3AAAgAkEQaiAEQbgnakEQaikDADcAAC\
ACQQhqIARBuCdqQQhqKQMANwAAIAYQIkEwIQQMHQsgBSAGQfAAEJUBIgRB+A5qQQxqQgA3AgAgBEH4\
DmpBFGpCADcCACAEQfgOakEcakIANwIAIARCADcC/A4gBEEANgL4DiAEQfgOaiAEQfgOakEEckF/c2\
pBJGpBB0kaIARBIDYC+A4gBEGQFGpBEGoiCSAEQfgOakEQaikDADcDACAEQZAUakEIaiAEQfgOakEI\
aiIDKQMANwMAIARBkBRqQRhqIgggBEH4DmpBGGopAwA3AwAgBEGQFGpBIGoiByAEQfgOakEgaigCAD\
YCACAEQbgnakEIaiIMIARBkBRqQQxqKQIANwMAIARBuCdqQRBqIgsgBEGQFGpBFGopAgA3AwAgBEG4\
J2pBGGoiDSAEQZAUakEcaikCADcDACAEIAQpA/gONwOQFCAEIAQpApQUNwO4JyAEQZAUaiAEQfAAEJ\
UBGiAEIAQpA5AUIARB+BRqLQAAIgKtfDcDkBQgBEG4FGohAQJAIAJBwABGDQAgASACakEAQcAAIAJr\
EJQBGgsgBEEAOgD4FCAEQZAUaiABQX8QFCADIAkpAwAiFjcDACAMIBY3AwAgCyAIKQMANwMAIA0gBy\
kDADcDACAEIAQpA5gUIhY3A/gOIAQgFjcDuCdBIBAZIgJFDRogAiAEKQO4JzcAACACQRhqIARBuCdq\
QRhqKQMANwAAIAJBEGogBEG4J2pBEGopAwA3AAAgAkEIaiAEQbgnakEIaikDADcAAAwbCyAFIAZB+A\
4QlQEhAQJAAkAgBA0AQQEhAgwBCyAEQX9MDRQgBBAZIgJFDRogAkF8ai0AAEEDcUUNACACQQAgBBCU\
ARoLIAFBkBRqIAFB+A4QlQEaIAFB+A5qIAFBkBRqEB8gAUH4DmogAiAEEBcMGAsgBSAGQeACEJUBIg\
FBhA9qQgA3AgAgAUGMD2pCADcCACABQZQPakEANgIAIAFCADcC/A4gAUEANgL4DkEEIQIgAUH4Dmog\
AUH4DmpBBHJBf3NqQSBqIQQDQCACQX9qIgINAAsCQCAEQQdJDQBBGCECA0AgAkF4aiICDQALC0EcIQ\
QgAUEcNgL4DiABQZAUakEQaiABQfgOakEQaikDADcDACABQZAUakEIaiABQfgOakEIaikDADcDACAB\
QZAUakEYaiABQfgOakEYaikDADcDACABQbgnakEIaiIJIAFBnBRqKQIANwMAIAFBuCdqQRBqIgMgAU\
GkFGopAgA3AwAgAUG4J2pBGGoiCCABQZAUakEcaigCADYCACABIAEpA/gONwOQFCABIAEpApQUNwO4\
JyABQZAUaiABQeACEJUBGiABQZAUaiABQdgVaiABQbgnahA4QRwQGSICRQ0YIAIgASkDuCc3AAAgAk\
EYaiAIKAIANgAAIAJBEGogAykDADcAACACQQhqIAkpAwA3AAAMFwsgBSAGQdgCEJUBIgFB+A5qQQxq\
QgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEcakIANwIAIAFCADcC/A4gAUEANgL4DiABQfgOaiABQf\
gOakEEckF/c2pBJGpBB0kaQSAhBCABQSA2AvgOIAFBkBRqQRBqIAFB+A5qQRBqKQMANwMAIAFBkBRq\
QQhqIAFB+A5qQQhqKQMANwMAIAFBkBRqQRhqIAFB+A5qQRhqKQMANwMAIAFBkBRqQSBqIAFB+A5qQS\
BqKAIANgIAIAFBuCdqQQhqIgkgAUGQFGpBDGopAgA3AwAgAUG4J2pBEGoiAyABQZAUakEUaikCADcD\
ACABQbgnakEYaiIIIAFBkBRqQRxqKQIANwMAIAEgASkD+A43A5AUIAEgASkClBQ3A7gnIAFBkBRqIA\
FB2AIQlQEaIAFBkBRqIAFB2BVqIAFBuCdqEEFBIBAZIgJFDRcgAiABKQO4JzcAACACQRhqIAgpAwA3\
AAAgAkEQaiADKQMANwAAIAJBCGogCSkDADcAAAwWCyAFIAZBuAIQlQEiAUH4DmpBDGpCADcCACABQf\
gOakEUakIANwIAIAFB+A5qQRxqQgA3AgAgAUH4DmpBJGpCADcCACABQfgOakEsakIANwIAIAFCADcC\
/A4gAUEANgL4DiABQfgOaiABQfgOakEEckF/c2pBNGpBB0kaQTAhBCABQTA2AvgOIAFBkBRqQRBqIA\
FB+A5qQRBqKQMANwMAIAFBkBRqQQhqIAFB+A5qQQhqKQMANwMAIAFBkBRqQRhqIAFB+A5qQRhqKQMA\
NwMAIAFBkBRqQSBqIAFB+A5qQSBqKQMANwMAIAFBkBRqQShqIAFB+A5qQShqKQMANwMAIAFBkBRqQT\
BqIAFB+A5qQTBqKAIANgIAIAFBuCdqQQhqIgkgAUGQFGpBDGopAgA3AwAgAUG4J2pBEGoiAyABQZAU\
akEUaikCADcDACABQbgnakEYaiIIIAFBkBRqQRxqKQIANwMAIAFBuCdqQSBqIgcgAUGQFGpBJGopAg\
A3AwAgAUG4J2pBKGoiDCABQZAUakEsaikCADcDACABIAEpA/gONwOQFCABIAEpApQUNwO4JyABQZAU\
aiABQbgCEJUBGiABQZAUaiABQdgVaiABQbgnahBJQTAQGSICRQ0WIAIgASkDuCc3AAAgAkEoaiAMKQ\
MANwAAIAJBIGogBykDADcAACACQRhqIAgpAwA3AAAgAkEQaiADKQMANwAAIAJBCGogCSkDADcAAAwV\
CyAFIAZBmAIQlQEiAUH4DmpBDGpCADcCACABQfgOakEUakIANwIAIAFB+A5qQRxqQgA3AgAgAUH4Dm\
pBJGpCADcCACABQfgOakEsakIANwIAIAFB+A5qQTRqQgA3AgAgAUH4DmpBPGpCADcCACABQgA3AvwO\
IAFBADYC+A4gAUH4DmogAUH4DmpBBHJBf3NqQcQAakEHSRpBwAAhBCABQcAANgL4DiABQZAUaiABQf\
gOakHEABCVARogAUG4J2pBOGoiCSABQZAUakE8aikCADcDACABQbgnakEwaiIDIAFBkBRqQTRqKQIA\
NwMAIAFBuCdqQShqIgggAUGQFGpBLGopAgA3AwAgAUG4J2pBIGoiByABQZAUakEkaikCADcDACABQb\
gnakEYaiIMIAFBkBRqQRxqKQIANwMAIAFBuCdqQRBqIgsgAUGQFGpBFGopAgA3AwAgAUG4J2pBCGoi\
DSABQZAUakEMaikCADcDACABIAEpApQUNwO4JyABQZAUaiABQZgCEJUBGiABQZAUaiABQdgVaiABQb\
gnahBLQcAAEBkiAkUNFSACIAEpA7gnNwAAIAJBOGogCSkDADcAACACQTBqIAMpAwA3AAAgAkEoaiAI\
KQMANwAAIAJBIGogBykDADcAACACQRhqIAwpAwA3AAAgAkEQaiALKQMANwAAIAJBCGogDSkDADcAAA\
wUCyAFIAZB4AAQlQEiAUH4DmpBDGpCADcCACABQgA3AvwOIAFBADYC+A4gAUH4DmogAUH4DmpBBHJB\
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\
IAFB+A5qQRRqKQIANwMAIAFBiCZqQRhqIgwgAUH4DmpBHGopAgA3AwAgASABKQO4JzcD+A4gASABKQ\
L8DjcDiCYgAUGQFGogAUG4FGogAUGIJmoQJyAIIAwpAwA3AwAgCSAHKQMANwMAIAMgAikDADcDACAB\
IAEpA4gmNwP4DkEgEBkiAkUNCiACIAEpA/gONwAAIAJBGGogCCkDADcAACACQRBqIAkpAwA3AAAgAk\
EIaiADKQMANwAADAkLIAUgBkHYARCVASIBQZAUaiABQdgBEJUBGiABQbgnakEMakIANwIAIAFBuCdq\
QRRqQgA3AgAgAUG4J2pBHGpCADcCACABQbgnakEkakIANwIAIAFBuCdqQSxqQgA3AgAgAUG4J2pBNG\
pCADcCACABQbgnakE8akIANwIAIAFCADcCvCcgAUEANgK4JyABQbgnaiABQbgnakEEckF/c2pBxABq\
QQdJGiABQcAANgK4JyABQfgOaiABQbgnakHEABCVARogAUHAJmogAUH4DmpBPGopAgA3AwBBMCEEIA\
FBiCZqQTBqIAFB+A5qQTRqKQIANwMAIAFBiCZqQShqIgIgAUH4DmpBLGopAgA3AwAgAUGIJmpBIGoi\
CSABQfgOakEkaikCADcDACABQYgmakEYaiIDIAFB+A5qQRxqKQIANwMAIAFBiCZqQRBqIgggAUH4Dm\
pBFGopAgA3AwAgAUGIJmpBCGoiByABQfgOakEMaikCADcDACABIAEpAvwONwOIJiABQZAUaiABQeAU\
aiABQYgmahAjIAFB+A5qQShqIgwgAikDADcDACABQfgOakEgaiILIAkpAwA3AwAgAUH4DmpBGGoiCS\
ADKQMANwMAIAFB+A5qQRBqIgMgCCkDADcDACABQfgOakEIaiIIIAcpAwA3AwAgASABKQOIJjcD+A5B\
MBAZIgJFDQkgAiABKQP4DjcAACACQShqIAwpAwA3AAAgAkEgaiALKQMANwAAIAJBGGogCSkDADcAAC\
ACQRBqIAMpAwA3AAAgAkEIaiAIKQMANwAADAgLIAUgBkHYARCVASIBQZAUaiABQdgBEJUBGiABQbgn\
akEMakIANwIAIAFBuCdqQRRqQgA3AgAgAUG4J2pBHGpCADcCACABQbgnakEkakIANwIAIAFBuCdqQS\
xqQgA3AgAgAUG4J2pBNGpCADcCACABQbgnakE8akIANwIAIAFCADcCvCcgAUEANgK4JyABQbgnaiAB\
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\
AwA3AwAgBUHAAmpBCGogBUGYCGpBCGopAwA3AwAgBUHAAmpBGGogBUGYCGpBGGopAwA3AwAgBUHAAm\
pBIGogBUGYCGpBIGooAgA2AgAgBUHoBmpBCGoiAyAFQcACakEMaikCADcDACAFQegGakEQaiIGIAVB\
wAJqQRRqKQIANwMAIAVB6AZqQRhqIgcgBUHAAmpBHGopAgA3AwAgBSAFKQOYCDcDwAIgBSAFKQLEAj\
cD6AYgAiACQcgBaiAFQegGahBCIAJBAEHIARCUAUHQAmpBADoAAEEgEBkiAUUNECABIAUpA+gGNwAA\
IAFBGGogBykDADcAACABQRBqIAYpAwA3AAAgAUEIaiADKQMANwAADA8LIAVBmAhqQQxqQgA3AgAgBU\
GYCGpBFGpCADcCACAFQZgIakEcakIANwIAIAVBmAhqQSRqQgA3AgAgBUGYCGpBLGpCADcCACAFQgA3\
ApwIIAVBADYCmAggBUGYCGogBUGYCGpBBHJBf3NqQTRqQQdJGkEwIQQgBUEwNgKYCCAFQcACakEQai\
AFQZgIakEQaikDADcDACAFQcACakEIaiAFQZgIakEIaikDADcDACAFQcACakEYaiAFQZgIakEYaikD\
ADcDACAFQcACakEgaiAFQZgIakEgaikDADcDACAFQcACakEoaiAFQZgIakEoaikDADcDACAFQcACak\
EwaiAFQZgIakEwaigCADYCACAFQegGakEIaiIDIAVBwAJqQQxqKQIANwMAIAVB6AZqQRBqIgYgBUHA\
AmpBFGopAgA3AwAgBUHoBmpBGGoiByAFQcACakEcaikCADcDACAFQegGakEgaiIIIAVBwAJqQSRqKQ\
IANwMAIAVB6AZqQShqIgkgBUHAAmpBLGopAgA3AwAgBSAFKQOYCDcDwAIgBSAFKQLEAjcD6AYgAiAC\
QcgBaiAFQegGahBKIAJBAEHIARCUAUGwAmpBADoAAEEwEBkiAUUNDyABIAUpA+gGNwAAIAFBKGogCS\
kDADcAACABQSBqIAgpAwA3AAAgAUEYaiAHKQMANwAAIAFBEGogBikDADcAACABQQhqIAMpAwA3AAAM\
DgsgBUGYCGpBDGpCADcCACAFQZgIakEUakIANwIAIAVBmAhqQRxqQgA3AgAgBUGYCGpBJGpCADcCAC\
AFQZgIakEsakIANwIAIAVBmAhqQTRqQgA3AgAgBUGYCGpBPGpCADcCACAFQgA3ApwIIAVBADYCmAgg\
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\
fwR+IwBBgA9rIgEkAAJAAkACQAJAIABFDQAgACgCACICQX9GDQEgACACQQFqNgIAIABBCGooAgAhAg\
JAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEEEaigC\
ACIDDhkAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYAAtB0AEQGSIERQ0bIAFBCGpBOGogAkE4aikDAD\
cDACABQQhqQTBqIAJBMGopAwA3AwAgAUEIakEoaiACQShqKQMANwMAIAFBCGpBIGogAkEgaikDADcD\
ACABQQhqQRhqIAJBGGopAwA3AwAgAUEIakEQaiACQRBqKQMANwMAIAFBCGpBCGogAkEIaikDADcDAC\
ABIAIpAwA3AwggAikDQCELIAFBCGpByABqIAJByABqEGMgASALNwNIIAQgAUEIakHQARCVARoMGAtB\
0AEQGSIERQ0aIAFBCGpBOGogAkE4aikDADcDACABQQhqQTBqIAJBMGopAwA3AwAgAUEIakEoaiACQS\
hqKQMANwMAIAFBCGpBIGogAkEgaikDADcDACABQQhqQRhqIAJBGGopAwA3AwAgAUEIakEQaiACQRBq\
KQMANwMAIAFBCGpBCGogAkEIaikDADcDACABIAIpAwA3AwggAikDQCELIAFBCGpByABqIAJByABqEG\
MgASALNwNIIAQgAUEIakHQARCVARoMFwtB0AEQGSIERQ0ZIAFBCGpBOGogAkE4aikDADcDACABQQhq\
QTBqIAJBMGopAwA3AwAgAUEIakEoaiACQShqKQMANwMAIAFBCGpBIGogAkEgaikDADcDACABQQhqQR\
hqIAJBGGopAwA3AwAgAUEIakEQaiACQRBqKQMANwMAIAFBCGpBCGogAkEIaikDADcDACABIAIpAwA3\
AwggAikDQCELIAFBCGpByABqIAJByABqEGMgASALNwNIIAQgAUEIakHQARCVARoMFgtB0AEQGSIERQ\
0YIAFBCGpBOGogAkE4aikDADcDACABQQhqQTBqIAJBMGopAwA3AwAgAUEIakEoaiACQShqKQMANwMA\
IAFBCGpBIGogAkEgaikDADcDACABQQhqQRhqIAJBGGopAwA3AwAgAUEIakEQaiACQRBqKQMANwMAIA\
FBCGpBCGogAkEIaikDADcDACABIAIpAwA3AwggAikDQCELIAFBCGpByABqIAJByABqEGMgASALNwNI\
IAQgAUEIakHQARCVARoMFQtB8AAQGSIERQ0XIAFBCGpBIGogAkEgaikDADcDACABQQhqQRhqIAJBGG\
opAwA3AwAgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEoaiACQShqEFEg\
ASALNwMIIAQgAUEIakHwABCVARoMFAtB+A4QGSIERQ0WIAFBCGpBiAFqIAJBiAFqKQMANwMAIAFBCG\
pBgAFqIAJBgAFqKQMANwMAIAFBCGpB+ABqIAJB+ABqKQMANwMAIAEgAikDcDcDeCABQQhqQRBqIAJB\
EGopAwA3AwAgAUEIakEYaiACQRhqKQMANwMAIAFBCGpBIGogAkEgaikDADcDACABIAIpAwg3AxAgAi\
kDACELIAFBCGpB4ABqIAJB4ABqKQMANwMAIAFBCGpB2ABqIAJB2ABqKQMANwMAIAFBCGpB0ABqIAJB\
0ABqKQMANwMAIAFBCGpByABqIAJByABqKQMANwMAIAFBCGpBwABqIAJBwABqKQMANwMAIAFBCGpBOG\
ogAkE4aikDADcDACABQQhqQTBqIAJBMGopAwA3AwAgASACKQMoNwMwIAItAGohBSACLQBpIQYgAi0A\
aCEHIAFBADYCmAECQCACKAKQASIIRQ0AIAJBlAFqIglBCGopAAAhDCAJQRBqKQAAIQ0gCSkAACEOIA\
FBtAFqIAlBGGopAAA3AgAgAUGsAWogDTcCACABQaQBaiAMNwIAIAFBCGpBlAFqIA43AgAgAkG0AWoi\
CiAJIAhBBXRqIglGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUHUAWogCkEYaikAADcCAC\
ABQcwBaiANNwIAIAFBxAFqIAw3AgAgAUEIakG0AWogDjcCACACQdQBaiIKIAlGDQAgCkEIaikAACEM\
IApBEGopAAAhDSAKKQAAIQ4gAUH0AWogCkEYaikAADcCACABQewBaiANNwIAIAFB5AFqIAw3AgAgAU\
EIakHUAWogDjcCACACQfQBaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUGUAmog\
CkEYaikAADcCACABQYwCaiANNwIAIAFBhAJqIAw3AgAgAUEIakH0AWogDjcCACACQZQCaiIKIAlGDQ\
AgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUG0AmogCkEYaikAADcCACABQawCaiANNwIAIAFB\
pAJqIAw3AgAgAUEIakGUAmogDjcCACACQbQCaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQ\
AAIQ4gAUHUAmogCkEYaikAADcCACABQcwCaiANNwIAIAFBxAJqIAw3AgAgAUEIakG0AmogDjcCACAC\
QdQCaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUH0AmogCkEYaikAADcCACABQe\
wCaiANNwIAIAFB5AJqIAw3AgAgAUEIakHUAmogDjcCACACQfQCaiIKIAlGDQAgCkEIaikAACEMIApB\
EGopAAAhDSAKKQAAIQ4gAUGUA2ogCkEYaikAADcCACABQYwDaiANNwIAIAFBhANqIAw3AgAgAUEIak\
H0AmogDjcCACACQZQDaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUG0A2ogCkEY\
aikAADcCACABQawDaiANNwIAIAFBpANqIAw3AgAgAUEIakGUA2ogDjcCACACQbQDaiIKIAlGDQAgCk\
EIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUHUA2ogCkEYaikAADcCACABQcwDaiANNwIAIAFBxANq\
IAw3AgAgAUEIakG0A2ogDjcCACACQdQDaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ\
4gAUH0A2ogCkEYaikAADcCACABQewDaiANNwIAIAFB5ANqIAw3AgAgAUEIakHUA2ogDjcCACACQfQD\
aiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUGUBGogCkEYaikAADcCACABQYwEai\
ANNwIAIAFBhARqIAw3AgAgAUEIakH0A2ogDjcCACACQZQEaiIKIAlGDQAgCkEIaikAACEMIApBEGop\
AAAhDSAKKQAAIQ4gAUG0BGogCkEYaikAADcCACABQawEaiANNwIAIAFBpARqIAw3AgAgAUEIakGUBG\
ogDjcCACACQbQEaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUHUBGogCkEYaikA\
ADcCACABQcwEaiANNwIAIAFBxARqIAw3AgAgAUEIakG0BGogDjcCACACQdQEaiIKIAlGDQAgCkEIai\
kAACEMIApBEGopAAAhDSAKKQAAIQ4gAUH0BGogCkEYaikAADcCACABQewEaiANNwIAIAFB5ARqIAw3\
AgAgAUEIakHUBGogDjcCACACQfQEaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAU\
GUBWogCkEYaikAADcCACABQYwFaiANNwIAIAFBhAVqIAw3AgAgAUEIakH0BGogDjcCACACQZQFaiIK\
IAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUG0BWogCkEYaikAADcCACABQawFaiANNw\
IAIAFBpAVqIAw3AgAgAUEIakGUBWogDjcCACACQbQFaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAh\
DSAKKQAAIQ4gAUHUBWogCkEYaikAADcCACABQcwFaiANNwIAIAFBxAVqIAw3AgAgAUEIakG0BWogDj\
cCACACQdQFaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUH0BWogCkEYaikAADcC\
ACABQewFaiANNwIAIAFB5AVqIAw3AgAgAUEIakHUBWogDjcCACACQfQFaiIKIAlGDQAgCkEIaikAAC\
EMIApBEGopAAAhDSAKKQAAIQ4gAUGUBmogCkEYaikAADcCACABQYwGaiANNwIAIAFBhAZqIAw3AgAg\
AUEIakH0BWogDjcCACACQZQGaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUG0Bm\
ogCkEYaikAADcCACABQawGaiANNwIAIAFBpAZqIAw3AgAgAUEIakGUBmogDjcCACACQbQGaiIKIAlG\
DQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUHUBmogCkEYaikAADcCACABQcwGaiANNwIAIA\
FBxAZqIAw3AgAgAUEIakG0BmogDjcCACACQdQGaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAK\
KQAAIQ4gAUH0BmogCkEYaikAADcCACABQewGaiANNwIAIAFB5AZqIAw3AgAgAUEIakHUBmogDjcCAC\
ACQfQGaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUGUB2ogCkEYaikAADcCACAB\
QYwHaiANNwIAIAFBhAdqIAw3AgAgAUEIakH0BmogDjcCACACQZQHaiIKIAlGDQAgCkEIaikAACEMIA\
pBEGopAAAhDSAKKQAAIQ4gAUG0B2ogCkEYaikAADcCACABQawHaiANNwIAIAFBpAdqIAw3AgAgAUEI\
akGUB2ogDjcCACACQbQHaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUHUB2ogCk\
EYaikAADcCACABQcwHaiANNwIAIAFBxAdqIAw3AgAgAUEIakG0B2ogDjcCACACQdQHaiIKIAlGDQAg\
CkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUH0B2ogCkEYaikAADcCACABQewHaiANNwIAIAFB5A\
dqIAw3AgAgAUEIakHUB2ogDjcCACACQfQHaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAA\
IQ4gAUGUCGogCkEYaikAADcCACABQYwIaiANNwIAIAFBhAhqIAw3AgAgAUEIakH0B2ogDjcCACACQZ\
QIaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUG0CGogCkEYaikAADcCACABQawI\
aiANNwIAIAFBpAhqIAw3AgAgAUEIakGUCGogDjcCACACQbQIaiIKIAlGDQAgCkEIaikAACEMIApBEG\
opAAAhDSAKKQAAIQ4gAUHUCGogCkEYaikAADcCACABQcwIaiANNwIAIAFBxAhqIAw3AgAgAUEIakG0\
CGogDjcCACACQdQIaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUH0CGogCkEYai\
kAADcCACABQewIaiANNwIAIAFB5AhqIAw3AgAgAUEIakHUCGogDjcCACACQfQIaiIKIAlGDQAgCkEI\
aikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUGUCWogCkEYaikAADcCACABQYwJaiANNwIAIAFBhAlqIA\
w3AgAgAUEIakH0CGogDjcCACACQZQJaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4g\
AUG0CWogCkEYaikAADcCACABQawJaiANNwIAIAFBpAlqIAw3AgAgAUEIakGUCWogDjcCACACQbQJai\
IKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUHUCWogCkEYaikAADcCACABQcwJaiAN\
NwIAIAFBxAlqIAw3AgAgAUEIakG0CWogDjcCACACQdQJaiIKIAlGDQAgCkEIaikAACEMIApBEGopAA\
AhDSAKKQAAIQ4gAUH0CWogCkEYaikAADcCACABQewJaiANNwIAIAFB5AlqIAw3AgAgAUEIakHUCWog\
DjcCACACQfQJaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUGUCmogCkEYaikAAD\
cCACABQYwKaiANNwIAIAFBhApqIAw3AgAgAUEIakH0CWogDjcCACACQZQKaiIKIAlGDQAgCkEIaikA\
ACEMIApBEGopAAAhDSAKKQAAIQ4gAUG0CmogCkEYaikAADcCACABQawKaiANNwIAIAFBpApqIAw3Ag\
AgAUEIakGUCmogDjcCACACQbQKaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUHU\
CmogCkEYaikAADcCACABQcwKaiANNwIAIAFBxApqIAw3AgAgAUEIakG0CmogDjcCACACQdQKaiIKIA\
lGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUH0CmogCkEYaikAADcCACABQewKaiANNwIA\
IAFB5ApqIAw3AgAgAUEIakHUCmogDjcCACACQfQKaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDS\
AKKQAAIQ4gAUGUC2ogCkEYaikAADcCACABQYwLaiANNwIAIAFBhAtqIAw3AgAgAUEIakH0CmogDjcC\
ACACQZQLaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUG0C2ogCkEYaikAADcCAC\
ABQawLaiANNwIAIAFBpAtqIAw3AgAgAUEIakGUC2ogDjcCACACQbQLaiIKIAlGDQAgCkEIaikAACEM\
IApBEGopAAAhDSAKKQAAIQ4gAUHUC2ogCkEYaikAADcCACABQcwLaiANNwIAIAFBxAtqIAw3AgAgAU\
EIakG0C2ogDjcCACACQdQLaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUH0C2og\
CkEYaikAADcCACABQewLaiANNwIAIAFB5AtqIAw3AgAgAUEIakHUC2ogDjcCACACQfQLaiIKIAlGDQ\
AgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUGUDGogCkEYaikAADcCACABQYwMaiANNwIAIAFB\
hAxqIAw3AgAgAUEIakH0C2ogDjcCACACQZQMaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQ\
AAIQ4gAUG0DGogCkEYaikAADcCACABQawMaiANNwIAIAFBpAxqIAw3AgAgAUEIakGUDGogDjcCACAC\
QbQMaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUHUDGogCkEYaikAADcCACABQc\
wMaiANNwIAIAFBxAxqIAw3AgAgAUEIakG0DGogDjcCACACQdQMaiIKIAlGDQAgCkEIaikAACEMIApB\
EGopAAAhDSAKKQAAIQ4gAUH0DGogCkEYaikAADcCACABQewMaiANNwIAIAFB5AxqIAw3AgAgAUEIak\
HUDGogDjcCACACQfQMaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUGUDWogCkEY\
aikAADcCACABQYwNaiANNwIAIAFBhA1qIAw3AgAgAUEIakH0DGogDjcCACACQZQNaiIKIAlGDQAgCk\
EIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUG0DWogCkEYaikAADcCACABQawNaiANNwIAIAFBpA1q\
IAw3AgAgAUEIakGUDWogDjcCACACQbQNaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ\
4gAUHUDWogCkEYaikAADcCACABQcwNaiANNwIAIAFBxA1qIAw3AgAgAUEIakG0DWogDjcCACACQdQN\
aiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUH0DWogCkEYaikAADcCACABQewNai\
ANNwIAIAFB5A1qIAw3AgAgAUEIakHUDWogDjcCACACQfQNaiIKIAlGDQAgCkEIaikAACEMIApBEGop\
AAAhDSAKKQAAIQ4gAUGUDmogCkEYaikAADcCACABQYwOaiANNwIAIAFBhA5qIAw3AgAgAUEIakH0DW\
ogDjcCACACQZQOaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAUG0DmogCkEYaikA\
ADcCACABQawOaiANNwIAIAFBpA5qIAw3AgAgAUEIakGUDmogDjcCACACQbQOaiIKIAlGDQAgCkEIai\
kAACEMIApBEGopAAAhDSAKKQAAIQ4gAUHUDmogCkEYaikAADcCACABQcwOaiANNwIAIAFBxA5qIAw3\
AgAgAUEIakG0DmogDjcCACACQdQOaiIKIAlGDQAgCkEIaikAACEMIApBEGopAAAhDSAKKQAAIQ4gAU\
H0DmogCkEYaikAADcCACABQewOaiANNwIAIAFB5A5qIAw3AgAgAUEIakHUDmogDjcCACACQfQOaiAJ\
Rw0YCyABIAU6AHIgASAGOgBxIAEgBzoAcCABIAs3AwggASAIQf///z9xIgJBNyACQTdJGzYCmAEgBC\
ABQQhqQfgOEJUBGgwTC0HgAhAZIgRFDRUgAUEIaiACQcgBEJUBGiABQQhqQcgBaiACQcgBahBkIAQg\
AUEIakHgAhCVARoMEgtB2AIQGSIERQ0UIAFBCGogAkHIARCVARogAUEIakHIAWogAkHIAWoQZSAEIA\
FBCGpB2AIQlQEaDBELQbgCEBkiBEUNEyABQQhqIAJByAEQlQEaIAFBCGpByAFqIAJByAFqEGYgBCAB\
QQhqQbgCEJUBGgwQC0GYAhAZIgRFDRIgAUEIaiACQcgBEJUBGiABQQhqQcgBaiACQcgBahBnIAQgAU\
EIakGYAhCVARoMDwtB4AAQGSIERQ0RIAFBCGpBEGogAkEQaikDADcDACABIAIpAwg3AxAgAikDACEL\
IAFBCGpBGGogAkEYahBRIAEgCzcDCCAEIAFBCGpB4AAQlQEaDA4LQeAAEBkiBEUNECABQQhqQRBqIA\
JBEGopAwA3AwAgASACKQMINwMQIAIpAwAhCyABQQhqQRhqIAJBGGoQUSABIAs3AwggBCABQQhqQeAA\
EJUBGgwNC0HoABAZIgRFDQ8gAUEIakEYaiACQRhqKAIANgIAIAFBCGpBEGogAkEQaikDADcDACABIA\
IpAwg3AxAgAikDACELIAFBCGpBIGogAkEgahBRIAEgCzcDCCAEIAFBCGpB6AAQlQEaDAwLQegAEBki\
BEUNDiABQQhqQRhqIAJBGGooAgA2AgAgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQ\
sgAUEIakEgaiACQSBqEFEgASALNwMIIAQgAUEIakHoABCVARoMCwtB4AIQGSIERQ0NIAFBCGogAkHI\
ARCVARogAUEIakHIAWogAkHIAWoQZCAEIAFBCGpB4AIQlQEaDAoLQdgCEBkiBEUNDCABQQhqIAJByA\
EQlQEaIAFBCGpByAFqIAJByAFqEGUgBCABQQhqQdgCEJUBGgwJC0G4AhAZIgRFDQsgAUEIaiACQcgB\
EJUBGiABQQhqQcgBaiACQcgBahBmIAQgAUEIakG4AhCVARoMCAtBmAIQGSIERQ0KIAFBCGogAkHIAR\
CVARogAUEIakHIAWogAkHIAWoQZyAEIAFBCGpBmAIQlQEaDAcLQfAAEBkiBEUNCSABQQhqQSBqIAJB\
IGopAwA3AwAgAUEIakEYaiACQRhqKQMANwMAIAFBCGpBEGogAkEQaikDADcDACABIAIpAwg3AxAgAi\
kDACELIAFBCGpBKGogAkEoahBRIAEgCzcDCCAEIAFBCGpB8AAQlQEaDAYLQfAAEBkiBEUNCCABQQhq\
QSBqIAJBIGopAwA3AwAgAUEIakEYaiACQRhqKQMANwMAIAFBCGpBEGogAkEQaikDADcDACABIAIpAw\
g3AxAgAikDACELIAFBCGpBKGogAkEoahBRIAEgCzcDCCAEIAFBCGpB8AAQlQEaDAULQdgBEBkiBEUN\
ByABQQhqQThqIAJBOGopAwA3AwAgAUEIakEwaiACQTBqKQMANwMAIAFBCGpBKGogAkEoaikDADcDAC\
ABQQhqQSBqIAJBIGopAwA3AwAgAUEIakEYaiACQRhqKQMANwMAIAFBCGpBEGogAkEQaikDADcDACAB\
QQhqQQhqIAJBCGopAwA3AwAgASACKQMANwMIIAJByABqKQMAIQsgAikDQCEMIAFBCGpB0ABqIAJB0A\
BqEGMgAUEIakHIAGogCzcDACABIAw3A0ggBCABQQhqQdgBEJUBGgwEC0HYARAZIgRFDQYgAUEIakE4\
aiACQThqKQMANwMAIAFBCGpBMGogAkEwaikDADcDACABQQhqQShqIAJBKGopAwA3AwAgAUEIakEgai\
ACQSBqKQMANwMAIAFBCGpBGGogAkEYaikDADcDACABQQhqQRBqIAJBEGopAwA3AwAgAUEIakEIaiAC\
QQhqKQMANwMAIAEgAikDADcDCCACQcgAaikDACELIAIpA0AhDCABQQhqQdAAaiACQdAAahBjIAFBCG\
pByABqIAs3AwAgASAMNwNIIAQgAUEIakHYARCVARoMAwtB+AIQGSIERQ0FIAFBCGogAkHIARCVARog\
AUEIakHIAWogAkHIAWoQaCAEIAFBCGpB+AIQlQEaDAILQdgCEBkiBEUNBCABQQhqIAJByAEQlQEaIA\
FBCGpByAFqIAJByAFqEGUgBCABQQhqQdgCEJUBGgwBC0HoABAZIgRFDQMgAUEIakEQaiACQRBqKQMA\
NwMAIAFBCGpBGGogAkEYaikDADcDACABIAIpAwg3AxAgAikDACELIAFBCGpBIGogAkEgahBRIAEgCz\
cDCCAEIAFBCGpB6AAQlQEaCyAAIAAoAgBBf2o2AgBBDBAZIgBFDQIgACAENgIIIAAgAzYCBCAAQQA2\
AgAgAUGAD2okACAADwsQkQEACxCSAQALAAsQjgEAC9k+AhN/An4jAEGAAmsiBCQAAkACQAJAAkACQA\
JAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAk\
ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAADhkAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYAAsg\
AUHIAGohBUGAASABQcgBai0AACIAayIGIANPDRgCQCAARQ0AIAUgAGogAiAGEJUBGiABIAEpA0BCgA\
F8NwNAIAEgBUIAEBIgAyAGayEDIAIgBmohAgsgAyADQQd2IANBAEcgA0H/AHFFcWsiAEEHdCIHayED\
IABFDUkgByEGIAIhAANAIAEgASkDQEKAAXw3A0AgASAAQgAQEiAAQYABaiEAIAZBgH9qIgYNAAxKCw\
sgAUHIAGohBUGAASABQcgBai0AACIAayIGIANPDRgCQCAARQ0AIAUgAGogAiAGEJUBGiABIAEpA0BC\
gAF8NwNAIAEgBUIAEBIgAyAGayEDIAIgBmohAgsgAyADQQd2IANBAEcgA0H/AHFFcWsiAEEHdCIHay\
EDIABFDUcgByEGIAIhAANAIAEgASkDQEKAAXw3A0AgASAAQgAQEiAAQYABaiEAIAZBgH9qIgYNAAxI\
CwsgAUHIAGohBUGAASABQcgBai0AACIAayIGIANPDRgCQCAARQ0AIAUgAGogAiAGEJUBGiABIAEpA0\
BCgAF8NwNAIAEgBUIAEBIgAyAGayEDIAIgBmohAgsgAyADQQd2IANBAEcgA0H/AHFFcWsiAEEHdCIH\
ayEDIABFDUUgByEGIAIhAANAIAEgASkDQEKAAXw3A0AgASAAQgAQEiAAQYABaiEAIAZBgH9qIgYNAA\
xGCwsgAUHIAGohBUGAASABQcgBai0AACIAayIGIANPDRgCQCAARQ0AIAUgAGogAiAGEJUBGiABIAEp\
A0BCgAF8NwNAIAEgBUIAEBIgAyAGayEDIAIgBmohAgsgAyADQQd2IANBAEcgA0H/AHFFcWsiAEEHdC\
IHayEDIABFDUMgByEGIAIhAANAIAEgASkDQEKAAXw3A0AgASAAQgAQEiAAQYABaiEAIAZBgH9qIgYN\
AAxECwsgAUEoaiEFQcAAIAFB6ABqLQAAIgBrIgYgA08NGAJAIABFDQAgBSAAaiACIAYQlQEaIAEgAS\
kDAELAAHw3AwAgASAFQQAQFCADIAZrIQMgAiAGaiECCyADIANBBnYgA0EARyADQT9xRXFrIgBBBnQi\
B2shAyAARQ1BIAchBiACIQADQCABIAEpAwBCwAB8NwMAIAEgAEEAEBQgAEHAAGohACAGQUBqIgYNAA\
xCCwsgAUHpAGotAABBBnQgAS0AaGoiAEUNPyABIAJBgAggAGsiACADIAAgA0kbIgUQNyEAIAMgBWsi\
A0UNRSAEQfAAakEQaiAAQRBqIgYpAwA3AwAgBEHwAGpBGGogAEEYaiIHKQMANwMAIARB8ABqQSBqIA\
BBIGoiCCkDADcDACAEQfAAakEwaiAAQTBqKQMANwMAIARB8ABqQThqIABBOGopAwA3AwAgBEHwAGpB\
wABqIABBwABqKQMANwMAIARB8ABqQcgAaiAAQcgAaikDADcDACAEQfAAakHQAGogAEHQAGopAwA3Aw\
AgBEHwAGpB2ABqIABB2ABqKQMANwMAIARB8ABqQeAAaiAAQeAAaikDADcDACAEIAApAwg3A3ggBCAA\
KQMoNwOYASABQekAai0AACEJIAAtAGohCiAEIAEtAGgiCzoA2AEgBCAAKQMAIhc3A3AgBCAKIAlFck\
ECciIJOgDZASAEQRhqIgogCCkCADcDACAEQRBqIgggBykCADcDACAEQQhqIgcgBikCADcDACAEIAAp\
Agg3AwAgBCAEQfAAakEoaiALIBcgCRAYIAooAgAhCSAIKAIAIQggBygCACEKIAQoAhwhCyAEKAIUIQ\
wgBCgCDCENIAQoAgQhDiAEKAIAIQ8gACAXECogACgCkAEiB0E3Tw0YIABBkAFqIAdBBXRqIgZBIGog\
CzYCACAGQRxqIAk2AgAgBkEYaiAMNgIAIAZBFGogCDYCACAGQRBqIA02AgAgBkEMaiAKNgIAIAZBCG\
ogDjYCACAGQQRqIA82AgAgAEEoaiIGQRhqQgA3AwAgBkEgakIANwMAIAZBKGpCADcDACAGQTBqQgA3\
AwAgBkE4akIANwMAIAZCADcDACAAIAdBAWo2ApABIAZBCGpCADcDACAGQRBqQgA3AwAgAEEIaiIGQR\
hqIABBiAFqKQMANwMAIAZBEGogAEGAAWopAwA3AwAgBkEIaiAAQfgAaikDADcDACAGIAApA3A3AwAg\
ACAAKQMAQgF8NwMAIAFBADsBaCACIAVqIQIMPwsgBCABNgJwIAFByAFqIQZBkAEgAUHYAmotAAAiAG\
siBSADSw0YAkAgAEUNACAGIABqIAIgBRCVARogBEHwAGogBkEBEEQgAyAFayEDIAIgBWohAgsgAyAD\
QZABbiIHQZABbCIFayEAIANBjwFNDT0gBEHwAGogAiAHEEQMPQsgBCABNgJwIAFByAFqIQZBiAEgAU\
HQAmotAAAiAGsiBSADSw0YAkAgAEUNACAGIABqIAIgBRCVARogBEHwAGogBkEBEEggAyAFayEDIAIg\
BWohAgsgAyADQYgBbiIHQYgBbCIFayEAIANBhwFNDTsgBEHwAGogAiAHEEgMOwsgBCABNgJwIAFByA\
FqIQZB6AAgAUGwAmotAAAiAGsiBSADSw0YAkAgAEUNACAGIABqIAIgBRCVARogBEHwAGogBkEBEE8g\
AyAFayEDIAIgBWohAgsgAyADQegAbiIHQegAbCIFayEAIANB5wBNDTkgBEHwAGogAiAHEE8MOQsgBC\
ABNgJwIAFByAFqIQZByAAgAUGQAmotAAAiAGsiBSADSw0YAkAgAEUNACAGIABqIAIgBRCVARogBEHw\
AGogBkEBEFQgAyAFayEDIAIgBWohAgsgAyADQcgAbiIHQcgAbCIFayEAIANBxwBNDTcgBEHwAGogAi\
AHEFQMNwsgAUEYaiEFQcAAIAFB2ABqLQAAIgBrIgYgA0sNGAJAIABFDQAgBSAAaiACIAYQlQEaIAEg\
ASkDAEIBfDcDACABQQhqIAUQHSADIAZrIQMgAiAGaiECCyADQT9xIQcgAiADQUBxIgBqIQggA0E/TQ\
01IAEgASkDACADQQZ2rXw3AwAgAUEIaiEGA0AgBiACEB0gAkHAAGohAiAAQUBqIgANAAw2CwsgBCAB\
NgJwIAFBGGohBkHAACABQdgAai0AACIAayIFIANLDRgCQCAARQ0AIAYgAGogAiAFEJUBGiAEQfAAai\
AGQQEQGiADIAVrIQMgAiAFaiECCyADQT9xIQAgAiADQUBxaiEFIANBP00NMyAEQfAAaiACIANBBnYQ\
GgwzCyABQSBqIQVBwAAgAUHgAGotAAAiAGsiBiADSw0YAkAgAEUNACAFIABqIAIgBhCVARogASABKQ\
MAQgF8NwMAIAFBCGogBRATIAMgBmshAyACIAZqIQILIANBP3EhByACIANBQHEiAGohCCADQT9NDTEg\
ASABKQMAIANBBnatfDcDACABQQhqIQYDQCAGIAIQEyACQcAAaiECIABBQGoiAA0ADDILCyABQSBqIQ\
ZBwAAgAUHgAGotAAAiAGsiBSADSw0YAkAgAEUNACAGIABqIAIgBRCVARogASABKQMAQgF8NwMAIAFB\
CGogBkEBEBUgAyAFayEDIAIgBWohAgsgA0E/cSEAIAIgA0FAcWohBSADQT9NDS8gASABKQMAIANBBn\
YiA618NwMAIAFBCGogAiADEBUMLwsgBCABNgJwIAFByAFqIQZBkAEgAUHYAmotAAAiAGsiBSADSw0Y\
AkAgAEUNACAGIABqIAIgBRCVARogBEHwAGogBkEBEEQgAyAFayEDIAIgBWohAgsgAyADQZABbiIHQZ\
ABbCIFayEAIANBjwFNDS0gBEHwAGogAiAHEEQMLQsgBCABNgJwIAFByAFqIQZBiAEgAUHQAmotAAAi\
AGsiBSADSw0YAkAgAEUNACAGIABqIAIgBRCVARogBEHwAGogBkEBEEggAyAFayEDIAIgBWohAgsgAy\
ADQYgBbiIHQYgBbCIFayEAIANBhwFNDSsgBEHwAGogAiAHEEgMKwsgBCABNgJwIAFByAFqIQZB6AAg\
AUGwAmotAAAiAGsiBSADSw0YAkAgAEUNACAGIABqIAIgBRCVARogBEHwAGogBkEBEE8gAyAFayEDIA\
IgBWohAgsgAyADQegAbiIHQegAbCIFayEAIANB5wBNDSkgBEHwAGogAiAHEE8MKQsgBCABNgJwIAFB\
yAFqIQZByAAgAUGQAmotAAAiAGsiBSADSw0YAkAgAEUNACAGIABqIAIgBRCVARogBEHwAGogBkEBEF\
QgAyAFayEDIAIgBWohAgsgAyADQcgAbiIHQcgAbCIFayEAIANBxwBNDScgBEHwAGogAiAHEFQMJwsg\
AUEoaiEGQcAAIAFB6ABqLQAAIgBrIgUgA0sNGAJAIABFDQAgBiAAaiACIAUQlQEaIAEgASkDAEIBfD\
cDACABQQhqIAZBARAPIAMgBWshAyACIAVqIQILIANBP3EhACACIANBQHFqIQUgA0E/TQ0lIAEgASkD\
ACADQQZ2IgOtfDcDACABQQhqIAIgAxAPDCULIAFBKGohBkHAACABQegAai0AACIAayIFIANLDRgCQC\
AARQ0AIAYgAGogAiAFEJUBGiABIAEpAwBCAXw3AwAgAUEIaiAGQQEQDyADIAVrIQMgAiAFaiECCyAD\
QT9xIQAgAiADQUBxaiEFIANBP00NIyABIAEpAwAgA0EGdiIDrXw3AwAgAUEIaiACIAMQDwwjCyABQd\
AAaiEGQYABIAFB0AFqLQAAIgBrIgUgA0sNGAJAIABFDQAgBiAAaiACIAUQlQEaIAEgASkDQCIXQgF8\
Ihg3A0AgAUHIAGoiACAAKQMAIBggF1StfDcDACABIAZBARANIAMgBWshAyACIAVqIQILIANB/wBxIQ\
AgAiADQYB/cWohBSADQf8ATQ0hIAEgASkDQCIXIANBB3YiA618Ihg3A0AgAUHIAGoiByAHKQMAIBgg\
F1StfDcDACABIAIgAxANDCELIAFB0ABqIQZBgAEgAUHQAWotAAAiAGsiBSADSw0YAkAgAEUNACAGIA\
BqIAIgBRCVARogASABKQNAIhdCAXwiGDcDQCABQcgAaiIAIAApAwAgGCAXVK18NwMAIAEgBkEBEA0g\
AyAFayEDIAIgBWohAgsgA0H/AHEhACACIANBgH9xaiEFIANB/wBNDR8gASABKQNAIhcgA0EHdiIDrX\
wiGDcDQCABQcgAaiIHIAcpAwAgGCAXVK18NwMAIAEgAiADEA0MHwsgBCABNgJwIAFByAFqIQZBqAEg\
AUHwAmotAAAiAGsiBSADSw0YAkAgAEUNACAGIABqIAIgBRCVARogBEHwAGogBkEBED4gAyAFayEDIA\
IgBWohAgsgAyADQagBbiIHQagBbCIFayEAIANBpwFNDR0gBEHwAGogAiAHED4MHQsgBCABNgJwIAFB\
yAFqIQZBiAEgAUHQAmotAAAiAGsiBSADSw0YAkAgAEUNACAGIABqIAIgBRCVARogBEHwAGogBkEBEE\
ggAyAFayEDIAIgBWohAgsgAyADQYgBbiIHQYgBbCIFayEAIANBhwFNDRsgBEHwAGogAiAHEEgMGwsg\
AUEgaiEFAkBBwAAgAUHgAGotAAAiAGsiBiADSw0AAkAgAEUNACAFIABqIAIgBhCVARogASABKQMAQg\
F8NwMAIAFBCGogBRAWIAMgBmshAyACIAZqIQILIANBP3EhByACIANBQHEiAGohCCADQT9NDRkgASAB\
KQMAIANBBnatfDcDACABQQhqIQYDQCAGIAIQFiACQcAAaiECIABBQGoiAA0ADBoLCyAFIABqIAIgAx\
CVARogACADaiEHDBkLIAUgAGogAiADEJUBGiABIAAgA2o6AMgBDDELIAUgAGogAiADEJUBGiABIAAg\
A2o6AMgBDDALIAUgAGogAiADEJUBGiABIAAgA2o6AMgBDC8LIAUgAGogAiADEJUBGiABIAAgA2o6AM\
gBDC4LIAUgAGogAiADEJUBGiABIAAgA2o6AGgMLQsgBCALNgKMASAEIAk2AogBIAQgDDYChAEgBCAI\
NgKAASAEIA02AnwgBCAKNgJ4IAQgDjYCdCAEIA82AnBBiJHAACAEQfAAakGch8AAQfyGwAAQYgALIA\
YgAGogAiADEJUBGiABIAAgA2o6ANgCDCsLIAYgAGogAiADEJUBGiABIAAgA2o6ANACDCoLIAYgAGog\
AiADEJUBGiABIAAgA2o6ALACDCkLIAYgAGogAiADEJUBGiABIAAgA2o6AJACDCgLIAUgAGogAiADEJ\
UBGiABIAAgA2o6AFgMJwsgBiAAaiACIAMQlQEaIAEgACADajoAWAwmCyAFIABqIAIgAxCVARogASAA\
IANqOgBgDCULIAYgAGogAiADEJUBGiABIAAgA2o6AGAMJAsgBiAAaiACIAMQlQEaIAEgACADajoA2A\
IMIwsgBiAAaiACIAMQlQEaIAEgACADajoA0AIMIgsgBiAAaiACIAMQlQEaIAEgACADajoAsAIMIQsg\
BiAAaiACIAMQlQEaIAEgACADajoAkAIMIAsgBiAAaiACIAMQlQEaIAEgACADajoAaAwfCyAGIABqIA\
IgAxCVARogASAAIANqOgBoDB4LIAYgAGogAiADEJUBGiABIAAgA2o6ANABDB0LIAYgAGogAiADEJUB\
GiABIAAgA2o6ANABDBwLIAYgAGogAiADEJUBGiABIAAgA2o6APACDBsLIAYgAGogAiADEJUBGiABIA\
AgA2o6ANACDBoLIAUgCCAHEJUBGgsgASAHOgBgDBgLAkAgAEGJAU8NACAGIAIgBWogABCVARogASAA\
OgDQAgwYCyAAQYgBQYCAwAAQjAEACwJAIABBqQFPDQAgBiACIAVqIAAQlQEaIAEgADoA8AIMFwsgAE\
GoAUGAgMAAEIwBAAsgBiAFIAAQlQEaIAEgADoA0AEMFQsgBiAFIAAQlQEaIAEgADoA0AEMFAsgBiAF\
IAAQlQEaIAEgADoAaAwTCyAGIAUgABCVARogASAAOgBoDBILAkAgAEHJAE8NACAGIAIgBWogABCVAR\
ogASAAOgCQAgwSCyAAQcgAQYCAwAAQjAEACwJAIABB6QBPDQAgBiACIAVqIAAQlQEaIAEgADoAsAIM\
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\
ajYCCCAAIBEgCiAXaiAcIBsgGUEKdyIKQX9zcnNqQc76z8p6akEIdyAYaiIPQQp3aiADIBZqIAQgDU\
EKdyIDcyAMc2pBD3cgDmoiDUEKdyIWajYCBCAAIBMgASAYaiAPIBwgG0EKdyIBQX9zcnNqQc76z8p6\
akEFdyAKaiIJaiAOIAJqIAwgBEEKdyICcyANc2pBDXcgA2oiBEEKd2o2AgAgACgCECEMIAAgASAVai\
AGIApqIAkgDyAgQX9zcnNqQc76z8p6akEGd2ogAyALaiANIAVzIARzakELdyACaiIKajYCECAAIAEg\
DGogBWogAiAHaiAEIBZzIApzakELd2o2AgwLhCgCMH8BfiMAQcAAayIDQRhqIgRCADcDACADQSBqIg\
VCADcDACADQThqIgZCADcDACADQTBqIgdCADcDACADQShqIghCADcDACADQQhqIgkgASkACDcDACAD\
QRBqIgogASkAEDcDACAEIAEoABgiCzYCACAFIAEoACAiBDYCACADIAEpAAA3AwAgAyABKAAcIgU2Ah\
wgAyABKAAkIgw2AiQgCCABKAAoIg02AgAgAyABKAAsIgg2AiwgByABKAAwIg42AgAgAyABKAA0Igc2\
AjQgBiABKAA4Ig82AgAgAyABKAA8IgE2AjwgACAIIAEgBCAFIAcgCCALIAQgDCAMIA0gDyABIAQgBC\
ALIAEgDSAPIAggBSAHIAEgBSAIIAsgByAHIA4gBSALIABBJGoiECgCACIRIABBFGoiEigCACITamoi\
BkGZmoPfBXNBEHciFEG66r+qemoiFSARc0EUdyIWIAZqaiIXIBRzQRh3IhggFWoiGSAWc0EZdyIaIA\
BBIGoiGygCACIVIABBEGoiHCgCACIdaiAKKAIAIgZqIgogAnNBq7OP/AFzQRB3Ih5B8ua74wNqIh8g\
FXNBFHciICAKaiADKAIUIgJqIiFqaiIiIABBHGoiIygCACIWIABBDGoiJCgCACIlaiAJKAIAIglqIg\
ogACkDACIzQiCIp3NBjNGV2HlzQRB3IhRBhd2e23tqIiYgFnNBFHciJyAKaiADKAIMIgpqIiggFHNB\
GHciKXNBEHciKiAAQRhqIisoAgAiLCAAKAIIIi1qIAMoAgAiFGoiLiAzp3NB/6S5iAVzQRB3Ii9B58\
yn0AZqIjAgLHNBFHciMSAuaiADKAIEIgNqIi4gL3NBGHciLyAwaiIwaiIyIBpzQRR3IhogImpqIiIg\
KnNBGHciKiAyaiIyIBpzQRl3IhogASAPIBcgMCAxc0EZdyIwamoiFyAhIB5zQRh3Ih5zQRB3IiEgKS\
AmaiImaiIpIDBzQRR3IjAgF2pqIhdqaiIxIAwgBCAmICdzQRl3IiYgLmpqIicgGHNBEHciGCAeIB9q\
Ih5qIh8gJnNBFHciJiAnamoiJyAYc0EYdyIYc0EQdyIuIAggDSAeICBzQRl3Ih4gKGpqIiAgL3NBEH\
ciKCAZaiIZIB5zQRR3Ih4gIGpqIiAgKHNBGHciKCAZaiIZaiIvIBpzQRR3IhogMWpqIjEgLnNBGHci\
LiAvaiIvIBpzQRl3IhogASAMICIgGSAec0EZdyIZamoiHiAXICFzQRh3IhdzQRB3IiEgGCAfaiIYai\
IfIBlzQRR3IhkgHmpqIh5qaiIiIAQgICAYICZzQRl3IhhqIAZqIiAgKnNBEHciJiAXIClqIhdqIikg\
GHNBFHciGCAgamoiICAmc0EYdyImc0EQdyIqIA0gDyAXIDBzQRl3IhcgJ2pqIicgKHNBEHciKCAyai\
IwIBdzQRR3IhcgJ2pqIicgKHNBGHciKCAwaiIwaiIyIBpzQRR3IhogImpqIiIgKnNBGHciKiAyaiIy\
IBpzQRl3IhogMSAwIBdzQRl3IhdqIAJqIjAgHiAhc0EYdyIec0EQdyIhICYgKWoiJmoiKSAXc0EUdy\
IXIDBqIApqIjBqaiIxIA4gJiAYc0EZdyIYICdqIANqIiYgLnNBEHciJyAeIB9qIh5qIh8gGHNBFHci\
GCAmamoiJiAnc0EYdyInc0EQdyIuIB4gGXNBGXciGSAgaiAUaiIeIChzQRB3IiAgL2oiKCAZc0EUdy\
IZIB5qIAlqIh4gIHNBGHciICAoaiIoaiIvIBpzQRR3IhogMWpqIjEgLnNBGHciLiAvaiIvIBpzQRl3\
IhogIiAoIBlzQRl3IhlqIAJqIiIgMCAhc0EYdyIhc0EQdyIoICcgH2oiH2oiJyAZc0EUdyIZICJqIA\
lqIiJqaiIwIA4gHiAfIBhzQRl3IhhqaiIeICpzQRB3Ih8gISApaiIhaiIpIBhzQRR3IhggHmogFGoi\
HiAfc0EYdyIfc0EQdyIqIAQgCCAhIBdzQRl3IhcgJmpqIiEgIHNBEHciICAyaiImIBdzQRR3IhcgIW\
pqIiEgIHNBGHciICAmaiImaiIyIBpzQRR3IhogMGogA2oiMCAqc0EYdyIqIDJqIjIgGnNBGXciGiAM\
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\
CCIJQRh0IAlBCHRBgID8B3FyIAlBCHZBgP4DcSAJQRh2cnI2AgggAyABKAAMIglBGHQgCUEIdEGAgP\
wHcXIgCUEIdkGA/gNxIAlBGHZycjYCDCADIAEoABAiCUEYdCAJQQh0QYCA/AdxciAJQQh2QYD+A3Eg\
CUEYdnJyNgIQIAMgASgAFCIJQRh0IAlBCHRBgID8B3FyIAlBCHZBgP4DcSAJQRh2cnI2AhQgAyABKA\
AcIglBGHQgCUEIdEGAgPwHcXIgCUEIdkGA/gNxIAlBGHZyciIKNgIcIAMgASgAICIJQRh0IAlBCHRB\
gID8B3FyIAlBCHZBgP4DcSAJQRh2cnIiCzYCICADIAEoABgiCUEYdCAJQQh0QYCA/AdxciAJQQh2QY\
D+A3EgCUEYdnJyIgw2AhggAygCACENIAMoAgQhDiADKAIIIQ8gAygCECEQIAMoAgwhESADKAIUIRIg\
AyABKAAkIglBGHQgCUEIdEGAgPwHcXIgCUEIdkGA/gNxIAlBGHZyciITNgIkIAMgASgAKCIJQRh0IA\
lBCHRBgID8B3FyIAlBCHZBgP4DcSAJQRh2cnIiFDYCKCADIAEoADAiCUEYdCAJQQh0QYCA/AdxciAJ\
QQh2QYD+A3EgCUEYdnJyIhU2AjAgAyABKAAsIglBGHQgCUEIdEGAgPwHcXIgCUEIdkGA/gNxIAlBGH\
ZyciIWNgIsIAMgASgANCIJQRh0IAlBCHRBgID8B3FyIAlBCHZBgP4DcSAJQRh2cnIiCTYCNCADIAEo\
ADgiF0EYdCAXQQh0QYCA/AdxciAXQQh2QYD+A3EgF0EYdnJyIhc2AjggAyABKAA8IhhBGHQgGEEIdE\
GAgPwHcXIgGEEIdkGA/gNxIBhBGHZyciIYNgI8IAUgEyAKcyAYcyAMIBBzIBVzIBEgDnMgE3MgF3NB\
AXciGXNBAXciGnNBAXciGyAKIBJzIAlzIBAgD3MgFHMgGHNBAXciHHNBAXciHXMgGCAJcyAdcyAVIB\
RzIBxzIBtzQQF3Ih5zQQF3Ih9zIBogHHMgHnMgGSAYcyAbcyAXIBVzIBpzIBYgE3MgGXMgCyAMcyAX\
cyASIBFzIBZzIA8gDXMgC3MgCXNBAXciIHNBAXciIXNBAXciInNBAXciI3NBAXciJHNBAXciJXNBAX\
ciJnNBAXciJyAdICFzIAkgFnMgIXMgFCALcyAgcyAdc0EBdyIoc0EBdyIpcyAcICBzIChzIB9zQQF3\
IipzQQF3IitzIB8gKXMgK3MgHiAocyAqcyAnc0EBdyIsc0EBdyItcyAmICpzICxzICUgH3MgJ3MgJC\
AecyAmcyAjIBtzICVzICIgGnMgJHMgISAZcyAjcyAgIBdzICJzIClzQQF3Ii5zQQF3Ii9zQQF3IjBz\
QQF3IjFzQQF3IjJzQQF3IjNzQQF3IjRzQQF3IjUgKyAvcyApICNzIC9zICggInMgLnMgK3NBAXciNn\
NBAXciN3MgKiAucyA2cyAtc0EBdyI4c0EBdyI5cyAtIDdzIDlzICwgNnMgOHMgNXNBAXciOnNBAXci\
O3MgNCA4cyA6cyAzIC1zIDVzIDIgLHMgNHMgMSAncyAzcyAwICZzIDJzIC8gJXMgMXMgLiAkcyAwcy\
A3c0EBdyI8c0EBdyI9c0EBdyI+c0EBdyI/c0EBdyJAc0EBdyJBc0EBdyJCc0EBdyJDIDkgPXMgNyAx\
cyA9cyA2IDBzIDxzIDlzQQF3IkRzQQF3IkVzIDggPHMgRHMgO3NBAXciRnNBAXciR3MgOyBFcyBHcy\
A6IERzIEZzIENzQQF3IkhzQQF3IklzIEIgRnMgSHMgQSA7cyBDcyBAIDpzIEJzID8gNXMgQXMgPiA0\
cyBAcyA9IDNzID9zIDwgMnMgPnMgRXNBAXciSnNBAXciS3NBAXciTHNBAXciTXNBAXciTnNBAXciT3\
NBAXciUHNBAXdqIEYgSnMgRCA+cyBKcyBHc0EBdyJRcyBJc0EBdyJSIEUgP3MgS3MgUXNBAXciUyBM\
IEEgOiA5IDwgMSAmIB8gKCAhIBcgEyAQIAVBHnciVGogDiAHIAZBHnciECACcyAFcSACc2pqIA0gCC\
AFQQV3aiACIAdzIAZxIAdzampBmfOJ1AVqIg5BBXdqQZnzidQFaiJVQR53IgUgDkEedyINcyACIA9q\
IA4gVCAQc3EgEHNqIFVBBXdqQZnzidQFaiIOcSANc2ogECARaiBVIA0gVHNxIFRzaiAOQQV3akGZ84\
nUBWoiEEEFd2pBmfOJ1AVqIhFBHnciD2ogBSAMaiARIBBBHnciEyAOQR53IgxzcSAMc2ogDSASaiAM\
IAVzIBBxIAVzaiARQQV3akGZ84nUBWoiEUEFd2pBmfOJ1AVqIhJBHnciBSARQR53IhBzIAogDGogES\
APIBNzcSATc2ogEkEFd2pBmfOJ1AVqIgpxIBBzaiALIBNqIBAgD3MgEnEgD3NqIApBBXdqQZnzidQF\
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\
AWpBADoAAAwVCyABQQhqKAIAIQMgAkHQAGpBCGoQeyACQQhqQSBqIAJB+ABqKQMAIgU3AwAgAkEIak\
EYaiACQdAAakEgaikDACIGNwMAIAJBCGpBEGogAkHQAGpBGGopAwAiBzcDACACQQhqQQhqIAJB0ABq\
QRBqKQMAIgg3AwAgAiACKQNYIgk3AwggA0EgaiAFNwMAIANBGGogBjcDACADQRBqIAc3AwAgA0EIai\
AINwMAIAMgCTcDACADQegAakEAOgAADBQLIAFBCGooAgAiA0IANwMAIAMgAykDcDcDCCADQRBqIANB\
+ABqKQMANwMAIANBGGogA0GAAWopAwA3AwAgA0EgaiADQYgBaikDADcDACADQShqQQBBwgAQlAEaIA\
MoApABRQ0TIANBADYCkAEMEwsgAUEIaigCAEEAQcgBEJQBQdgCakEAOgAADBILIAFBCGooAgBBAEHI\
ARCUAUHQAmpBADoAAAwRCyABQQhqKAIAQQBByAEQlAFBsAJqQQA6AAAMEAsgAUEIaigCAEEAQcgBEJ\
QBQZACakEAOgAADA8LIAFBCGooAgAiA0L+uevF6Y6VmRA3AxAgA0KBxpS6lvHq5m83AwggA0IANwMA\
IANB2ABqQQA6AAAMDgsgAUEIaigCACIDQv6568XpjpWZEDcDECADQoHGlLqW8ermbzcDCCADQgA3Aw\
AgA0HYAGpBADoAAAwNCyABQQhqKAIAIgNCADcDACADQQApA+iMQDcDCCADQRBqQQApA/CMQDcDACAD\
QRhqQQAoAviMQDYCACADQeAAakEAOgAADAwLIAFBCGooAgAiA0Hww8uefDYCGCADQv6568XpjpWZED\
cDECADQoHGlLqW8ermbzcDCCADQgA3AwAgA0HgAGpBADoAAAwLCyABQQhqKAIAQQBByAEQlAFB2AJq\
QQA6AAAMCgsgAUEIaigCAEEAQcgBEJQBQdACakEAOgAADAkLIAFBCGooAgBBAEHIARCUAUGwAmpBAD\
oAAAwICyABQQhqKAIAQQBByAEQlAFBkAJqQQA6AAAMBwsgAUEIaigCACIDQgA3AwAgA0EAKQOgjUA3\
AwggA0EQakEAKQOojUA3AwAgA0EYakEAKQOwjUA3AwAgA0EgakEAKQO4jUA3AwAgA0HoAGpBADoAAA\
wGCyABQQhqKAIAIgNCADcDACADQQApA4CNQDcDCCADQRBqQQApA4iNQDcDACADQRhqQQApA5CNQDcD\
ACADQSBqQQApA5iNQDcDACADQegAakEAOgAADAULIAFBCGooAgAiA0IANwNAIANBACkDgI5ANwMAIA\
NByABqQgA3AwAgA0EIakEAKQOIjkA3AwAgA0EQakEAKQOQjkA3AwAgA0EYakEAKQOYjkA3AwAgA0Eg\
akEAKQOgjkA3AwAgA0EoakEAKQOojkA3AwAgA0EwakEAKQOwjkA3AwAgA0E4akEAKQO4jkA3AwAgA0\
HQAWpBADoAAAwECyABQQhqKAIAIgNCADcDQCADQQApA8CNQDcDACADQcgAakIANwMAIANBCGpBACkD\
yI1ANwMAIANBEGpBACkD0I1ANwMAIANBGGpBACkD2I1ANwMAIANBIGpBACkD4I1ANwMAIANBKGpBAC\
kD6I1ANwMAIANBMGpBACkD8I1ANwMAIANBOGpBACkD+I1ANwMAIANB0AFqQQA6AAAMAwsgAUEIaigC\
AEEAQcgBEJQBQfACakEAOgAADAILIAFBCGooAgBBAEHIARCUAUHQAmpBADoAAAwBCyABQQhqKAIAIg\
NCADcDACADQQApA7iRQDcDCCADQRBqQQApA8CRQDcDACADQRhqQQApA8iRQDcDACADQeAAakEAOgAA\
CyABQQA2AgAgAEIANwMAIAJBoAFqJAAPCxCRAQALEJIBAAumDQECfyMAQZACayIDJAACQAJAAkACQA\
JAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAJBfWoOCQMMCgsBBQwCAAwLAkAC\
QCABQZeAwABBCxCWAUUNACABQaKAwABBCxCWAUUNASABQa2AwABBCxCWAQ0NQdABEBkiAUUNFyADQZ\
ABaiICQTAQdCABIAJByAAQlQEhAiADQQA2AgAgAyADQQRyQQBBgAEQlAFBf3NqQYQBakEHSRogA0GA\
ATYCACADQYgBaiADQYQBEJUBGiACQcgAaiADQYgBakEEckGAARCVARogAkHIAWpBADoAAEEDIQIMFQ\
tB0AEQGSIBRQ0WIANBkAFqIgJBHBB0IAEgAkHIABCVASECIANBADYCACADIANBBHJBAEGAARCUAUF/\
c2pBhAFqQQdJGiADQYABNgIAIANBiAFqIANBhAEQlQEaIAJByABqIANBiAFqQQRyQYABEJUBGiACQc\
gBakEAOgAAQQEhAgwUC0HQARAZIgFFDRUgA0GQAWoiAkEgEHQgASACQcgAEJUBIQIgA0EANgIAIAMg\
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\
IGohCiACQRBqIQsgAkEYaiEMIANBfmpBN0khDQNAIAAgBTYCkAEgAkEIaiIDIAdBKGopAAA3AwAgCy\
AHQTBqKQAANwMAIAwgB0E4aikAADcDACACIAdBIGopAAA3AwAgBUUNAiAAIAVBf2oiDjYCkAEgAC0A\
aiEPIAogAikDADcAACAKQQhqIAMpAwA3AAAgCkEQaiALKQMANwAAIApBGGogDCkDADcAACACQZABak\
EYaiIDIAdBGGoiECkAADcDACACQZABakEQaiIRIAdBEGoiEikAADcDACACQZABakEIaiITIAdBCGoi\
FCkAADcDACAJIAYpAwA3AwAgCUEIaiAGQQhqIhUpAwA3AwAgCUEQaiAGQRBqIhYpAwA3AwAgCUEYai\
AGQRhqIhcpAwA3AwAgAiAHKQAANwOQASAIQThqIAJBkAFqQThqKQMANwAAIAhBMGogAkGQAWpBMGop\
AwA3AAAgCEEoaiACQZABakEoaikDADcAACAIQSBqIAopAwA3AAAgCEEYaiADKQMANwAAIAhBEGogES\
kDADcAACAIQQhqIBMpAwA3AAAgCCACKQOQATcAACACQcAAOgCIASACIA9BBHIiDzoAiQEgAkIANwMg\
IAMgFykCADcDACARIBYpAgA3AwAgEyAVKQIANwMAIAIgBikCADcDkAEgAkGQAWogCEHAAEIAIA8QGC\
ADKAIAIQMgESgCACERIBMoAgAhEyACKAKsASEPIAIoAqQBIRUgAigCnAEhFiACKAKUASEXIAIoApAB\
IRggDUUNAyAHIBg2AgAgB0EcaiAPNgIAIBAgAzYCACAHQRRqIBU2AgAgEiARNgIAIAdBDGogFjYCAC\
AUIBM2AgAgB0EEaiAXNgIAIAAgBTYCkAEgB0FgaiEHIA4hBSAOIARPDQALCyACQdABaiQADwtBsJDA\
AEErQbSFwAAQcwALIAIgDzYCrAEgAiADNgKoASACIBU2AqQBIAIgETYCoAEgAiAWNgKcASACIBM2Ap\
gBIAIgFzYClAEgAiAYNgKQAUGIkcAAIAJBkAFqQZyHwABB/IbAABBiAAucBQEKfyMAQTBrIgMkACAD\
QSRqIAE2AgAgA0EDOgAoIANCgICAgIAENwMIIAMgADYCIEEAIQQgA0EANgIYIANBADYCEAJAAkACQA\
JAIAIoAggiBQ0AIAJBFGooAgAiAEUNASACKAIQIQEgAEEDdCEGIABBf2pB/////wFxQQFqIQQgAigC\
ACEAA0ACQCAAQQRqKAIAIgdFDQAgAygCICAAKAIAIAcgAygCJCgCDBEIAA0ECyABKAIAIANBCGogAU\
EEaigCABEGAA0DIAFBCGohASAAQQhqIQAgBkF4aiIGDQAMAgsLIAJBDGooAgAiAUUNACABQQV0IQgg\
AUF/akH///8/cUEBaiEEIAIoAgAhAEEAIQYDQAJAIABBBGooAgAiAUUNACADKAIgIAAoAgAgASADKA\
IkKAIMEQgADQMLIAMgBSAGaiIBQRxqLQAAOgAoIAMgAUEEaikCAEIgiTcDCCABQRhqKAIAIQkgAigC\
ECEKQQAhC0EAIQcCQAJAAkAgAUEUaigCAA4DAQACAQsgCUEDdCEMQQAhByAKIAxqIgxBBGooAgBBBE\
cNASAMKAIAKAIAIQkLQQEhBwsgAyAJNgIUIAMgBzYCECABQRBqKAIAIQcCQAJAAkAgAUEMaigCAA4D\
AQACAQsgB0EDdCEJIAogCWoiCUEEaigCAEEERw0BIAkoAgAoAgAhBwtBASELCyADIAc2AhwgAyALNg\
IYIAogASgCAEEDdGoiASgCACADQQhqIAEoAgQRBgANAiAAQQhqIQAgCCAGQSBqIgZHDQALCwJAIAQg\
AigCBE8NACADKAIgIAIoAgAgBEEDdGoiASgCACABKAIEIAMoAiQoAgwRCAANAQtBACEBDAELQQEhAQ\
sgA0EwaiQAIAELmgQCA38CfiMAQfABayIDJAAgACkDACEGIAEgAS0AQCIEaiIFQYABOgAAIANBCGpB\
EGogAEEYaigCADYCACADQRBqIABBEGopAgA3AwAgAyAAKQIINwMIIAZCCYYhBiAErUIDhiEHAkAgBE\
E/cyIARQ0AIAVBAWpBACAAEJQBGgsgBiAHhCEGAkACQCAEQThxQThGDQAgASAGNwA4IANBCGogARAT\
DAELIANBCGogARATIANB4ABqQQxqQgA3AgAgA0HgAGpBFGpCADcCACADQeAAakEcakIANwIAIANB4A\
BqQSRqQgA3AgAgA0HgAGpBLGpCADcCACADQeAAakE0akIANwIAIANBnAFqQgA3AgAgA0IANwJkIANB\
ADYCYCADQeAAaiADQeAAakEEckF/c2pBxABqQQdJGiADQcAANgJgIANBqAFqIANB4ABqQcQAEJUBGi\
ADQdAAaiADQagBakE0aikCADcDACADQcgAaiADQagBakEsaikCADcDACADQcAAaiADQagBakEkaikC\
ADcDACADQThqIANBqAFqQRxqKQIANwMAIANBMGogA0GoAWpBFGopAgA3AwAgA0EoaiADQagBakEMai\
kCADcDACADIAMpAqwBNwMgIAMgBjcDWCADQQhqIANBIGoQEwsgAUEAOgBAIAIgAygCCDYAACACIAMp\
Agw3AAQgAiADKQIUNwAMIANB8AFqJAALigQBCn8jAEEwayIGJABBACEHIAZBADYCCAJAIAFBQHEiCE\
UNAEEBIQcgBkEBNgIIIAYgADYCACAIQcAARg0AQQIhByAGQQI2AgggBiAAQcAAajYCBCAIQYABRg0A\
IAYgAEGAAWo2AhBBiJHAACAGQRBqQYyHwABB/IbAABBiAAsgAUE/cSEJAkAgByAFQQV2IgEgByABSR\
siAUUNACADQQRyIQogAUEFdCELQQAhAyAGIQwDQCAMKAIAIQEgBkEQakEYaiINIAJBGGopAgA3AwAg\
BkEQakEQaiIOIAJBEGopAgA3AwAgBkEQakEIaiIPIAJBCGopAgA3AwAgBiACKQIANwMQIAZBEGogAU\
HAAEIAIAoQGCAEIANqIgFBGGogDSkDADcAACABQRBqIA4pAwA3AAAgAUEIaiAPKQMANwAAIAEgBikD\
EDcAACAMQQRqIQwgCyADQSBqIgNHDQALCwJAAkACQAJAIAlFDQAgB0EFdCICIAVLDQEgBSACayIBQR\
9NDQIgCUEgRw0DIAQgAmoiAiAAIAhqIgEpAAA3AAAgAkEYaiABQRhqKQAANwAAIAJBEGogAUEQaikA\
ADcAACACQQhqIAFBCGopAAA3AAAgB0EBaiEHCyAGQTBqJAAgBw8LIAIgBUG0hMAAEI0BAAtBICABQb\
SEwAAQjAEAC0EgIAlBxITAABBrAAvyAwIDfwJ+IwBB4AFrIgMkACAAKQMAIQYgASABLQBAIgRqIgVB\
gAE6AAAgA0EIaiAAQRBqKQIANwMAIAMgACkCCDcDACAGQgmGIQYgBK1CA4YhBwJAIARBP3MiAEUNAC\
AFQQFqQQAgABCUARoLIAYgB4QhBgJAAkAgBEE4cUE4Rg0AIAEgBjcAOCADIAEQHQwBCyADIAEQHSAD\
QdAAakEMakIANwIAIANB0ABqQRRqQgA3AgAgA0HQAGpBHGpCADcCACADQdAAakEkakIANwIAIANB0A\
BqQSxqQgA3AgAgA0HQAGpBNGpCADcCACADQYwBakIANwIAIANCADcCVCADQQA2AlAgA0HQAGogA0HQ\
AGpBBHJBf3NqQcQAakEHSRogA0HAADYCUCADQZgBaiADQdAAakHEABCVARogA0HAAGogA0GYAWpBNG\
opAgA3AwAgA0E4aiADQZgBakEsaikCADcDACADQTBqIANBmAFqQSRqKQIANwMAIANBKGogA0GYAWpB\
HGopAgA3AwAgA0EgaiADQZgBakEUaikCADcDACADQRhqIANBmAFqQQxqKQIANwMAIAMgAykCnAE3Ax\
AgAyAGNwNIIAMgA0EQahAdCyABQQA6AEAgAiADKQMANwAAIAIgAykDCDcACCADQeABaiQAC/IDAgN/\
An4jAEHgAWsiAyQAIAApAwAhBiABIAEtAEAiBGoiBUGAAToAACADQQhqIABBEGopAgA3AwAgAyAAKQ\
IINwMAIAZCCYYhBiAErUIDhiEHAkAgBEE/cyIARQ0AIAVBAWpBACAAEJQBGgsgBiAHhCEGAkACQCAE\
QThxQThGDQAgASAGNwA4IAMgARAbDAELIAMgARAbIANB0ABqQQxqQgA3AgAgA0HQAGpBFGpCADcCAC\
ADQdAAakEcakIANwIAIANB0ABqQSRqQgA3AgAgA0HQAGpBLGpCADcCACADQdAAakE0akIANwIAIANB\
jAFqQgA3AgAgA0IANwJUIANBADYCUCADQdAAaiADQdAAakEEckF/c2pBxABqQQdJGiADQcAANgJQIA\
NBmAFqIANB0ABqQcQAEJUBGiADQcAAaiADQZgBakE0aikCADcDACADQThqIANBmAFqQSxqKQIANwMA\
IANBMGogA0GYAWpBJGopAgA3AwAgA0EoaiADQZgBakEcaikCADcDACADQSBqIANBmAFqQRRqKQIANw\
MAIANBGGogA0GYAWpBDGopAgA3AwAgAyADKQKcATcDECADIAY3A0ggAyADQRBqEBsLIAFBADoAQCAC\
IAMpAwA3AAAgAiADKQMINwAIIANB4AFqJAAL5wMCBH8CfiMAQdABayIDJAAgASABLQBAIgRqIgVBAT\
oAACAAKQMAQgmGIQcgBK1CA4YhCAJAIARBP3MiBkUNACAFQQFqQQAgBhCUARoLIAcgCIQhBwJAAkAg\
BEE4cUE4Rg0AIAEgBzcAOCAAQQhqIAEQFgwBCyAAQQhqIgQgARAWIANBwABqQQxqQgA3AgAgA0HAAG\
pBFGpCADcCACADQcAAakEcakIANwIAIANBwABqQSRqQgA3AgAgA0HAAGpBLGpCADcCACADQcAAakE0\
akIANwIAIANB/ABqQgA3AgAgA0IANwJEIANBADYCQCADQcAAaiADQcAAakEEckF/c2pBxABqQQdJGi\
ADQcAANgJAIANBiAFqIANBwABqQcQAEJUBGiADQTBqIANBiAFqQTRqKQIANwMAIANBKGogA0GIAWpB\
LGopAgA3AwAgA0EgaiADQYgBakEkaikCADcDACADQRhqIANBiAFqQRxqKQIANwMAIANBEGogA0GIAW\
pBFGopAgA3AwAgA0EIaiADQYgBakEMaikCADcDACADIAMpAowBNwMAIAMgBzcDOCAEIAMQFgsgAUEA\
OgBAIAIgACkDCDcAACACIABBEGopAwA3AAggAiAAQRhqKQMANwAQIANB0AFqJAALgAMBBX8CQAJAAk\
AgAUEJSQ0AQQAhAkHN/3sgAUEQIAFBEEsbIgFrIABNDQEgAUEQIABBC2pBeHEgAEELSRsiA2pBDGoQ\
GSIARQ0BIABBeGohAgJAAkAgAUF/aiIEIABxDQAgAiEBDAELIABBfGoiBSgCACIGQXhxIAQgAGpBAC\
ABa3FBeGoiAEEAIAEgACACa0EQSxtqIgEgAmsiAGshBAJAIAZBA3FFDQAgASABKAIEQQFxIARyQQJy\
NgIEIAEgBGoiBCAEKAIEQQFyNgIEIAUgBSgCAEEBcSAAckECcjYCACACIABqIgQgBCgCBEEBcjYCBC\
ACIAAQJAwBCyACKAIAIQIgASAENgIEIAEgAiAAajYCAAsgASgCBCIAQQNxRQ0CIABBeHEiAiADQRBq\
TQ0CIAEgAEEBcSADckECcjYCBCABIANqIgAgAiADayIDQQNyNgIEIAEgAmoiAiACKAIEQQFyNgIEIA\
AgAxAkDAILIAAQGSECCyACDwsgAUEIaguLAwECfyMAQZABayIAJAACQEHwABAZIgFFDQAgAEEMakIA\
NwIAIABBFGpCADcCACAAQRxqQgA3AgAgAEEkakIANwIAIABBLGpCADcCACAAQTRqQgA3AgAgAEE8ak\
IANwIAIABCADcCBCAAQQA2AgAgACAAQQRyQX9zakHEAGpBB0kaIABBwAA2AgAgAEHIAGogAEHEABCV\
ARogAUHgAGogAEHIAGpBPGopAgA3AAAgAUHYAGogAEHIAGpBNGopAgA3AAAgAUHQAGogAEHIAGpBLG\
opAgA3AAAgAUHIAGogAEHIAGpBJGopAgA3AAAgAUHAAGogAEHIAGpBHGopAgA3AAAgAUE4aiAAQcgA\
akEUaikCADcAACABQTBqIABByABqQQxqKQIANwAAIAEgACkCTDcAKCABQgA3AwAgAUHoAGpBADoAAC\
ABQQApA6CNQDcDCCABQRBqQQApA6iNQDcDACABQRhqQQApA7CNQDcDACABQSBqQQApA7iNQDcDACAA\
QZABaiQAIAEPCwALiwMBAn8jAEGQAWsiACQAAkBB8AAQGSIBRQ0AIABBDGpCADcCACAAQRRqQgA3Ag\
AgAEEcakIANwIAIABBJGpCADcCACAAQSxqQgA3AgAgAEE0akIANwIAIABBPGpCADcCACAAQgA3AgQg\
AEEANgIAIAAgAEEEckF/c2pBxABqQQdJGiAAQcAANgIAIABByABqIABBxAAQlQEaIAFB4ABqIABByA\
BqQTxqKQIANwAAIAFB2ABqIABByABqQTRqKQIANwAAIAFB0ABqIABByABqQSxqKQIANwAAIAFByABq\
IABByABqQSRqKQIANwAAIAFBwABqIABByABqQRxqKQIANwAAIAFBOGogAEHIAGpBFGopAgA3AAAgAU\
EwaiAAQcgAakEMaikCADcAACABIAApAkw3ACggAUIANwMAIAFB6ABqQQA6AAAgAUEAKQOAjUA3Awgg\
AUEQakEAKQOIjUA3AwAgAUEYakEAKQOQjUA3AwAgAUEgakEAKQOYjUA3AwAgAEGQAWokACABDwsAC/\
sCAQJ/IwBBkAFrIgAkAAJAQegAEBkiAUUNACAAQQxqQgA3AgAgAEEUakIANwIAIABBHGpCADcCACAA\
QSRqQgA3AgAgAEEsakIANwIAIABBNGpCADcCACAAQTxqQgA3AgAgAEIANwIEIABBADYCACAAIABBBH\
JBf3NqQcQAakEHSRogAEHAADYCACAAQcgAaiAAQcQAEJUBGiABQdgAaiAAQcgAakE8aikCADcAACAB\
QdAAaiAAQcgAakE0aikCADcAACABQcgAaiAAQcgAakEsaikCADcAACABQcAAaiAAQcgAakEkaikCAD\
cAACABQThqIABByABqQRxqKQIANwAAIAFBMGogAEHIAGpBFGopAgA3AAAgAUEoaiAAQcgAakEMaikC\
ADcAACABIAApAkw3ACAgAUIANwMAIAFB4ABqQQA6AAAgAUEAKQPojEA3AwggAUEQakEAKQPwjEA3Aw\
AgAUEYakEAKAL4jEA2AgAgAEGQAWokACABDwsAC/sCAQJ/IwBBkAFrIgAkAAJAQegAEBkiAUUNACAB\
QgA3AwAgAUEAKQO4kUA3AwggAUEQakEAKQPAkUA3AwAgAUEYakEAKQPIkUA3AwAgAEEMakIANwIAIA\
BBFGpCADcCACAAQRxqQgA3AgAgAEEkakIANwIAIABBLGpCADcCACAAQTRqQgA3AgAgAEE8akIANwIA\
IABCADcCBCAAQQA2AgAgACAAQQRyQX9zakHEAGpBB0kaIABBwAA2AgAgAEHIAGogAEHEABCVARogAU\
HYAGogAEHIAGpBPGopAgA3AAAgAUHQAGogAEHIAGpBNGopAgA3AAAgAUHIAGogAEHIAGpBLGopAgA3\
AAAgAUHAAGogAEHIAGpBJGopAgA3AAAgAUE4aiAAQcgAakEcaikCADcAACABQTBqIABByABqQRRqKQ\
IANwAAIAFBKGogAEHIAGpBDGopAgA3AAAgASAAKQJMNwAgIAFB4ABqQQA6AAAgAEGQAWokACABDwsA\
C6kDAQF/IAIgAi0AqAEiA2pBAEGoASADaxCUASEDIAJBADoAqAEgA0EfOgAAIAIgAi0ApwFBgAFyOg\
CnASABIAEpAwAgAikAAIU3AwAgASABKQMIIAIpAAiFNwMIIAEgASkDECACKQAQhTcDECABIAEpAxgg\
AikAGIU3AxggASABKQMgIAIpACCFNwMgIAEgASkDKCACKQAohTcDKCABIAEpAzAgAikAMIU3AzAgAS\
ABKQM4IAIpADiFNwM4IAEgASkDQCACKQBAhTcDQCABIAEpA0ggAikASIU3A0ggASABKQNQIAIpAFCF\
NwNQIAEgASkDWCACKQBYhTcDWCABIAEpA2AgAikAYIU3A2AgASABKQNoIAIpAGiFNwNoIAEgASkDcC\
ACKQBwhTcDcCABIAEpA3ggAikAeIU3A3ggASABKQOAASACKQCAAYU3A4ABIAEgASkDiAEgAikAiAGF\
NwOIASABIAEpA5ABIAIpAJABhTcDkAEgASABKQOYASACKQCYAYU3A5gBIAEgASkDoAEgAikAoAGFNw\
OgASABECUgACABQcgBEJUBGgvvAgEDfwJAAkACQAJAIAAtAGgiA0UNAAJAIANBwQBPDQAgAEEoaiIE\
IANqIAFBwAAgA2siAyACIAMgAkkbIgMQlQEaIAAgAC0AaCADaiIFOgBoIAEgA2ohAQJAIAIgA2siAg\
0AQQAhAgwDCyAAQQhqIARBwAAgACkDACAALQBqIABB6QBqIgMtAABFchAYIARBAEHBABCUARogAyAD\
LQAAQQFqOgAADAELIANBwABBlITAABCNAQALQQAhAyACQcEASQ0BIABBCGohBCAAQekAaiIDLQAAIQ\
UDQCAEIAFBwAAgACkDACAALQBqIAVB/wFxRXIQGCADIAMtAABBAWoiBToAACABQcAAaiEBIAJBQGoi\
AkHAAEsNAAsgAC0AaCEFCyAFQf8BcSIDQcEATw0BCyAAIANqQShqIAFBwAAgA2siAyACIAMgAkkbIg\
IQlQEaIAAgAC0AaCACajoAaCAADwsgA0HAAEGUhMAAEI0BAAudAwECfyMAQRBrIgMkACABIAEtAJAB\
IgRqQQBBkAEgBGsQlAEhBCABQQA6AJABIARBAToAACABIAEtAI8BQYABcjoAjwEgACAAKQMAIAEpAA\
CFNwMAIAAgACkDCCABKQAIhTcDCCAAIAApAxAgASkAEIU3AxAgACAAKQMYIAEpABiFNwMYIAAgACkD\
ICABKQAghTcDICAAIAApAyggASkAKIU3AyggACAAKQMwIAEpADCFNwMwIAAgACkDOCABKQA4hTcDOC\
AAIAApA0AgASkAQIU3A0AgACAAKQNIIAEpAEiFNwNIIAAgACkDUCABKQBQhTcDUCAAIAApA1ggASkA\
WIU3A1ggACAAKQNgIAEpAGCFNwNgIAAgACkDaCABKQBohTcDaCAAIAApA3AgASkAcIU3A3AgACAAKQ\
N4IAEpAHiFNwN4IAAgACkDgAEgASkAgAGFNwOAASAAIAApA4gBIAEpAIgBhTcDiAEgABAlIAIgACkD\
ADcAACACIAApAwg3AAggAiAAKQMQNwAQIAIgACkDGD4AGCADQRBqJAALnQMBAn8jAEEQayIDJAAgAS\
ABLQCQASIEakEAQZABIARrEJQBIQQgAUEAOgCQASAEQQY6AAAgASABLQCPAUGAAXI6AI8BIAAgACkD\
ACABKQAAhTcDACAAIAApAwggASkACIU3AwggACAAKQMQIAEpABCFNwMQIAAgACkDGCABKQAYhTcDGC\
AAIAApAyAgASkAIIU3AyAgACAAKQMoIAEpACiFNwMoIAAgACkDMCABKQAwhTcDMCAAIAApAzggASkA\
OIU3AzggACAAKQNAIAEpAECFNwNAIAAgACkDSCABKQBIhTcDSCAAIAApA1AgASkAUIU3A1AgACAAKQ\
NYIAEpAFiFNwNYIAAgACkDYCABKQBghTcDYCAAIAApA2ggASkAaIU3A2ggACAAKQNwIAEpAHCFNwNw\
IAAgACkDeCABKQB4hTcDeCAAIAApA4ABIAEpAIABhTcDgAEgACAAKQOIASABKQCIAYU3A4gBIAAQJS\
ACIAApAwA3AAAgAiAAKQMINwAIIAIgACkDEDcAECACIAApAxg+ABggA0EQaiQAC5YDAQR/IwBBkARr\
IgMkAAJAIAJFDQAgAkGoAWwhBCADQeACakEEciEFIANBsAFqIANBsAFqQQRyIgZBf3NqQawBakEHSR\
oDQCAAKAIAIQIgA0EANgKwASAGQQBBqAEQlAEaIANBqAE2ArABIANB4AJqIANBsAFqQawBEJUBGiAD\
QQhqIAVBqAEQlQEaIAMgAikDADcDCCADIAIpAwg3AxAgAyACKQMQNwMYIAMgAikDGDcDICADIAIpAy\
A3AyggAyACKQMoNwMwIAMgAikDMDcDOCADIAIpAzg3A0AgAyACKQNANwNIIAMgAikDSDcDUCADIAIp\
A1A3A1ggAyACKQNYNwNgIAMgAikDYDcDaCADIAIpA2g3A3AgAyACKQNwNwN4IAMgAikDeDcDgAEgAy\
ACKQOAATcDiAEgAyACKQOIATcDkAEgAyACKQOQATcDmAEgAyACKQOYATcDoAEgAyACKQOgATcDqAEg\
AhAlIAEgA0EIakGoARCVARogAUGoAWohASAEQdh+aiIEDQALCyADQZAEaiQAC/oCAQJ/IwBBkAFrIg\
AkAAJAQegAEBkiAUUNACAAQQxqQgA3AgAgAEEUakIANwIAIABBHGpCADcCACAAQSRqQgA3AgAgAEEs\
akIANwIAIABBNGpCADcCACAAQTxqQgA3AgAgAEIANwIEIABBADYCACAAIABBBHJBf3NqQcQAakEHSR\
ogAEHAADYCACAAQcgAaiAAQcQAEJUBGiABQdgAaiAAQcgAakE8aikCADcAACABQdAAaiAAQcgAakE0\
aikCADcAACABQcgAaiAAQcgAakEsaikCADcAACABQcAAaiAAQcgAakEkaikCADcAACABQThqIABByA\
BqQRxqKQIANwAAIAFBMGogAEHIAGpBFGopAgA3AAAgAUEoaiAAQcgAakEMaikCADcAACABIAApAkw3\
ACAgAUHww8uefDYCGCABQv6568XpjpWZEDcDECABQoHGlLqW8ermbzcDCCABQgA3AwAgAUHgAGpBAD\
oAACAAQZABaiQAIAEPCwAL5AIBBH8jAEGQBGsiAyQAIAMgADYCBCAAQcgBaiEEAkACQAJAAkACQCAA\
QfACai0AACIFRQ0AQagBIAVrIgYgAksNASABIAQgBWogBhCVASAGaiEBIAIgBmshAgsgAiACQagBbi\
IGQagBbCIFSQ0BIANBBGogASAGEDoCQCACIAVrIgINAEEAIQIMBAsgA0EANgKwASADQbABaiADQbAB\
akEEckEAQagBEJQBQX9zakGsAWpBB0kaIANBqAE2ArABIANB4AJqIANBsAFqQawBEJUBGiADQQhqIA\
NB4AJqQQRyQagBEJUBGiADQQRqIANBCGpBARA6IAJBqQFPDQIgASAFaiADQQhqIAIQlQEaIAQgA0EI\
akGoARCVARoMAwsgASAEIAVqIAIQlQEaIAUgAmohAgwCC0HAjMAAQSNBoIzAABBzAAsgAkGoAUGwjM\
AAEIwBAAsgACACOgDwAiADQZAEaiQAC+QCAQR/IwBBsANrIgMkACADIAA2AgQgAEHIAWohBAJAAkAC\
QAJAAkAgAEHQAmotAAAiBUUNAEGIASAFayIGIAJLDQEgASAEIAVqIAYQlQEgBmohASACIAZrIQILIA\
IgAkGIAW4iBkGIAWwiBUkNASADQQRqIAEgBhBDAkAgAiAFayICDQBBACECDAQLIANBADYCkAEgA0GQ\
AWogA0GQAWpBBHJBAEGIARCUAUF/c2pBjAFqQQdJGiADQYgBNgKQASADQaACaiADQZABakGMARCVAR\
ogA0EIaiADQaACakEEckGIARCVARogA0EEaiADQQhqQQEQQyACQYkBTw0CIAEgBWogA0EIaiACEJUB\
GiAEIANBCGpBiAEQlQEaDAMLIAEgBCAFaiACEJUBGiAFIAJqIQIMAgtBwIzAAEEjQaCMwAAQcwALIA\
JBiAFBsIzAABCMAQALIAAgAjoA0AIgA0GwA2okAAuRAwEBfwJAIAJFDQAgASACQagBbGohAyAAKAIA\
IQIDQCACIAIpAwAgASkAAIU3AwAgAiACKQMIIAEpAAiFNwMIIAIgAikDECABKQAQhTcDECACIAIpAx\
ggASkAGIU3AxggAiACKQMgIAEpACCFNwMgIAIgAikDKCABKQAohTcDKCACIAIpAzAgASkAMIU3AzAg\
AiACKQM4IAEpADiFNwM4IAIgAikDQCABKQBAhTcDQCACIAIpA0ggASkASIU3A0ggAiACKQNQIAEpAF\
CFNwNQIAIgAikDWCABKQBYhTcDWCACIAIpA2AgASkAYIU3A2AgAiACKQNoIAEpAGiFNwNoIAIgAikD\
cCABKQBwhTcDcCACIAIpA3ggASkAeIU3A3ggAiACKQOAASABKQCAAYU3A4ABIAIgAikDiAEgASkAiA\
GFNwOIASACIAIpA5ABIAEpAJABhTcDkAEgAiACKQOYASABKQCYAYU3A5gBIAIgAikDoAEgASkAoAGF\
NwOgASACECUgAUGoAWoiASADRw0ACwsL7gIBAn8jAEGQAWsiACQAAkBB4AAQGSIBRQ0AIABBDGpCAD\
cCACAAQRRqQgA3AgAgAEEcakIANwIAIABBJGpCADcCACAAQSxqQgA3AgAgAEE0akIANwIAIABBPGpC\
ADcCACAAQgA3AgQgAEEANgIAIAAgAEEEckF/c2pBxABqQQdJGiAAQcAANgIAIABByABqIABBxAAQlQ\
EaIAFB0ABqIABByABqQTxqKQIANwAAIAFByABqIABByABqQTRqKQIANwAAIAFBwABqIABByABqQSxq\
KQIANwAAIAFBOGogAEHIAGpBJGopAgA3AAAgAUEwaiAAQcgAakEcaikCADcAACABQShqIABByABqQR\
RqKQIANwAAIAFBIGogAEHIAGpBDGopAgA3AAAgASAAKQJMNwAYIAFC/rnrxemOlZkQNwMQIAFCgcaU\
upbx6uZvNwMIIAFCADcDACABQdgAakEAOgAAIABBkAFqJAAgAQ8LAAu8AgEIfwJAAkAgAkEPSw0AIA\
AhAwwBCyAAQQAgAGtBA3EiBGohBQJAIARFDQAgACEDIAEhBgNAIAMgBi0AADoAACAGQQFqIQYgA0EB\
aiIDIAVJDQALCyAFIAIgBGsiB0F8cSIIaiEDAkACQCABIARqIglBA3EiBkUNACAIQQFIDQEgCUF8cS\
IKQQRqIQFBACAGQQN0IgJrQRhxIQQgCigCACEGA0AgBSAGIAJ2IAEoAgAiBiAEdHI2AgAgAUEEaiEB\
IAVBBGoiBSADSQ0ADAILCyAIQQFIDQAgCSEBA0AgBSABKAIANgIAIAFBBGohASAFQQRqIgUgA0kNAA\
sLIAdBA3EhAiAJIAhqIQELAkAgAkUNACADIAJqIQUDQCADIAEtAAA6AAAgAUEBaiEBIANBAWoiAyAF\
SQ0ACwsgAAv6AgEBfyABIAEtAIgBIgNqQQBBiAEgA2sQlAEhAyABQQA6AIgBIANBAToAACABIAEtAI\
cBQYABcjoAhwEgACAAKQMAIAEpAACFNwMAIAAgACkDCCABKQAIhTcDCCAAIAApAxAgASkAEIU3AxAg\
ACAAKQMYIAEpABiFNwMYIAAgACkDICABKQAghTcDICAAIAApAyggASkAKIU3AyggACAAKQMwIAEpAD\
CFNwMwIAAgACkDOCABKQA4hTcDOCAAIAApA0AgASkAQIU3A0AgACAAKQNIIAEpAEiFNwNIIAAgACkD\
UCABKQBQhTcDUCAAIAApA1ggASkAWIU3A1ggACAAKQNgIAEpAGCFNwNgIAAgACkDaCABKQBohTcDaC\
AAIAApA3AgASkAcIU3A3AgACAAKQN4IAEpAHiFNwN4IAAgACkDgAEgASkAgAGFNwOAASAAECUgAiAA\
KQMANwAAIAIgACkDCDcACCACIAApAxA3ABAgAiAAKQMYNwAYC/oCAQF/IAEgAS0AiAEiA2pBAEGIAS\
ADaxCUASEDIAFBADoAiAEgA0EGOgAAIAEgAS0AhwFBgAFyOgCHASAAIAApAwAgASkAAIU3AwAgACAA\
KQMIIAEpAAiFNwMIIAAgACkDECABKQAQhTcDECAAIAApAxggASkAGIU3AxggACAAKQMgIAEpACCFNw\
MgIAAgACkDKCABKQAohTcDKCAAIAApAzAgASkAMIU3AzAgACAAKQM4IAEpADiFNwM4IAAgACkDQCAB\
KQBAhTcDQCAAIAApA0ggASkASIU3A0ggACAAKQNQIAEpAFCFNwNQIAAgACkDWCABKQBYhTcDWCAAIA\
ApA2AgASkAYIU3A2AgACAAKQNoIAEpAGiFNwNoIAAgACkDcCABKQBwhTcDcCAAIAApA3ggASkAeIU3\
A3ggACAAKQOAASABKQCAAYU3A4ABIAAQJSACIAApAwA3AAAgAiAAKQMINwAIIAIgACkDEDcAECACIA\
ApAxg3ABgL5gIBBH8jAEGwA2siAyQAAkAgAkUNACACQYgBbCEEIANBoAJqQQRyIQUgA0GQAWogA0GQ\
AWpBBHIiBkF/c2pBjAFqQQdJGgNAIAAoAgAhAiADQQA2ApABIAZBAEGIARCUARogA0GIATYCkAEgA0\
GgAmogA0GQAWpBjAEQlQEaIANBCGogBUGIARCVARogAyACKQMANwMIIAMgAikDCDcDECADIAIpAxA3\
AxggAyACKQMYNwMgIAMgAikDIDcDKCADIAIpAyg3AzAgAyACKQMwNwM4IAMgAikDODcDQCADIAIpA0\
A3A0ggAyACKQNINwNQIAMgAikDUDcDWCADIAIpA1g3A2AgAyACKQNgNwNoIAMgAikDaDcDcCADIAIp\
A3A3A3ggAyACKQN4NwOAASADIAIpA4ABNwOIASACECUgASADQQhqQYgBEJUBGiABQYgBaiEBIARB+H\
5qIgQNAAsLIANBsANqJAAL2AIBAX8CQCACRQ0AIAEgAkGQAWxqIQMgACgCACECA0AgAiACKQMAIAEp\
AACFNwMAIAIgAikDCCABKQAIhTcDCCACIAIpAxAgASkAEIU3AxAgAiACKQMYIAEpABiFNwMYIAIgAi\
kDICABKQAghTcDICACIAIpAyggASkAKIU3AyggAiACKQMwIAEpADCFNwMwIAIgAikDOCABKQA4hTcD\
OCACIAIpA0AgASkAQIU3A0AgAiACKQNIIAEpAEiFNwNIIAIgAikDUCABKQBQhTcDUCACIAIpA1ggAS\
kAWIU3A1ggAiACKQNgIAEpAGCFNwNgIAIgAikDaCABKQBohTcDaCACIAIpA3AgASkAcIU3A3AgAiAC\
KQN4IAEpAHiFNwN4IAIgAikDgAEgASkAgAGFNwOAASACIAIpA4gBIAEpAIgBhTcDiAEgAhAlIAFBkA\
FqIgEgA0cNAAsLC90CAQF/IAIgAi0AiAEiA2pBAEGIASADaxCUASEDIAJBADoAiAEgA0EfOgAAIAIg\
Ai0AhwFBgAFyOgCHASABIAEpAwAgAikAAIU3AwAgASABKQMIIAIpAAiFNwMIIAEgASkDECACKQAQhT\
cDECABIAEpAxggAikAGIU3AxggASABKQMgIAIpACCFNwMgIAEgASkDKCACKQAohTcDKCABIAEpAzAg\
AikAMIU3AzAgASABKQM4IAIpADiFNwM4IAEgASkDQCACKQBAhTcDQCABIAEpA0ggAikASIU3A0ggAS\
ABKQNQIAIpAFCFNwNQIAEgASkDWCACKQBYhTcDWCABIAEpA2AgAikAYIU3A2AgASABKQNoIAIpAGiF\
NwNoIAEgASkDcCACKQBwhTcDcCABIAEpA3ggAikAeIU3A3ggASABKQOAASACKQCAAYU3A4ABIAEQJS\
AAIAFByAEQlQEaC7MCAQR/QR8hAgJAIAFB////B0sNACABQQYgAUEIdmciAmt2QQFxIAJBAXRrQT5q\
IQILIABCADcCECAAIAI2AhwgAkECdEHU1MAAaiEDAkACQAJAAkACQEEAKALI0kAiBEEBIAJ0IgVxRQ\
0AIAMoAgAiBCgCBEF4cSABRw0BIAQhAgwCC0EAIAQgBXI2AsjSQCADIAA2AgAgACADNgIYDAMLIAFB\
AEEZIAJBAXZrQR9xIAJBH0YbdCEDA0AgBCADQR12QQRxakEQaiIFKAIAIgJFDQIgA0EBdCEDIAIhBC\
ACKAIEQXhxIAFHDQALCyACKAIIIgMgADYCDCACIAA2AgggAEEANgIYIAAgAjYCDCAAIAM2AggPCyAF\
IAA2AgAgACAENgIYCyAAIAA2AgwgACAANgIIC7oCAQV/IAAoAhghAQJAAkACQCAAKAIMIgIgAEcNAC\
AAQRRBECAAQRRqIgIoAgAiAxtqKAIAIgQNAUEAIQIMAgsgACgCCCIEIAI2AgwgAiAENgIIDAELIAIg\
AEEQaiADGyEDA0AgAyEFAkAgBCICQRRqIgMoAgAiBA0AIAJBEGohAyACKAIQIQQLIAQNAAsgBUEANg\
IACwJAIAFFDQACQAJAIAAoAhxBAnRB1NTAAGoiBCgCACAARg0AIAFBEEEUIAEoAhAgAEYbaiACNgIA\
IAINAQwCCyAEIAI2AgAgAg0AQQBBACgCyNJAQX4gACgCHHdxNgLI0kAPCyACIAE2AhgCQCAAKAIQIg\
RFDQAgAiAENgIQIAQgAjYCGAsgAEEUaigCACIERQ0AIAJBFGogBDYCACAEIAI2AhgPCwvFAgEBfwJA\
IAJFDQAgASACQYgBbGohAyAAKAIAIQIDQCACIAIpAwAgASkAAIU3AwAgAiACKQMIIAEpAAiFNwMIIA\
IgAikDECABKQAQhTcDECACIAIpAxggASkAGIU3AxggAiACKQMgIAEpACCFNwMgIAIgAikDKCABKQAo\
hTcDKCACIAIpAzAgASkAMIU3AzAgAiACKQM4IAEpADiFNwM4IAIgAikDQCABKQBAhTcDQCACIAIpA0\
ggASkASIU3A0ggAiACKQNQIAEpAFCFNwNQIAIgAikDWCABKQBYhTcDWCACIAIpA2AgASkAYIU3A2Ag\
AiACKQNoIAEpAGiFNwNoIAIgAikDcCABKQBwhTcDcCACIAIpA3ggASkAeIU3A3ggAiACKQOAASABKQ\
CAAYU3A4ABIAIQJSABQYgBaiIBIANHDQALCwvHAgEBfyABIAEtAGgiA2pBAEHoACADaxCUASEDIAFB\
ADoAaCADQQE6AAAgASABLQBnQYABcjoAZyAAIAApAwAgASkAAIU3AwAgACAAKQMIIAEpAAiFNwMIIA\
AgACkDECABKQAQhTcDECAAIAApAxggASkAGIU3AxggACAAKQMgIAEpACCFNwMgIAAgACkDKCABKQAo\
hTcDKCAAIAApAzAgASkAMIU3AzAgACAAKQM4IAEpADiFNwM4IAAgACkDQCABKQBAhTcDQCAAIAApA0\
ggASkASIU3A0ggACAAKQNQIAEpAFCFNwNQIAAgACkDWCABKQBYhTcDWCAAIAApA2AgASkAYIU3A2Ag\
ABAlIAIgACkDADcAACACIAApAwg3AAggAiAAKQMQNwAQIAIgACkDGDcAGCACIAApAyA3ACAgAiAAKQ\
MoNwAoC8cCAQF/IAEgAS0AaCIDakEAQegAIANrEJQBIQMgAUEAOgBoIANBBjoAACABIAEtAGdBgAFy\
OgBnIAAgACkDACABKQAAhTcDACAAIAApAwggASkACIU3AwggACAAKQMQIAEpABCFNwMQIAAgACkDGC\
ABKQAYhTcDGCAAIAApAyAgASkAIIU3AyAgACAAKQMoIAEpACiFNwMoIAAgACkDMCABKQAwhTcDMCAA\
IAApAzggASkAOIU3AzggACAAKQNAIAEpAECFNwNAIAAgACkDSCABKQBIhTcDSCAAIAApA1AgASkAUI\
U3A1AgACAAKQNYIAEpAFiFNwNYIAAgACkDYCABKQBghTcDYCAAECUgAiAAKQMANwAAIAIgACkDCDcA\
CCACIAApAxA3ABAgAiAAKQMYNwAYIAIgACkDIDcAICACIAApAyg3ACgLmwIBAX8gASABLQBIIgNqQQ\
BByAAgA2sQlAEhAyABQQA6AEggA0EBOgAAIAEgAS0AR0GAAXI6AEcgACAAKQMAIAEpAACFNwMAIAAg\
ACkDCCABKQAIhTcDCCAAIAApAxAgASkAEIU3AxAgACAAKQMYIAEpABiFNwMYIAAgACkDICABKQAghT\
cDICAAIAApAyggASkAKIU3AyggACAAKQMwIAEpADCFNwMwIAAgACkDOCABKQA4hTcDOCAAIAApA0Ag\
ASkAQIU3A0AgABAlIAIgACkDADcAACACIAApAwg3AAggAiAAKQMQNwAQIAIgACkDGDcAGCACIAApAy\
A3ACAgAiAAKQMoNwAoIAIgACkDMDcAMCACIAApAzg3ADgLmwIBAX8gASABLQBIIgNqQQBByAAgA2sQ\
lAEhAyABQQA6AEggA0EGOgAAIAEgAS0AR0GAAXI6AEcgACAAKQMAIAEpAACFNwMAIAAgACkDCCABKQ\
AIhTcDCCAAIAApAxAgASkAEIU3AxAgACAAKQMYIAEpABiFNwMYIAAgACkDICABKQAghTcDICAAIAAp\
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\
ACABECJBBCEBDAELIAEgBUECdBAmIgFFDQILIAAgBTYCBCAAIAE2AgAgBkEQaiQADwtBwI7AAEEwEJ\
MBAAsAC4MBAQF/IwBBEGsiBSQAIAUgASACIAMgBBAOIAVBCGooAgAhBCAFKAIEIQMCQAJAIAUoAgAN\
ACAAIAQ2AgQgACADNgIADAELIAMgBBAAIQQgAEEANgIAIAAgBDYCBAsCQCABQQVHDQAgAigCkAFFDQ\
AgAkEANgKQAQsgAhAiIAVBEGokAAt+AQF/IwBBwABrIgQkACAEQSs2AgwgBCAANgIIIAQgAjYCFCAE\
IAE2AhAgBEEsakECNgIAIARBPGpBATYCACAEQgI3AhwgBEG8iMAANgIYIARBAjYCNCAEIARBMGo2Ai\
ggBCAEQRBqNgI4IAQgBEEIajYCMCAEQRhqIAMQeAALdQECfyMAQZACayICJABBACEDIAJBADYCAANA\
IAIgA2pBBGogASADaigAADYCACACIANBBGoiAzYCACADQYABRw0ACyACQYgBaiACQYQBEJUBGiAAIA\
JBiAFqQQRyQYABEJUBIAEtAIABOgCAASACQZACaiQAC3UBAn8jAEGwAmsiAiQAQQAhAyACQQA2AgAD\
QCACIANqQQRqIAEgA2ooAAA2AgAgAiADQQRqIgM2AgAgA0GQAUcNAAsgAkGYAWogAkGUARCVARogAC\
ACQZgBakEEckGQARCVASABLQCQAToAkAEgAkGwAmokAAt1AQJ/IwBBoAJrIgIkAEEAIQMgAkEANgIA\
A0AgAiADakEEaiABIANqKAAANgIAIAIgA0EEaiIDNgIAIANBiAFHDQALIAJBkAFqIAJBjAEQlQEaIA\
AgAkGQAWpBBHJBiAEQlQEgAS0AiAE6AIgBIAJBoAJqJAALcwECfyMAQeABayICJABBACEDIAJBADYC\
AANAIAIgA2pBBGogASADaigAADYCACACIANBBGoiAzYCACADQegARw0ACyACQfAAaiACQewAEJUBGi\
AAIAJB8ABqQQRyQegAEJUBIAEtAGg6AGggAkHgAWokAAtzAQJ/IwBBoAFrIgIkAEEAIQMgAkEANgIA\
A0AgAiADakEEaiABIANqKAAANgIAIAIgA0EEaiIDNgIAIANByABHDQALIAJB0ABqIAJBzAAQlQEaIA\
AgAkHQAGpBBHJByAAQlQEgAS0ASDoASCACQaABaiQAC3UBAn8jAEHgAmsiAiQAQQAhAyACQQA2AgAD\
QCACIANqQQRqIAEgA2ooAAA2AgAgAiADQQRqIgM2AgAgA0GoAUcNAAsgAkGwAWogAkGsARCVARogAC\
ACQbABakEEckGoARCVASABLQCoAToAqAEgAkHgAmokAAt7AQJ/IwBBMGsiAiQAIAJBFGpBAjYCACAC\
QdyHwAA2AhAgAkECNgIMIAJBvIfAADYCCCABQRxqKAIAIQMgASgCGCEBIAJBAjYCLCACQgI3AhwgAk\
G8iMAANgIYIAIgAkEIajYCKCABIAMgAkEYahArIQEgAkEwaiQAIAELewECfyMAQTBrIgIkACACQRRq\
QQI2AgAgAkHch8AANgIQIAJBAjYCDCACQbyHwAA2AgggAUEcaigCACEDIAEoAhghASACQQI2AiwgAk\
ICNwIcIAJBvIjAADYCGCACIAJBCGo2AiggASADIAJBGGoQKyEBIAJBMGokACABC2wBAX8jAEEwayID\
JAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAzcCDCADQbiLwAA2AgggA0EDNg\
IkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhB4AAtsAQF/IwBBMGsiAyQAIAMgATYC\
BCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0GYiMAANgIIIANBAzYCJCADIANBIG\
o2AhggAyADNgIoIAMgA0EEajYCICADQQhqIAIQeAALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIA\
IANBHGpBAjYCACADQSxqQQM2AgAgA0ICNwIMIANByIrAADYCCCADQQM2AiQgAyADQSBqNgIYIAMgA0\
EEajYCKCADIAM2AiAgA0EIaiACEHgAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2\
AgAgA0EsakEDNgIAIANCAjcCDCADQeiKwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIANBBGo2AiggAy\
ADNgIgIANBCGogAhB4AAtXAQJ/AkACQCAARQ0AIAAoAgANASAAQQA2AgAgACgCCCEBIAAoAgQhAiAA\
ECICQCACQQVHDQAgASgCkAFFDQAgAUEANgKQAQsgARAiDwsQkQEACxCSAQALWAECf0EAQQAoAsDSQC\
IBQQFqNgLA0kBBAEEAKAKI1kBBAWoiAjYCiNZAAkAgAUEASA0AIAJBAksNAEEAKAK80kBBf0wNACAC\
QQFLDQAgAEUNABCYAQALAAtKAQN/QQAhAwJAIAJFDQACQANAIAAtAAAiBCABLQAAIgVHDQEgAEEBai\
EAIAFBAWohASACQX9qIgJFDQIMAAsLIAQgBWshAwsgAwtGAAJAAkAgAUUNACABKAIADQEgAUF/NgIA\
IAFBBGooAgAgAUEIaigCACACEFAgAUEANgIAIABCADcDAA8LEJEBAAsQkgEAC0cBAX8jAEEgayIDJA\
AgA0EUakEANgIAIANBsJDAADYCECADQgE3AgQgAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEHgA\
C4sBACAAQgA3A0AgAEL5wvibkaOz8NsANwM4IABC6/qG2r+19sEfNwMwIABCn9j52cKR2oKbfzcDKC\
AAQtGFmu/6z5SH0QA3AyAgAELx7fT4paf9p6V/NwMYIABCq/DT9K/uvLc8NwMQIABCu86qptjQ67O7\
fzcDCCAAIAGtQoiS95X/zPmE6gCFNwMAC0UBAn8jAEEQayIBJAACQCAAKAIIIgINAEGwkMAAQStB+J\
DAABBzAAsgASAAKAIMNgIIIAEgADYCBCABIAI2AgAgARB8AAtCAQF/AkACQAJAIAJBgIDEAEYNAEEB\
IQQgACACIAEoAhARBgANAQsgAw0BQQAhBAsgBA8LIAAgA0EAIAEoAgwRCAALPwEBfyMAQSBrIgAkAC\
AAQRxqQQA2AgAgAEGwkMAANgIYIABCATcCDCAAQaCCwAA2AgggAEEIakGogsAAEHgACz4BAX8jAEEg\
ayICJAAgAkEBOgAYIAIgATYCFCACIAA2AhAgAkGoiMAANgIMIAJBsJDAADYCCCACQQhqEHUACz0BAn\
8gACgCACIBQRRqKAIAIQICQAJAIAEoAgQOAgAAAQsgAg0AIAAoAgQtABAQcAALIAAoAgQtABAQcAAL\
MwACQCAAQfz///8HSw0AAkAgAA0AQQQPCyAAIABB/f///wdJQQJ0EDEiAEUNACAADwsAC1IAIABCx8\
yj2NbQ67O7fzcDCCAAQgA3AwAgAEEgakKrs4/8kaOz8NsANwMAIABBGGpC/6S5iMWR2oKbfzcDACAA\
QRBqQvLmu+Ojp/2npX83AwALLAEBfyMAQRBrIgEkACABQQhqIABBCGooAgA2AgAgASAAKQIANwMAIA\
EQeQALJgACQCAADQBBwI7AAEEwEJMBAAsgACACIAMgBCAFIAEoAhARDAALJAACQCAADQBBwI7AAEEw\
EJMBAAsgACACIAMgBCABKAIQEQoACyQAAkAgAA0AQcCOwABBMBCTAQALIAAgAiADIAQgASgCEBEJAA\
skAAJAIAANAEHAjsAAQTAQkwEACyAAIAIgAyAEIAEoAhARCgALJAACQCAADQBBwI7AAEEwEJMBAAsg\
ACACIAMgBCABKAIQEQkACyQAAkAgAA0AQcCOwABBMBCTAQALIAAgAiADIAQgASgCEBEJAAskAAJAIA\
ANAEHAjsAAQTAQkwEACyAAIAIgAyAEIAEoAhARFwALJAACQCAADQBBwI7AAEEwEJMBAAsgACACIAMg\
BCABKAIQERgACyQAAkAgAA0AQcCOwABBMBCTAQALIAAgAiADIAQgASgCEBEWAAsiAAJAIAANAEHAjs\
AAQTAQkwEACyAAIAIgAyABKAIQEQcACyAAAkACQCABQfz///8HSw0AIAAgAhAmIgENAQsACyABCyAA\
AkAgAA0AQcCOwABBMBCTAQALIAAgAiABKAIQEQYACxQAIAAoAgAgASAAKAIEKAIMEQYACxAAIAEgAC\
gCACAAKAIEEBwLDgACQCABRQ0AIAAQIgsLCwAgACABIAIQbgALCwAgACABIAIQbQALEQBBuILAAEEv\
QbiDwAAQcwALDQAgACgCABoDfwwACwsLACAAIwBqJAAjAAsNAEHQ0cAAQRsQkwEACw4AQevRwABBzw\
AQkwEACwkAIAAgARALAAsKACAAIAEgAhBTCwoAIAAgASACEEALCgAgACABIAIQcQsMAEK4ic+XicbR\
+EwLAwAACwIACwvE0oCAAAEAQYCAwAALulLQBRAAUAAAAJUAAAAJAAAAQkxBS0UyQkJMQUtFMkItMj\
I0QkxBS0UyQi0yNTZCTEFLRTJCLTM4NEJMQUtFMlNCTEFLRTNLRUNDQUstMjI0S0VDQ0FLLTI1NktF\
Q0NBSy0zODRLRUNDQUstNTEyTUQ0TUQ1UklQRU1ELTE2MFNIQS0xU0hBLTIyNFNIQS0yNTZTSEEtMz\
g0U0hBLTUxMlRJR0VSdW5zdXBwb3J0ZWQgYWxnb3JpdGhtbm9uLWRlZmF1bHQgbGVuZ3RoIHNwZWNp\
ZmllZCBmb3Igbm9uLWV4dGVuZGFibGUgYWxnb3JpdGhtbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy\
5yc2NhcGFjaXR5IG92ZXJmbG93AAANARAAEQAAAPEAEAAcAAAABgIAAAUAAABBcnJheVZlYzogY2Fw\
YWNpdHkgZXhjZWVkZWQgaW4gZXh0ZW5kL2Zyb21faXRlcn4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naX\
RodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYXJyYXl2ZWMtMC43LjIvc3JjL2FycmF5dmVjLnJzAGcB\
EABQAAAAAQQAAAUAAAB+Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOW\
VjODIzL2JsYWtlMy0xLjMuMS9zcmMvbGliLnJzAAAAyAEQAEkAAAC5AQAACQAAAMgBEABJAAAAXwIA\
AAoAAADIARAASQAAAI0CAAAJAAAAyAEQAEkAAACNAgAANAAAAMgBEABJAAAAuQIAAB8AAADIARAASQ\
AAAN0CAAAKAAAAyAEQAEkAAADWAgAACQAAAMgBEABJAAAAAQMAABkAAADIARAASQAAAAMDAAAJAAAA\
yAEQAEkAAAADAwAAOAAAAMgBEABJAAAA+AMAAB4AAADIARAASQAAAKoEAAAWAAAAyAEQAEkAAAC8BA\
AAFgAAAMgBEABJAAAA7QQAABIAAADIARAASQAAAPcEAAASAAAAyAEQAEkAAABpBQAAIQAAABEAAAAE\
AAAABAAAABIAAAB+Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjOD\
IzL2FycmF5dmVjLTAuNy4yL3NyYy9hcnJheXZlY19pbXBsLnJzAAAAJAMQAFUAAAAnAAAACQAAABEA\
AAAEAAAABAAAABIAAAARAAAAIAAAAAEAAAATAAAAQ2FwYWNpdHlFcnJvcgAAAKwDEAANAAAAaW5zdW\
ZmaWNpZW50IGNhcGFjaXR5AAAAxAMQABUAAAApaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBp\
cyAgYnV0IHRoZSBpbmRleCBpcyAA5QMQACAAAAAFBBAAEgAAABEAAAAAAAAAAQAAABQAAAA6IAAAMA\
gQAAAAAAA4BBAAAgAAADAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIx\
MjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MD\
UxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4\
MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5cmFuZ2Ugc3RhcnQgaW5kZXggIG\
91dCBvZiByYW5nZSBmb3Igc2xpY2Ugb2YgbGVuZ3RoIBQFEAASAAAAJgUQACIAAAByYW5nZSBlbmQg\
aW5kZXggWAUQABAAAAAmBRAAIgAAAHNvdXJjZSBzbGljZSBsZW5ndGggKCkgZG9lcyBub3QgbWF0Y2\
ggZGVzdGluYXRpb24gc2xpY2UgbGVuZ3RoICh4BRAAFQAAAI0FEAArAAAA5AMQAAEAAAB+Ly5jYXJn\
by9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Jsb2NrLWJ1ZmZlci0wLj\
EwLjAvc3JjL2xpYi5yc9AFEABQAAAAPwEAAB4AAADQBRAAUAAAAPwAAAAnAAAAYXNzZXJ0aW9uIGZh\
aWxlZDogbWlkIDw9IHNlbGYubGVuKCkAAAAAAAEjRWeJq83v/ty6mHZUMhDw4dLDAAAAAGfmCWqFrm\
e7cvNuPDr1T6V/Ug5RjGgFm6vZgx8ZzeBb2J4FwQfVfDYX3XAwOVkO9zELwP8RFVhop4/5ZKRP+r4I\
ybzzZ+YJajunyoSFrme7K/iU/nLzbjzxNh1fOvVPpdGC5q1/Ug5RH2w+K4xoBZtrvUH7q9mDH3khfh\
MZzeBb2J4FwV2du8sH1Xw2KimaYhfdcDBaAVmROVkO99jsLxUxC8D/ZyYzZxEVWGiHSrSOp4/5ZA0u\
DNukT/q+HUi1R2Nsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBkZXN0cm95ZWQgYWxyZWFkeQ\
EAAAAAAAAAgoAAAAAAAACKgAAAAAAAgACAAIAAAACAi4AAAAAAAAABAACAAAAAAIGAAIAAAACACYAA\
AAAAAICKAAAAAAAAAIgAAAAAAAAACYAAgAAAAAAKAACAAAAAAIuAAIAAAAAAiwAAAAAAAICJgAAAAA\
AAgAOAAAAAAACAAoAAAAAAAICAAAAAAAAAgAqAAAAAAAAACgAAgAAAAICBgACAAAAAgICAAAAAAACA\
AQAAgAAAAAAIgACAAAAAgGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdW\
VsaWJyYXJ5L3N0ZC9zcmMvcGFuaWNraW5nLnJzAFsIEAAcAAAARwIAAA8AAABjYWxsZWQgYFJlc3Vs\
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\
9ZY43HWPsT2PY6qOgOmrjTU5n6xyC8CR+t63ki1JYv1BVWtbTS756N7GbX7qvsSrVz81zpBW2tZpV3\
OEFDlCpkojCp0N+CiAUPn2FfKzeqIZ47hNGjRREZytMQVY73ulIjx3M4aWBxpWx0U2vp0kntoT+WhM\
pnibLWXa7zTDO3+pJ0z0F2vmIBJidgt9zZqJQ3eWgmft4Mpb7vP8ecgANnWfQLZtkrU5mtAGiMV6Mb\
Cug28hHziGSsrmASUwn9FiNP9m+zv93SR8IHLr4uzi07b2St4I6se+TZmcxIuasJflrEm6lwfPZkeM\
s3UqfMVzkxsTWB6TYc4sgrEMHLoJuVV1ndIRfZPdr38S5JJtxq072im87MJUcdXBoiT+9oJNE8VYTy\
diW1HjOhwmgcsBLsgH6ct/4xMZCe34yUYAyPnYSTJj+4jj7ZvPgJ7xbBGaU4EYVyTVa/fzA1Go90eu\
9ea3Fc+cftTextfbGrsoAkFc5USZTtteJdRHtjD8qrgriBFdKiHTKbuLCfWzlgLpFOq1j1oC3VchlH\
tntayQo8DnWPsBSr2DTGfTiTu580vfpC2eKUirjDIexPxSLFi6lozzA7Jd2H+9vdHKg66CYMFCtLuw\
mtqla+hfuT+pcTdnBC6y2FIxSclYU4QeVLSXhkgqvmZpjtMt3KKVK4U8kqwRLMB7qPINmbGII743Tx\
v6CIB8A+VUTcjQcB/UV85+7K2QVDo6BtknPCsAv6IwgISjrn7AAyDtbTICxoZAqWl9KKeDinr1MMtf\
esV55+t55ERotem83AUPtHOj4g5XiG54Gteg9ui9zbqchy+jZMG80WqXi9dmll7iIas8w+XlqmMQkJ\
CNaUhEsxiYu4oePq6HZOO03DuJMfm9rxnVu1/coEVjymWUmyb+KIbsUZw/YAFdHrdJUKEGQORNsct2\
9+VwbL/tK1Xv8hgSQaM2WnAIBwzLRGCYT3UUTecOKKgOQ9lWzWVQX1PXkSXBlu8KcvEjMsgfpWNzbz\
mgw251bGwgcG9pbnRlciBwYXNzZWQgdG8gcnVzdHJlY3Vyc2l2ZSB1c2Ugb2YgYW4gb2JqZWN0IGRl\
dGVjdGVkIHdoaWNoIHdvdWxkIGxlYWQgdG8gdW5zYWZlIGFsaWFzaW5nIGluIHJ1c3QAttCAgAAEbm\
FtZQGr0ICAAJoBAEVqc19zeXM6OlR5cGVFcnJvcjo6bmV3OjpfX3diZ19uZXdfZGIyNTRhZTBhMWJi\
MGZmNTo6aGU1YTViY2I5N2UzNWVlOTEBO3dhc21fYmluZGdlbjo6X193YmluZGdlbl9vYmplY3RfZH\
JvcF9yZWY6Omg3MDI4MTAxYzVkZDAzMWM5AlVqc19zeXM6OlVpbnQ4QXJyYXk6OmJ5dGVfbGVuZ3Ro\
OjpfX3diZ19ieXRlTGVuZ3RoXzg3YTA0MzZhNzRhZGMyNmM6OmhjZDQ0M2I5NTE3NDg1ZTQ4A1Vqc1\
9zeXM6OlVpbnQ4QXJyYXk6OmJ5dGVfb2Zmc2V0OjpfX3diZ19ieXRlT2Zmc2V0XzQ0NzdkNTQ3MTBh\
ZjZmOWI6OmgxOTBhYjU2ZGQxMmViZjEyBExqc19zeXM6OlVpbnQ4QXJyYXk6OmJ1ZmZlcjo6X193Ym\
dfYnVmZmVyXzIxMzEwZWExNzI1N2IwYjQ6Omg3NTEzNDhhMDRjMjc1ZDk3BXlqc19zeXM6OlVpbnQ4\
QXJyYXk6Om5ld193aXRoX2J5dGVfb2Zmc2V0X2FuZF9sZW5ndGg6Ol9fd2JnX25ld3dpdGhieXRlb2\
Zmc2V0YW5kbGVuZ3RoX2Q5YWEyNjY3MDNjYjk4YmU6OmgxNDIxMzk4ZDhkMjBlYjY4Bkxqc19zeXM6\
OlVpbnQ4QXJyYXk6Omxlbmd0aDo6X193YmdfbGVuZ3RoXzllMWFlMTkwMGNiMGZiZDU6OmgzMDRhZT\
U1ZDBjYjNkZGQ3BzJ3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fbWVtb3J5OjpoOThkMDcxZmRlMWQ2\
M2Q3ZghVanNfc3lzOjpXZWJBc3NlbWJseTo6TWVtb3J5OjpidWZmZXI6Ol9fd2JnX2J1ZmZlcl8zZj\
NkNzY0ZDQ3NDdkNTY0OjpoNzYxM2VjZTFiNjI1N2QwYwlGanNfc3lzOjpVaW50OEFycmF5OjpuZXc6\
Ol9fd2JnX25ld184YzNmMDA1MjI3MmE0NTdhOjpoOTM5NDM5OWIzMzA3MmJkZQpGanNfc3lzOjpVaW\
50OEFycmF5OjpzZXQ6Ol9fd2JnX3NldF84M2RiOTY5MGY5MzUzZTc5OjpoMmMzYTNhZjQxYmVlN2Uw\
Ygsxd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3Rocm93OjpoZDI2NjNkNGU1YTBiZjQ3YgxAZGVub1\
9zdGRfd2FzbV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6ZGlnZXN0OjpoMGZkNzY4MDY4OThmNjM5\
Nw0sc2hhMjo6c2hhNTEyOjpjb21wcmVzczUxMjo6aDgwYjZjM2U0MjZhMGQ1ZjMOSmRlbm9fc3RkX3\
dhc21fY3J5cHRvOjpkaWdlc3Q6OkNvbnRleHQ6OmRpZ2VzdF9hbmRfcmVzZXQ6Omg2OTAzZDQxYWVk\
Yjc2ZDQ2DyxzaGEyOjpzaGEyNTY6OmNvbXByZXNzMjU2OjpoMDIxMDEwM2M3YjNkYzIyORATZGlnZX\
N0Y29udGV4dF9jbG9uZRFAZGVub19zdGRfd2FzbV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6dXBk\
YXRlOjpoOGMwN2Y3YmEwMDA1YWYwNBIzYmxha2UyOjpCbGFrZTJiVmFyQ29yZTo6Y29tcHJlc3M6Om\
hjMmYzMDEzNTFjMzhhNmZiEylyaXBlbWQ6OmMxNjA6OmNvbXByZXNzOjpoMjdkNWNhZGNlN2JhNjNm\
NxQzYmxha2UyOjpCbGFrZTJzVmFyQ29yZTo6Y29tcHJlc3M6OmgzNDI0ZTU5MjA4NzM1ZjAxFStzaG\
ExOjpjb21wcmVzczo6Y29tcHJlc3M6Omg2OGNiMGVhYTU0ZmNmZDljFix0aWdlcjo6Y29tcHJlc3M6\
OmNvbXByZXNzOjpoYTVmYzQxYjA5Y2I1NTFjYhctYmxha2UzOjpPdXRwdXRSZWFkZXI6OmZpbGw6Om\
gxNDk4OTZiZjFmMzRjOWNmGDZibGFrZTM6OnBvcnRhYmxlOjpjb21wcmVzc19pbl9wbGFjZTo6aDNi\
MTcwNDFlM2EyYWQ0ZjEZOmRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46Om1hbGxvYzo6aG\
E5NmZjZWZiYjQ0ZDZkYTUaZTxkaWdlc3Q6OmNvcmVfYXBpOjp3cmFwcGVyOjpDb3JlV3JhcHBlcjxU\
PiBhcyBkaWdlc3Q6OlVwZGF0ZT46OnVwZGF0ZTo6e3tjbG9zdXJlfX06Omg5OGEyNmM3ZjA2NjRkMz\
MzG2g8bWQ1OjpNZDVDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZp\
bmFsaXplX2ZpeGVkX2NvcmU6Ont7Y2xvc3VyZX19OjpoZjQwOGE4NDJlNzQwM2Y0ZRwsY29yZTo6Zm\
10OjpGb3JtYXR0ZXI6OnBhZDo6aDhjNzUzZTQ5NGY3YjU2OWQdIG1kNDo6Y29tcHJlc3M6OmhlYjZl\
YTc3NjgzMDc5MTJjHjBibGFrZTM6OmNvbXByZXNzX3N1YnRyZWVfd2lkZTo6aGQxY2IwNWY0NTBhYT\
cwZWQfL2JsYWtlMzo6SGFzaGVyOjpmaW5hbGl6ZV94b2Y6Omg1YzQ3NGJhNjI1NWZhOTU5IBNkaWdl\
c3Rjb250ZXh0X3Jlc2V0IT1kZW5vX3N0ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0OjpuZX\
c6Omg2YWExMzU3YWVjN2E0NmIxIjhkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpmcmVl\
OjpoYTQ3MzdiN2Y4NDk3MGFkZCNyPHNoYTI6OmNvcmVfYXBpOjpTaGE1MTJWYXJDb3JlIGFzIGRpZ2\
VzdDo6Y29yZV9hcGk6OlZhcmlhYmxlT3V0cHV0Q29yZT46OmZpbmFsaXplX3ZhcmlhYmxlX2NvcmU6\
OmgwNDU2Yzg2YjQ3NWNjOWIxJEFkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpkaXNwb3\
NlX2NodW5rOjpoM2I2YzRlNzRmYThhYTA0YiUga2VjY2FrOjpmMTYwMDo6aDM0YmRlNTM0MGY3NGE2\
YTgmDl9fcnVzdF9yZWFsbG9jJ3I8c2hhMjo6Y29yZV9hcGk6OlNoYTI1NlZhckNvcmUgYXMgZGlnZX\
N0Ojpjb3JlX2FwaTo6VmFyaWFibGVPdXRwdXRDb3JlPjo6ZmluYWxpemVfdmFyaWFibGVfY29yZTo6\
aGZhMzUyNzAwMzRlYzgyZDUoTmNvcmU6OmZtdDo6bnVtOjppbXA6OjxpbXBsIGNvcmU6OmZtdDo6RG\
lzcGxheSBmb3IgdTMyPjo6Zm10OjpoYzUwYTFjOWI4MmViNDQ0NildPHNoYTE6OlNoYTFDb3JlIGFz\
IGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Om\
g5OTZiY2RmNDE2MTUwYzExKjFibGFrZTM6Okhhc2hlcjo6bWVyZ2VfY3Zfc3RhY2s6Omg3MTMzMTRm\
ZWQ4YjMxMjcwKyNjb3JlOjpmbXQ6OndyaXRlOjpoZWQ4ZmU3ZDA5NTQ3OWVhMixkPHJpcGVtZDo6Um\
lwZW1kMTYwQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6\
ZV9maXhlZF9jb3JlOjpoMzkxZjg1Y2JlMzY3YmE0OC00Ymxha2UzOjpjb21wcmVzc19wYXJlbnRzX3\
BhcmFsbGVsOjpoNjI3NDYyMTFkMGE0ZGFjMi5bPG1kNDo6TWQ0Q29yZSBhcyBkaWdlc3Q6OmNvcmVf\
YXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoZTgxNjA3N2Y4NzdhYj\
RiZS9bPG1kNTo6TWQ1Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+Ojpm\
aW5hbGl6ZV9maXhlZF9jb3JlOjpoYTIzMWI4OGE4ODcyM2ViMjBfPHRpZ2VyOjpUaWdlckNvcmUgYX\
MgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6\
aGJhMjU4N2Y0Y2ZlYjRjNjAxMGRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6bWFsbG9jOjpoMDA1NzM1Nj\
dhMzMzOGRmODJMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+\
OjpkZWZhdWx0OjpoNmQwOGY1ZjVlYzRmYTVmMjNMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcm\
U6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoMDQyN2VjY2YzNzk5NTdiYzRMPGFsbG9jOjpi\
b3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoN2QwMmNjMm\
IyM2Q1NTlkZDVMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+\
OjpkZWZhdWx0OjpoNGMyYjExMDJkOTJlYjg2MjZkPHNoYTM6OlNoYWtlMTI4Q29yZSBhcyBkaWdlc3\
Q6OmNvcmVfYXBpOjpFeHRlbmRhYmxlT3V0cHV0Q29yZT46OmZpbmFsaXplX3hvZl9jb3JlOjpoN2Fl\
Yjk4ODRiZjgwZGI5ZjctYmxha2UzOjpDaHVua1N0YXRlOjp1cGRhdGU6OmhjYWRlYzU5N2NiOTJhOD\
hlOGI8c2hhMzo6S2VjY2FrMjI0Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENv\
cmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoMGY5NDA1NjkzYWY0MTk1ZDlhPHNoYTM6OlNoYTNfMj\
I0Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhl\
ZF9jb3JlOjpoNjQ0NjcyYWEwOWQyMzczNDpyPGRpZ2VzdDo6Y29yZV9hcGk6OnhvZl9yZWFkZXI6Ol\
hvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZGVyPjo6cmVhZDo6e3tjbG9z\
dXJlfX06OmhjMGIxNDZkODFjOGUxYTJlO0w8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6ZG\
VmYXVsdDo6RGVmYXVsdD46OmRlZmF1bHQ6OmhhMDc5MzUyNTQ2MTRlMDI5PGU8ZGlnZXN0Ojpjb3Jl\
X2FwaTo6eG9mX3JlYWRlcjo6WG9mUmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpYb2ZSZW\
FkZXI+OjpyZWFkOjpoMTU0NmE3ZDc5MjNlYmVmNT1lPGRpZ2VzdDo6Y29yZV9hcGk6OnhvZl9yZWFk\
ZXI6OlhvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZGVyPjo6cmVhZDo6aD\
EzYWE2NDZkYmJiZjJkM2M+ZTxkaWdlc3Q6OmNvcmVfYXBpOjp3cmFwcGVyOjpDb3JlV3JhcHBlcjxU\
PiBhcyBkaWdlc3Q6OlVwZGF0ZT46OnVwZGF0ZTo6e3tjbG9zdXJlfX06Omg0MzY0MDRjNjQ1NDYwZG\
Q4P0w8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46OmRlZmF1\
bHQ6Omg1NzY4YjMxZGE5ZWVmYjhjQDFjb21waWxlcl9idWlsdGluczo6bWVtOjptZW1jcHk6Omg0NW\
ViNTM2MDFkOWQ2YmYwQWI8c2hhMzo6S2VjY2FrMjU2Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpG\
aXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoN2RhMzE4ZDEyOTc0ZDdkOEJhPH\
NoYTM6OlNoYTNfMjU2Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+Ojpm\
aW5hbGl6ZV9maXhlZF9jb3JlOjpoNjY0NjM3NDQ5NmFiNGI2NkNyPGRpZ2VzdDo6Y29yZV9hcGk6On\
hvZl9yZWFkZXI6OlhvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZGVyPjo6\
cmVhZDo6e3tjbG9zdXJlfX06OmgwYmYzMWE1MWMzYzRhNTNjRGU8ZGlnZXN0Ojpjb3JlX2FwaTo6d3\
JhcHBlcjo6Q29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpVcGRhdGU+Ojp1cGRhdGU6Ont7Y2xvc3Vy\
ZX19OjpoN2ExNmQxNDcyMDQ3NWE0ZUVkPHNoYTM6OlNoYWtlMjU2Q29yZSBhcyBkaWdlc3Q6OmNvcm\
VfYXBpOjpFeHRlbmRhYmxlT3V0cHV0Q29yZT46OmZpbmFsaXplX3hvZl9jb3JlOjpoMDk2NTY4MjQ1\
YzEyMzEzOUZGZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6aW5zZXJ0X2xhcmdlX2NodW\
5rOjpoYjEyOTkwZjkyNTM4ZmJiZkdGZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6dW5s\
aW5rX2xhcmdlX2NodW5rOjpoYmU4ZDM2YTlmNDA2MGNlZUhlPGRpZ2VzdDo6Y29yZV9hcGk6OndyYX\
BwZXI6OkNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYXRlOjp7e2Nsb3N1cmV9\
fTo6aDkwZTcxOTliNmM5Yzg0ZDVJYjxzaGEzOjpLZWNjYWszODRDb3JlIGFzIGRpZ2VzdDo6Y29yZV\
9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmhjNzMxNWU3MjdiNDk4\
ZjJiSmE8c2hhMzo6U2hhM18zODRDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q2\
9yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmhiMjgxYjZkYWM5MzM5NzYxS2I8c2hhMzo6S2VjY2Fr\
NTEyQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maX\
hlZF9jb3JlOjpoMTE4YWVmNjA5MWUyNDczN0xhPHNoYTM6OlNoYTNfNTEyQ29yZSBhcyBkaWdlc3Q6\
OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoMTJkOWIyMW\
RhNzk0M2E2MU1MPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+\
OjpkZWZhdWx0OjpoYTEzNzIzMDcwMWQ4YTA4NE5MPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcm\
U6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoMGM5YTJiNDA4NmExNDk1OU9lPGRpZ2VzdDo6\
Y29yZV9hcGk6OndyYXBwZXI6OkNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYX\
RlOjp7e2Nsb3N1cmV9fTo6aDI5YmQ4NWE4MDU5NjlhMGZQPmRlbm9fc3RkX3dhc21fY3J5cHRvOjpE\
aWdlc3RDb250ZXh0Ojp1cGRhdGU6Omg2ZmM2MzZkMTdkYTI1MDM1UVs8YmxvY2tfYnVmZmVyOjpCbG\
9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6Omgw\
NzFjYWI4NjlkMDlhNzgzUgZkaWdlc3RTMWNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbXNldDo6aD\
ViOGI5OThhNGIyZmIyMDVUZTxkaWdlc3Q6OmNvcmVfYXBpOjp3cmFwcGVyOjpDb3JlV3JhcHBlcjxU\
PiBhcyBkaWdlc3Q6OlVwZGF0ZT46OnVwZGF0ZTo6e3tjbG9zdXJlfX06Omg3MmQzOTNjYTdhNDJjMT\
Q4VRRkaWdlc3Rjb250ZXh0X2RpZ2VzdFYRZGlnZXN0Y29udGV4dF9uZXdXHGRpZ2VzdGNvbnRleHRf\
ZGlnZXN0QW5kUmVzZXRYTDxhbGxvYzo6Ym94ZWQ6OkJveDxUPiBhcyBjb3JlOjpkZWZhdWx0OjpEZW\
ZhdWx0Pjo6ZGVmYXVsdDo6aDUwY2YzMGQwNTU4ZjM5NzNZTDxhbGxvYzo6Ym94ZWQ6OkJveDxUPiBh\
cyBjb3JlOjpkZWZhdWx0OjpEZWZhdWx0Pjo6ZGVmYXVsdDo6aDEwZGIyOWY3M2EyODhlY2NaTDxhbG\
xvYzo6Ym94ZWQ6OkJveDxUPiBhcyBjb3JlOjpkZWZhdWx0OjpEZWZhdWx0Pjo6ZGVmYXVsdDo6aGIz\
OWVhZDY2MjhlYTQ2OWVbTDxhbGxvYzo6Ym94ZWQ6OkJveDxUPiBhcyBjb3JlOjpkZWZhdWx0OjpEZW\
ZhdWx0Pjo6ZGVmYXVsdDo6aDkxODM1OGM3OGY3ZWMwNTdcTDxhbGxvYzo6Ym94ZWQ6OkJveDxUPiBh\
cyBjb3JlOjpkZWZhdWx0OjpEZWZhdWx0Pjo6ZGVmYXVsdDo6aDdlMjlhOGQ1NWUxOGFiMTJdLWpzX3\
N5czo6VWludDhBcnJheTo6dG9fdmVjOjpoNTExZmY3NDM1NTJhYmYyM15MPGFsbG9jOjpib3hlZDo6\
Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoNTZkNzZlNmVlMGNmMT\
EzMF8bZGlnZXN0Y29udGV4dF9kaWdlc3RBbmREcm9wYD93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNs\
b3N1cmVzOjppbnZva2UzX211dDo6aDZmNWY3MDU3OTQ0NDg2MmVhR2Rlbm9fc3RkX3dhc21fY3J5cH\
RvOjpEaWdlc3RDb250ZXh0OjpkaWdlc3RfYW5kX2Ryb3A6OmgwYzhjZmNhY2I4NzM4NjI1Yi5jb3Jl\
OjpyZXN1bHQ6OnVud3JhcF9mYWlsZWQ6OmgyZGM3MDZkOTQ4YzIyOTYwY1s8YmxvY2tfYnVmZmVyOj\
pCbG9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6\
OmhhMzcwZGU5ZWU0OTc3OTY5ZFs8YmxvY2tfYnVmZmVyOjpCbG9ja0J1ZmZlcjxCbG9ja1NpemUsS2\
luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6OmhlMDUyZDMyZmZhZjY1MDY1ZVs8Ymxv\
Y2tfYnVmZmVyOjpCbG9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb2\
5lPjo6Y2xvbmU6OmgwNGU2Y2JjMjYxODU2NjVmZls8YmxvY2tfYnVmZmVyOjpCbG9ja0J1ZmZlcjxC\
bG9ja1NpemUsS2luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6OmgyZjA2OWU0MTM4Y2\
Q1NzVkZ1s8YmxvY2tfYnVmZmVyOjpCbG9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZTo6\
Y2xvbmU6OkNsb25lPjo6Y2xvbmU6Omg2MDNjOWFlZTQwMzkxY2I5aFs8YmxvY2tfYnVmZmVyOjpCbG\
9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6Omgy\
N2ZjNWY5N2EyNjUwM2E0aVA8YXJyYXl2ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBjb3\
JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMmFhYjQ0MTQ3MWIxNTBmNmpQPGFycmF5dmVjOjplcnJvcnM6\
OkNhcGFjaXR5RXJyb3I8VD4gYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDk1YTdhNTAyYjFmND\
kxMTNrTmNvcmU6OnNsaWNlOjo8aW1wbCBbVF0+Ojpjb3B5X2Zyb21fc2xpY2U6Omxlbl9taXNtYXRj\
aF9mYWlsOjpoZjNiYmFiYzAyMDQ4NjRiY2w2Y29yZTo6cGFuaWNraW5nOjpwYW5pY19ib3VuZHNfY2\
hlY2s6OmgxZmI3YTZkZjEwMzMxMjc5bURjb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX3N0YXJ0X2lu\
ZGV4X2xlbl9mYWlsX3J0OjpoYjMxN2NhODMzMjA0NjVhNm5CY29yZTo6c2xpY2U6OmluZGV4OjpzbG\
ljZV9lbmRfaW5kZXhfbGVuX2ZhaWxfcnQ6OmhmY2Y5M2RkMzVmMDExMmJkbxhfX3diZ19kaWdlc3Rj\
b250ZXh0X2ZyZWVwN3N0ZDo6cGFuaWNraW5nOjpydXN0X3BhbmljX3dpdGhfaG9vazo6aDcwYTBlMT\
k1ZjRkYjJhMjlxMWNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbWNtcDo6aDEyODViODQxMjBkZjVk\
Y2RyFGRpZ2VzdGNvbnRleHRfdXBkYXRlcyljb3JlOjpwYW5pY2tpbmc6OnBhbmljOjpoOGFmMDQ2Mz\
k3YTJiZjY1ZHQ6Ymxha2UyOjpCbGFrZTJiVmFyQ29yZTo6bmV3X3dpdGhfcGFyYW1zOjpoZmU3YThi\
OTZmMTJiYjNlZHURcnVzdF9iZWdpbl91bndpbmR2Q2NvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWRfaW\
50ZWdyYWw6OndyaXRlX3ByZWZpeDo6aDYwYjFiNTAzZTY2ZjMyYjF3NGFsbG9jOjpyYXdfdmVjOjpj\
YXBhY2l0eV9vdmVyZmxvdzo6aDRiMjc1Y2IzYzEwYjBhNzh4LWNvcmU6OnBhbmlja2luZzo6cGFuaW\
NfZm10OjpoNzUxYmU4MDc3OWQ0MmI1M3lDc3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRs\
ZXI6Ont7Y2xvc3VyZX19OjpoZGNmYzgxOWNlODM2ODI5ZXoRX193YmluZGdlbl9tYWxsb2N7OmJsYW\
tlMjo6Qmxha2Uyc1ZhckNvcmU6Om5ld193aXRoX3BhcmFtczo6aDdkODRlMGQyN2JiNzFmYWF8SXN0\
ZDo6c3lzX2NvbW1vbjo6YmFja3RyYWNlOjpfX3J1c3RfZW5kX3Nob3J0X2JhY2t0cmFjZTo6aDUzY2\
FiYWZhYjViMDlhZGF9P3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTRfbXV0\
OjpoMjVkYWUzZDIwMTM3NzFmNn4/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2\
tlM19tdXQ6Omg5NDRjN2I1M2RkMDI5YmE1fz93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVz\
OjppbnZva2UzX211dDo6aDEwMWI3OGEyODkzYzAxZTWAAT93YXNtX2JpbmRnZW46OmNvbnZlcnQ6Om\
Nsb3N1cmVzOjppbnZva2UzX211dDo6aDM4YWRlNGE4NThmNGRjNmSBAT93YXNtX2JpbmRnZW46OmNv\
bnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDdkZmM4ODhmOGY5ZDM3YjaCAT93YXNtX2Jpbm\
RnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDA3ZjNlM2I2OWE5OTkyM2GDAT93\
YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aGI2ZDRkNzUxZTE2ZT\
I5ODCEAT93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDlhM2Qx\
NTUyMzVkY2QzZjeFAT93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dD\
o6aGIwOWFiMmQ0MjdkMzBjNWKGAT93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZv\
a2UyX211dDo6aDQxMzc3NGY1ZjhkZGQyNDiHARJfX3diaW5kZ2VuX3JlYWxsb2OIAT93YXNtX2Jpbm\
RnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UxX211dDo6aDk3NDUyYTI3NWRjMDY3YmaJATA8\
JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGZmNGFmMWI0YTgxMzk5NmGKATI8JlQgYXMgY2\
9yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoOWFkYTE1Y2ZhZTdmNDIxMosBD19fd2JpbmRnZW5fZnJl\
ZYwBP2NvcmU6OnNsaWNlOjppbmRleDo6c2xpY2VfZW5kX2luZGV4X2xlbl9mYWlsOjpoM2RiNDc2Yj\
BkMDk5OTRkMo0BQWNvcmU6OnNsaWNlOjppbmRleDo6c2xpY2Vfc3RhcnRfaW5kZXhfbGVuX2ZhaWw6\
OmgxMzZjY2FkNzY0MTM2ODEwjgEzYXJyYXl2ZWM6OmFycmF5dmVjOjpleHRlbmRfcGFuaWM6OmhkMj\
U4ZTA5N2FmNDdjNjdjjwE5Y29yZTo6b3BzOjpmdW5jdGlvbjo6Rm5PbmNlOjpjYWxsX29uY2U6Omhl\
MDIxZGJiZjZmYWFhMDZkkAEfX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcpEBMXdhc21fYm\
luZGdlbjo6X19ydDo6dGhyb3dfbnVsbDo6aGY1MTcxZjBjZmY5YTE1MjGSATJ3YXNtX2JpbmRnZW46\
Ol9fcnQ6OmJvcnJvd19mYWlsOjpoOTRiZDgxZjkyOGIzODI5OJMBKndhc21fYmluZGdlbjo6dGhyb3\
dfc3RyOjpoMzBhYzBkOTY4ZWVkMjhkNJQBBm1lbXNldJUBBm1lbWNweZYBBm1lbWNtcJcBMTxUIGFz\
IGNvcmU6OmFueTo6QW55Pjo6dHlwZV9pZDo6aDEzYzc4NTk2Njg4ZjY3YjKYAQpydXN0X3BhbmljmQ\
FvY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZjb3JlOjppdGVyOjphZGFwdGVyczo6Y29waWVkOjpD\
b3BpZWQ8Y29yZTo6c2xpY2U6Oml0ZXI6Okl0ZXI8dTg+Pj46OmgwNWZhMGY5NzFiNDZiMGU3AO+AgI\
AACXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS42NS4wICg4\
OTdlMzc1NTMgMjAyMi0xMS0wMikGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4GMC4yLjgz\
");
    const wasmModule = new WebAssembly.Module(wasmBytes);
    return new WebAssembly.Instance(wasmModule, imports);
}
function base64decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
const digestAlgorithms = [
    "BLAKE2B-224",
    "BLAKE2B-256",
    "BLAKE2B-384",
    "BLAKE2B",
    "BLAKE2S",
    "BLAKE3",
    "KECCAK-224",
    "KECCAK-256",
    "KECCAK-384",
    "KECCAK-512",
    "SHA-384",
    "SHA3-224",
    "SHA3-256",
    "SHA3-384",
    "SHA3-512",
    "SHAKE128",
    "SHAKE256",
    "TIGER",
    "RIPEMD-160",
    "SHA-224",
    "SHA-256",
    "SHA-512",
    "MD4",
    "MD5",
    "SHA-1"
];
function timingSafeEqual(a, b) {
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    if (!(a instanceof DataView)) {
        a = ArrayBuffer.isView(a) ? new DataView(a.buffer, a.byteOffset, a.byteLength) : new DataView(a);
    }
    if (!(b instanceof DataView)) {
        b = ArrayBuffer.isView(b) ? new DataView(b.buffer, b.byteOffset, b.byteLength) : new DataView(b);
    }
    assert(a instanceof DataView);
    assert(b instanceof DataView);
    const length = a.byteLength;
    let out = 0;
    let i = -1;
    while(++i < length){
        out |= a.getUint8(i) ^ b.getUint8(i);
    }
    return out === 0;
}
function swap32(val1) {
    return (val1 & 0xff) << 24 | (val1 & 0xff00) << 8 | val1 >> 8 & 0xff00 | val1 >> 24 & 0xff;
}
function n16(n) {
    return n & 0xffff;
}
function n32(n) {
    return n >>> 0;
}
function add32WithCarry(a, b) {
    const added = n32(a) + n32(b);
    return [
        n32(added),
        added > 0xffffffff ? 1 : 0
    ];
}
function mul32WithCarry(a, b) {
    const al = n16(a);
    const ah = n16(a >>> 16);
    const bl = n16(b);
    const bh = n16(b >>> 16);
    const [t, tc] = add32WithCarry(al * bh, ah * bl);
    const [n, nc] = add32WithCarry(al * bl, n32(t << 16));
    const carry = nc + (tc << 16) + n16(t >>> 16) + ah * bh;
    return [
        n,
        carry
    ];
}
function mul32(a, b) {
    const al = n16(a);
    const ah = a - al;
    return n32(n32(ah * b) + al * b);
}
function mul64([ah, al], [bh, bl]) {
    const [n, c] = mul32WithCarry(al, bl);
    return [
        n32(mul32(al, bh) + mul32(ah, bl) + c),
        n
    ];
}
const prime32 = 16777619;
const fnv32 = (data)=>{
    let hash = 2166136261;
    data.forEach((c)=>{
        hash = mul32(hash, prime32);
        hash ^= c;
    });
    return Uint32Array.from([
        swap32(hash)
    ]).buffer;
};
const fnv32a = (data)=>{
    let hash = 2166136261;
    data.forEach((c)=>{
        hash ^= c;
        hash = mul32(hash, prime32);
    });
    return Uint32Array.from([
        swap32(hash)
    ]).buffer;
};
const prime64Lo = 435;
const prime64Hi = 256;
const fnv64 = (data)=>{
    let hashLo = 2216829733;
    let hashHi = 3421674724;
    data.forEach((c)=>{
        [hashHi, hashLo] = mul64([
            hashHi,
            hashLo
        ], [
            prime64Hi,
            prime64Lo
        ]);
        hashLo ^= c;
    });
    return new Uint32Array([
        swap32(hashHi >>> 0),
        swap32(hashLo >>> 0)
    ]).buffer;
};
const fnv64a = (data)=>{
    let hashLo = 2216829733;
    let hashHi = 3421674724;
    data.forEach((c)=>{
        hashLo ^= c;
        [hashHi, hashLo] = mul64([
            hashHi,
            hashLo
        ], [
            prime64Hi,
            prime64Lo
        ]);
    });
    return new Uint32Array([
        swap32(hashHi >>> 0),
        swap32(hashLo >>> 0)
    ]).buffer;
};
function fnv(name, buf) {
    if (!buf) {
        throw new TypeError("no data provided for hashing");
    }
    switch(name){
        case "FNV32":
            return fnv32(buf);
        case "FNV64":
            return fnv64(buf);
        case "FNV32A":
            return fnv32a(buf);
        case "FNV64A":
            return fnv64a(buf);
        default:
            throw new TypeError(`unsupported fnv digest: ${name}`);
    }
}
const webCrypto = ((crypto1)=>({
        getRandomValues: crypto1.getRandomValues?.bind(crypto1),
        randomUUID: crypto1.randomUUID?.bind(crypto1),
        subtle: {
            decrypt: crypto1.subtle?.decrypt?.bind(crypto1.subtle),
            deriveBits: crypto1.subtle?.deriveBits?.bind(crypto1.subtle),
            deriveKey: crypto1.subtle?.deriveKey?.bind(crypto1.subtle),
            digest: crypto1.subtle?.digest?.bind(crypto1.subtle),
            encrypt: crypto1.subtle?.encrypt?.bind(crypto1.subtle),
            exportKey: crypto1.subtle?.exportKey?.bind(crypto1.subtle),
            generateKey: crypto1.subtle?.generateKey?.bind(crypto1.subtle),
            importKey: crypto1.subtle?.importKey?.bind(crypto1.subtle),
            sign: crypto1.subtle?.sign?.bind(crypto1.subtle),
            unwrapKey: crypto1.subtle?.unwrapKey?.bind(crypto1.subtle),
            verify: crypto1.subtle?.verify?.bind(crypto1.subtle),
            wrapKey: crypto1.subtle?.wrapKey?.bind(crypto1.subtle)
        }
    }))(globalThis.crypto);
const bufferSourceBytes = (data)=>{
    let bytes;
    if (data instanceof Uint8Array) {
        bytes = data;
    } else if (ArrayBuffer.isView(data)) {
        bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    } else if (data instanceof ArrayBuffer) {
        bytes = new Uint8Array(data);
    }
    return bytes;
};
const stdCrypto = ((x)=>x)({
    ...webCrypto,
    subtle: {
        ...webCrypto.subtle,
        async digest (algorithm, data) {
            const { name, length } = normalizeAlgorithm(algorithm);
            const bytes = bufferSourceBytes(data);
            if (FNVAlgorithms.includes(name)) {
                return fnv(name, bytes);
            }
            if (webCryptoDigestAlgorithms.includes(name) && bytes) {
                return webCrypto.subtle.digest(algorithm, bytes);
            } else if (digestAlgorithms.includes(name)) {
                if (bytes) {
                    return stdCrypto.subtle.digestSync(algorithm, bytes);
                } else if (data[Symbol.iterator]) {
                    return stdCrypto.subtle.digestSync(algorithm, data);
                } else if (data[Symbol.asyncIterator]) {
                    const wasmCrypto = instantiate();
                    const context = new wasmCrypto.DigestContext(name);
                    for await (const chunk of data){
                        const chunkBytes = bufferSourceBytes(chunk);
                        if (!chunkBytes) {
                            throw new TypeError("data contained chunk of the wrong type");
                        }
                        context.update(chunkBytes);
                    }
                    return context.digestAndDrop(length).buffer;
                } else {
                    throw new TypeError("data must be a BufferSource or [Async]Iterable<BufferSource>");
                }
            } else if (webCrypto.subtle?.digest) {
                return webCrypto.subtle.digest(algorithm, data);
            } else {
                throw new TypeError(`unsupported digest algorithm: ${algorithm}`);
            }
        },
        digestSync (algorithm, data) {
            algorithm = normalizeAlgorithm(algorithm);
            const bytes = bufferSourceBytes(data);
            if (FNVAlgorithms.includes(algorithm.name)) {
                return fnv(algorithm.name, bytes);
            }
            const wasmCrypto = instantiate();
            if (bytes) {
                return wasmCrypto.digest(algorithm.name, bytes, algorithm.length).buffer;
            } else if (data[Symbol.iterator]) {
                const context = new wasmCrypto.DigestContext(algorithm.name);
                for (const chunk of data){
                    const chunkBytes = bufferSourceBytes(chunk);
                    if (!chunkBytes) {
                        throw new TypeError("data contained chunk of the wrong type");
                    }
                    context.update(chunkBytes);
                }
                return context.digestAndDrop(algorithm.length).buffer;
            } else {
                throw new TypeError("data must be a BufferSource or Iterable<BufferSource>");
            }
        },
        timingSafeEqual
    }
});
const FNVAlgorithms = [
    "FNV32",
    "FNV32A",
    "FNV64",
    "FNV64A"
];
const webCryptoDigestAlgorithms = [
    "SHA-384",
    "SHA-256",
    "SHA-512",
    "SHA-1"
];
const normalizeAlgorithm = (algorithm)=>typeof algorithm === "string" ? {
        name: algorithm.toUpperCase()
    } : {
        ...algorithm,
        name: algorithm.name.toUpperCase()
    };
const { Deno: Deno1 } = globalThis;
typeof Deno1?.noColor === "boolean" ? Deno1.noColor : false;
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");
var TokenType;
(function(TokenType) {
    TokenType[TokenType["BeginObject"] = 0] = "BeginObject";
    TokenType[TokenType["EndObject"] = 1] = "EndObject";
    TokenType[TokenType["BeginArray"] = 2] = "BeginArray";
    TokenType[TokenType["EndArray"] = 3] = "EndArray";
    TokenType[TokenType["NameSeparator"] = 4] = "NameSeparator";
    TokenType[TokenType["ValueSeparator"] = 5] = "ValueSeparator";
    TokenType[TokenType["NullOrTrueOrFalseOrNumber"] = 6] = "NullOrTrueOrFalseOrNumber";
    TokenType[TokenType["String"] = 7] = "String";
})(TokenType || (TokenType = {}));
const originalJSONParse = globalThis.JSON.parse;
class JSONCParser {
    #whitespace = new Set(" \t\r\n");
    #numberEndToken = new Set([
        ..."[]{}:,/",
        ...this.#whitespace
    ]);
    #text;
    #length;
    #tokenized;
    #options;
    constructor(text, options){
        this.#text = `${text}`;
        this.#length = this.#text.length;
        this.#tokenized = this.#tokenize();
        this.#options = options;
    }
    parse() {
        const token = this.#getNext();
        const res = this.#parseJsonValue(token);
        const { done, value: value1 } = this.#tokenized.next();
        if (!done) {
            throw new SyntaxError(buildErrorMessage(value1));
        }
        return res;
    }
    #getNext() {
        const { done, value: value1 } = this.#tokenized.next();
        if (done) {
            throw new SyntaxError("Unexpected end of JSONC input");
        }
        return value1;
    }
    *#tokenize() {
        for(let i = 0; i < this.#length; i++){
            if (this.#whitespace.has(this.#text[i])) {
                continue;
            }
            if (this.#text[i] === "/" && this.#text[i + 1] === "*") {
                i += 2;
                let hasEndOfComment = false;
                for(; i < this.#length; i++){
                    if (this.#text[i] === "*" && this.#text[i + 1] === "/") {
                        hasEndOfComment = true;
                        break;
                    }
                }
                if (!hasEndOfComment) {
                    throw new SyntaxError("Unexpected end of JSONC input");
                }
                i++;
                continue;
            }
            if (this.#text[i] === "/" && this.#text[i + 1] === "/") {
                i += 2;
                for(; i < this.#length; i++){
                    if (this.#text[i] === "\n" || this.#text[i] === "\r") {
                        break;
                    }
                }
                continue;
            }
            switch(this.#text[i]){
                case "{":
                    yield {
                        type: TokenType.BeginObject,
                        position: i
                    };
                    break;
                case "}":
                    yield {
                        type: TokenType.EndObject,
                        position: i
                    };
                    break;
                case "[":
                    yield {
                        type: TokenType.BeginArray,
                        position: i
                    };
                    break;
                case "]":
                    yield {
                        type: TokenType.EndArray,
                        position: i
                    };
                    break;
                case ":":
                    yield {
                        type: TokenType.NameSeparator,
                        position: i
                    };
                    break;
                case ",":
                    yield {
                        type: TokenType.ValueSeparator,
                        position: i
                    };
                    break;
                case '"':
                    {
                        const startIndex = i;
                        let shouldEscapeNext = false;
                        i++;
                        for(; i < this.#length; i++){
                            if (this.#text[i] === '"' && !shouldEscapeNext) {
                                break;
                            }
                            shouldEscapeNext = this.#text[i] === "\\" && !shouldEscapeNext;
                        }
                        yield {
                            type: TokenType.String,
                            sourceText: this.#text.substring(startIndex, i + 1),
                            position: startIndex
                        };
                        break;
                    }
                default:
                    {
                        const startIndex = i;
                        for(; i < this.#length; i++){
                            if (this.#numberEndToken.has(this.#text[i])) {
                                break;
                            }
                        }
                        i--;
                        yield {
                            type: TokenType.NullOrTrueOrFalseOrNumber,
                            sourceText: this.#text.substring(startIndex, i + 1),
                            position: startIndex
                        };
                    }
            }
        }
    }
    #parseJsonValue(value1) {
        switch(value1.type){
            case TokenType.BeginObject:
                return this.#parseObject();
            case TokenType.BeginArray:
                return this.#parseArray();
            case TokenType.NullOrTrueOrFalseOrNumber:
                return this.#parseNullOrTrueOrFalseOrNumber(value1);
            case TokenType.String:
                return this.#parseString(value1);
            default:
                throw new SyntaxError(buildErrorMessage(value1));
        }
    }
    #parseObject() {
        const target = {};
        for(let isFirst = true;; isFirst = false){
            const token1 = this.#getNext();
            if ((isFirst || this.#options.allowTrailingComma) && token1.type === TokenType.EndObject) {
                return target;
            }
            if (token1.type !== TokenType.String) {
                throw new SyntaxError(buildErrorMessage(token1));
            }
            const key = this.#parseString(token1);
            const token2 = this.#getNext();
            if (token2.type !== TokenType.NameSeparator) {
                throw new SyntaxError(buildErrorMessage(token2));
            }
            const token3 = this.#getNext();
            Object.defineProperty(target, key, {
                value: this.#parseJsonValue(token3),
                writable: true,
                enumerable: true,
                configurable: true
            });
            const token4 = this.#getNext();
            if (token4.type === TokenType.EndObject) {
                return target;
            }
            if (token4.type !== TokenType.ValueSeparator) {
                throw new SyntaxError(buildErrorMessage(token4));
            }
        }
    }
    #parseArray() {
        const target = [];
        for(let isFirst = true;; isFirst = false){
            const token1 = this.#getNext();
            if ((isFirst || this.#options.allowTrailingComma) && token1.type === TokenType.EndArray) {
                return target;
            }
            target.push(this.#parseJsonValue(token1));
            const token2 = this.#getNext();
            if (token2.type === TokenType.EndArray) {
                return target;
            }
            if (token2.type !== TokenType.ValueSeparator) {
                throw new SyntaxError(buildErrorMessage(token2));
            }
        }
    }
    #parseString(value1) {
        let parsed;
        try {
            parsed = originalJSONParse(value1.sourceText);
        } catch  {
            throw new SyntaxError(buildErrorMessage(value1));
        }
        assert(typeof parsed === "string");
        return parsed;
    }
    #parseNullOrTrueOrFalseOrNumber(value1) {
        if (value1.sourceText === "null") {
            return null;
        }
        if (value1.sourceText === "true") {
            return true;
        }
        if (value1.sourceText === "false") {
            return false;
        }
        let parsed;
        try {
            parsed = originalJSONParse(value1.sourceText);
        } catch  {
            throw new SyntaxError(buildErrorMessage(value1));
        }
        assert(typeof parsed === "number");
        return parsed;
    }
}
function buildErrorMessage({ type, sourceText, position }) {
    let token = "";
    switch(type){
        case TokenType.BeginObject:
            token = "{";
            break;
        case TokenType.EndObject:
            token = "}";
            break;
        case TokenType.BeginArray:
            token = "[";
            break;
        case TokenType.EndArray:
            token = "]";
            break;
        case TokenType.NameSeparator:
            token = ":";
            break;
        case TokenType.ValueSeparator:
            token = ",";
            break;
        case TokenType.NullOrTrueOrFalseOrNumber:
        case TokenType.String:
            token = 30 < sourceText.length ? `${sourceText.slice(0, 30)}...` : sourceText;
            break;
        default:
            throw new Error("unreachable");
    }
    return `Unexpected token ${token} in JSONC at position ${position}`;
}
function deferred() {
    let methods;
    let state = "pending";
    const promise = new Promise((resolve, reject)=>{
        methods = {
            async resolve (value1) {
                await value1;
                state = "fulfilled";
                resolve(value1);
            },
            reject (reason) {
                state = "rejected";
                reject(reason);
            }
        };
    });
    Object.defineProperty(promise, "state", {
        get: ()=>state
    });
    return Object.assign(promise, methods);
}
function debounce(fn, wait) {
    let timeout = null;
    let flush = null;
    const debounced = (...args)=>{
        debounced.clear();
        flush = ()=>{
            debounced.clear();
            fn.call(debounced, ...args);
        };
        timeout = setTimeout(flush, wait);
    };
    debounced.clear = ()=>{
        if (typeof timeout === "number") {
            clearTimeout(timeout);
            timeout = null;
            flush = null;
        }
    };
    debounced.flush = ()=>{
        flush?.();
    };
    Object.defineProperty(debounced, "pending", {
        get: ()=>typeof timeout === "number"
    });
    return debounced;
}
class MuxAsyncIterator {
    #iteratorCount = 0;
    #yields = [];
    #throws = [];
    #signal = deferred();
    add(iterable) {
        ++this.#iteratorCount;
        this.#callIteratorNext(iterable[Symbol.asyncIterator]());
    }
    async #callIteratorNext(iterator) {
        try {
            const { value: value1, done } = await iterator.next();
            if (done) {
                --this.#iteratorCount;
            } else {
                this.#yields.push({
                    iterator,
                    value: value1
                });
            }
        } catch (e) {
            this.#throws.push(e);
        }
        this.#signal.resolve();
    }
    async *iterate() {
        while(this.#iteratorCount > 0){
            await this.#signal;
            for(let i = 0; i < this.#yields.length; i++){
                const { iterator, value: value1 } = this.#yields[i];
                yield value1;
                this.#callIteratorNext(iterator);
            }
            if (this.#throws.length) {
                for (const e of this.#throws){
                    throw e;
                }
                this.#throws.length = 0;
            }
            this.#yields.length = 0;
            this.#signal = deferred();
        }
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}
function copy(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MAX_SIZE = 2 ** 32 - 2;
class Buffer {
    #buf;
    #off = 0;
    #readable = new ReadableStream({
        type: "bytes",
        pull: (controller)=>{
            const view = new Uint8Array(controller.byobRequest.view.buffer);
            if (this.empty()) {
                this.reset();
                controller.close();
                controller.byobRequest.respond(0);
                return;
            }
            const nread = copy(this.#buf.subarray(this.#off), view);
            this.#off += nread;
            controller.byobRequest.respond(nread);
        },
        autoAllocateChunkSize: 16_640
    });
    get readable() {
        return this.#readable;
    }
    #writable = new WritableStream({
        write: (chunk)=>{
            const m = this.#grow(chunk.byteLength);
            copy(chunk, this.#buf, m);
        }
    });
    get writable() {
        return this.#writable;
    }
    constructor(ab){
        this.#buf = ab === undefined ? new Uint8Array(0) : new Uint8Array(ab);
    }
    bytes(options = {
        copy: true
    }) {
        if (options.copy === false) return this.#buf.subarray(this.#off);
        return this.#buf.slice(this.#off);
    }
    empty() {
        return this.#buf.byteLength <= this.#off;
    }
    get length() {
        return this.#buf.byteLength - this.#off;
    }
    get capacity() {
        return this.#buf.buffer.byteLength;
    }
    truncate(n) {
        if (n === 0) {
            this.reset();
            return;
        }
        if (n < 0 || n > this.length) {
            throw Error("bytes.Buffer: truncation out of range");
        }
        this.#reslice(this.#off + n);
    }
    reset() {
        this.#reslice(0);
        this.#off = 0;
    }
    #tryGrowByReslice(n) {
        const l = this.#buf.byteLength;
        if (n <= this.capacity - l) {
            this.#reslice(l + n);
            return l;
        }
        return -1;
    }
    #reslice(len) {
        assert(len <= this.#buf.buffer.byteLength);
        this.#buf = new Uint8Array(this.#buf.buffer, 0, len);
    }
    #grow(n) {
        const m = this.length;
        if (m === 0 && this.#off !== 0) {
            this.reset();
        }
        const i = this.#tryGrowByReslice(n);
        if (i >= 0) {
            return i;
        }
        const c = this.capacity;
        if (n <= Math.floor(c / 2) - m) {
            copy(this.#buf.subarray(this.#off), this.#buf);
        } else if (c + n > MAX_SIZE) {
            throw new Error("The buffer cannot be grown beyond the maximum size.");
        } else {
            const buf = new Uint8Array(Math.min(2 * c + n, MAX_SIZE));
            copy(this.#buf.subarray(this.#off), buf);
            this.#buf = buf;
        }
        this.#off = 0;
        this.#reslice(Math.min(m + n, MAX_SIZE));
        return m;
    }
    grow(n) {
        if (n < 0) {
            throw Error("Buffer.grow: negative count");
        }
        const m = this.#grow(n);
        this.#reslice(m);
    }
}
function createLPS(pat) {
    const lps = new Uint8Array(pat.length);
    lps[0] = 0;
    let prefixEnd = 0;
    let i = 1;
    while(i < lps.length){
        if (pat[i] == pat[prefixEnd]) {
            prefixEnd++;
            lps[i] = prefixEnd;
            i++;
        } else if (prefixEnd === 0) {
            lps[i] = 0;
            i++;
        } else {
            prefixEnd = lps[prefixEnd - 1];
        }
    }
    return lps;
}
class BytesList {
    #len = 0;
    #chunks = [];
    constructor(){}
    size() {
        return this.#len;
    }
    add(value1, start = 0, end = value1.byteLength) {
        if (value1.byteLength === 0 || end - start === 0) {
            return;
        }
        checkRange(start, end, value1.byteLength);
        this.#chunks.push({
            value: value1,
            end,
            start,
            offset: this.#len
        });
        this.#len += end - start;
    }
    shift(n) {
        if (n === 0) {
            return;
        }
        if (this.#len <= n) {
            this.#chunks = [];
            this.#len = 0;
            return;
        }
        const idx = this.getChunkIndex(n);
        this.#chunks.splice(0, idx);
        const [chunk] = this.#chunks;
        if (chunk) {
            const diff = n - chunk.offset;
            chunk.start += diff;
        }
        let offset = 0;
        for (const chunk of this.#chunks){
            chunk.offset = offset;
            offset += chunk.end - chunk.start;
        }
        this.#len = offset;
    }
    getChunkIndex(pos) {
        let max = this.#chunks.length;
        let min = 0;
        while(true){
            const i = min + Math.floor((max - min) / 2);
            if (i < 0 || this.#chunks.length <= i) {
                return -1;
            }
            const { offset, start, end } = this.#chunks[i];
            const len = end - start;
            if (offset <= pos && pos < offset + len) {
                return i;
            } else if (offset + len <= pos) {
                min = i + 1;
            } else {
                max = i - 1;
            }
        }
    }
    get(i) {
        if (i < 0 || this.#len <= i) {
            throw new Error("out of range");
        }
        const idx = this.getChunkIndex(i);
        const { value: value1, offset, start } = this.#chunks[idx];
        return value1[start + i - offset];
    }
    *iterator(start = 0) {
        const startIdx = this.getChunkIndex(start);
        if (startIdx < 0) return;
        const first = this.#chunks[startIdx];
        let firstOffset = start - first.offset;
        for(let i = startIdx; i < this.#chunks.length; i++){
            const chunk = this.#chunks[i];
            for(let j = chunk.start + firstOffset; j < chunk.end; j++){
                yield chunk.value[j];
            }
            firstOffset = 0;
        }
    }
    slice(start, end = this.#len) {
        if (end === start) {
            return new Uint8Array();
        }
        checkRange(start, end, this.#len);
        const result = new Uint8Array(end - start);
        const startIdx = this.getChunkIndex(start);
        const endIdx = this.getChunkIndex(end - 1);
        let written = 0;
        for(let i = startIdx; i <= endIdx; i++){
            const { value: chunkValue, start: chunkStart, end: chunkEnd, offset: chunkOffset } = this.#chunks[i];
            const readStart = chunkStart + (i === startIdx ? start - chunkOffset : 0);
            const readEnd = i === endIdx ? end - chunkOffset + chunkStart : chunkEnd;
            const len = readEnd - readStart;
            result.set(chunkValue.subarray(readStart, readEnd), written);
            written += len;
        }
        return result;
    }
    concat() {
        const result = new Uint8Array(this.#len);
        let sum = 0;
        for (const { value: value1, start, end } of this.#chunks){
            result.set(value1.subarray(start, end), sum);
            sum += end - start;
        }
        return result;
    }
}
function checkRange(start, end, len) {
    if (start < 0 || len < start || end < 0 || len < end || end < start) {
        throw new Error("invalid range");
    }
}
class DelimiterStream extends TransformStream {
    #bufs = new BytesList();
    #delimiter;
    #inspectIndex = 0;
    #matchIndex = 0;
    #delimLen;
    #delimLPS;
    #disp;
    constructor(delimiter, options){
        super({
            transform: (chunk, controller)=>{
                this.#handle(chunk, controller);
            },
            flush: (controller)=>{
                controller.enqueue(this.#bufs.concat());
            }
        });
        this.#delimiter = delimiter;
        this.#delimLen = delimiter.length;
        this.#delimLPS = createLPS(delimiter);
        this.#disp = options?.disposition ?? "discard";
    }
    #handle(chunk, controller) {
        this.#bufs.add(chunk);
        let localIndex = 0;
        while(this.#inspectIndex < this.#bufs.size()){
            if (chunk[localIndex] === this.#delimiter[this.#matchIndex]) {
                this.#inspectIndex++;
                localIndex++;
                this.#matchIndex++;
                if (this.#matchIndex === this.#delimLen) {
                    const start = this.#inspectIndex - this.#delimLen;
                    const end = this.#disp == "suffix" ? this.#inspectIndex : start;
                    const copy = this.#bufs.slice(0, end);
                    controller.enqueue(copy);
                    const shift = this.#disp == "prefix" ? start : this.#inspectIndex;
                    this.#bufs.shift(shift);
                    this.#inspectIndex = this.#disp == "prefix" ? this.#delimLen : 0;
                    this.#matchIndex = 0;
                }
            } else {
                if (this.#matchIndex === 0) {
                    this.#inspectIndex++;
                    localIndex++;
                } else {
                    this.#matchIndex = this.#delimLPS[this.#matchIndex - 1];
                }
            }
        }
    }
}
BigInt(Number.MAX_SAFE_INTEGER);
new TextDecoder();
new Deno.errors.AlreadyExists("dest already exists.");
var EOL;
(function(EOL) {
    EOL["LF"] = "\n";
    EOL["CRLF"] = "\r\n";
})(EOL || (EOL = {}));
const re = [];
const src = [];
let R = 0;
const NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
const NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
const MAINVERSION = R++;
const nid = src[NUMERICIDENTIFIER];
src[MAINVERSION] = `(${nid})\\.(${nid})\\.(${nid})`;
const PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
const PRERELEASE = R++;
src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
const BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
const BUILD = R++;
src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
const FULL = R++;
const FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
src[FULL] = "^" + FULLPLAIN + "$";
const GTLT = R++;
src[GTLT] = "((?:<|>)?=?)";
const XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
const XRANGEPLAIN = R++;
src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[XRANGEIDENTIFIER] + ")" + "(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?" + ")?)?";
const XRANGE = R++;
src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
const LONETILDE = R++;
src[LONETILDE] = "(?:~>?)";
const TILDE = R++;
src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
const LONECARET = R++;
src[LONECARET] = "(?:\\^)";
const CARET = R++;
src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
const COMPARATOR = R++;
src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
const HYPHENRANGE = R++;
src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")" + "\\s+-\\s+" + "(" + src[XRANGEPLAIN] + ")" + "\\s*$";
const STAR = R++;
src[STAR] = "(<|>)?=?\\s*\\*";
for(let i = 0; i < R; i++){
    if (!re[i]) {
        re[i] = new RegExp(src[i]);
    }
}
({
    major: Number.POSITIVE_INFINITY,
    minor: Number.POSITIVE_INFINITY,
    patch: Number.POSITIVE_INFINITY,
    prerelease: [],
    build: []
});
({
    major: Number.NEGATIVE_INFINITY,
    minor: Number.POSITIVE_INFINITY,
    patch: Number.POSITIVE_INFINITY,
    prerelease: [],
    build: []
});
({
    major: Number.NaN,
    minor: Number.NaN,
    patch: Number.NaN,
    prerelease: [],
    build: []
});
function minitz(y, m, d, h, i, s, tz, throwOnInvalid) {
    return minitz.fromTZ(minitz.tp(y, m, d, h, i, s, tz), throwOnInvalid);
}
minitz.fromTZISO = (localTimeStr, tz, throwOnInvalid)=>{
    return minitz.fromTZ(parseISOLocal(localTimeStr, tz), throwOnInvalid);
};
minitz.fromTZ = function(tp, throwOnInvalid) {
    const inDate = new Date(Date.UTC(tp.y, tp.m - 1, tp.d, tp.h, tp.i, tp.s)), offset = getTimezoneOffset(tp.tz, inDate), dateGuess = new Date(inDate.getTime() - offset), dateOffsGuess = getTimezoneOffset(tp.tz, dateGuess);
    if (dateOffsGuess - offset === 0) {
        return dateGuess;
    } else {
        const dateGuess2 = new Date(inDate.getTime() - dateOffsGuess), dateOffsGuess2 = getTimezoneOffset(tp.tz, dateGuess2);
        if (dateOffsGuess2 - dateOffsGuess === 0) {
            return dateGuess2;
        } else if (!throwOnInvalid && dateOffsGuess2 - dateOffsGuess > 0) {
            return dateGuess2;
        } else if (!throwOnInvalid) {
            return dateGuess;
        } else {
            throw new Error("Invalid date passed to fromTZ()");
        }
    }
};
minitz.toTZ = function(d, tzStr) {
    const localDateString = d.toLocaleString("en-US", {
        timeZone: tzStr
    }).replace(/[\u202f]/, " ");
    const td = new Date(localDateString);
    return {
        y: td.getFullYear(),
        m: td.getMonth() + 1,
        d: td.getDate(),
        h: td.getHours(),
        i: td.getMinutes(),
        s: td.getSeconds(),
        tz: tzStr
    };
};
minitz.tp = (y, m, d, h, i, s, tz)=>{
    return {
        y,
        m,
        d,
        h,
        i,
        s,
        tz: tz
    };
};
function getTimezoneOffset(timeZone, date = new Date()) {
    const tz = date.toLocaleString("en-US", {
        timeZone: timeZone,
        timeZoneName: "short"
    }).split(" ").slice(-1)[0];
    const dateString = date.toLocaleString("en-US").replace(/[\u202f]/, " ");
    return Date.parse(`${dateString} GMT`) - Date.parse(`${dateString} ${tz}`);
}
function parseISOLocal(dtStr, tz) {
    const pd = new Date(Date.parse(dtStr));
    if (isNaN(pd)) {
        throw new Error("minitz: Invalid ISO8601 passed to parser.");
    }
    const stringEnd = dtStr.substring(9);
    if (dtStr.includes("Z") || stringEnd.includes("-") || stringEnd.includes("+")) {
        return minitz.tp(pd.getUTCFullYear(), pd.getUTCMonth() + 1, pd.getUTCDate(), pd.getUTCHours(), pd.getUTCMinutes(), pd.getUTCSeconds(), "Etc/UTC");
    } else {
        return minitz.tp(pd.getFullYear(), pd.getMonth() + 1, pd.getDate(), pd.getHours(), pd.getMinutes(), pd.getSeconds(), tz);
    }
}
minitz.minitz = minitz;
function CronOptions(options) {
    if (options === void 0) {
        options = {};
    }
    delete options.name;
    options.legacyMode = options.legacyMode === void 0 ? true : options.legacyMode;
    options.paused = options.paused === void 0 ? false : options.paused;
    options.maxRuns = options.maxRuns === void 0 ? Infinity : options.maxRuns;
    options.catch = options.catch === void 0 ? false : options.catch;
    options.interval = options.interval === void 0 ? 0 : parseInt(options.interval, 10);
    options.utcOffset = options.utcOffset === void 0 ? void 0 : parseInt(options.utcOffset, 10);
    options.unref = options.unref === void 0 ? false : options.unref;
    if (options.startAt) {
        options.startAt = new CronDate(options.startAt, options.timezone);
    }
    if (options.stopAt) {
        options.stopAt = new CronDate(options.stopAt, options.timezone);
    }
    if (options.interval !== null) {
        if (isNaN(options.interval)) {
            throw new Error("CronOptions: Supplied value for interval is not a number");
        } else if (options.interval < 0) {
            throw new Error("CronOptions: Supplied value for interval can not be negative");
        }
    }
    if (options.utcOffset !== void 0) {
        if (isNaN(options.utcOffset)) {
            throw new Error("CronOptions: Invalid value passed for utcOffset, should be number representing minutes offset from UTC.");
        } else if (options.utcOffset < -870 || options.utcOffset > 870) {
            throw new Error("CronOptions: utcOffset out of bounds.");
        }
        if (options.utcOffset !== void 0 && options.timezone) {
            throw new Error("CronOptions: Combining 'utcOffset' with 'timezone' is not allowed.");
        }
    }
    if (options.unref !== true && options.unref !== false) {
        throw new Error("CronOptions: Unref should be either true, false or undefined(false).");
    }
    return options;
}
const DaysOfMonth = [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
const RecursionSteps = [
    [
        "month",
        "year",
        0
    ],
    [
        "day",
        "month",
        -1
    ],
    [
        "hour",
        "day",
        0
    ],
    [
        "minute",
        "hour",
        0
    ],
    [
        "second",
        "minute",
        0
    ]
];
function CronDate(d, tz) {
    this.tz = tz;
    if (d && d instanceof Date) {
        if (!isNaN(d)) {
            this.fromDate(d);
        } else {
            throw new TypeError("CronDate: Invalid date passed to CronDate constructor");
        }
    } else if (d === void 0) {
        this.fromDate(new Date());
    } else if (d && typeof d === "string") {
        this.fromString(d);
    } else if (d instanceof CronDate) {
        this.fromCronDate(d);
    } else {
        throw new TypeError("CronDate: Invalid type (" + typeof d + ") passed to CronDate constructor");
    }
}
CronDate.prototype.fromDate = function(inDate) {
    if (this.tz !== void 0) {
        if (typeof this.tz === "number") {
            this.ms = inDate.getUTCMilliseconds();
            this.second = inDate.getUTCSeconds();
            this.minute = inDate.getUTCMinutes() + this.tz;
            this.hour = inDate.getUTCHours();
            this.day = inDate.getUTCDate();
            this.month = inDate.getUTCMonth();
            this.year = inDate.getUTCFullYear();
            this.apply();
        } else {
            const d = minitz.toTZ(inDate, this.tz);
            this.ms = inDate.getMilliseconds();
            this.second = d.s;
            this.minute = d.i;
            this.hour = d.h;
            this.day = d.d;
            this.month = d.m - 1;
            this.year = d.y;
        }
    } else {
        this.ms = inDate.getMilliseconds();
        this.second = inDate.getSeconds();
        this.minute = inDate.getMinutes();
        this.hour = inDate.getHours();
        this.day = inDate.getDate();
        this.month = inDate.getMonth();
        this.year = inDate.getFullYear();
    }
};
CronDate.prototype.fromCronDate = function(d) {
    this.tz = d.tz;
    this.year = d.year;
    this.month = d.month;
    this.day = d.day;
    this.hour = d.hour;
    this.minute = d.minute;
    this.second = d.second;
    this.ms = d.ms;
};
CronDate.prototype.apply = function() {
    if (this.month > 11 || this.day > DaysOfMonth[this.month] || this.hour > 59 || this.minute > 59 || this.second > 59 || this.hour < 0 || this.minute < 0 || this.second < 0) {
        const d = new Date(Date.UTC(this.year, this.month, this.day, this.hour, this.minute, this.second, this.ms));
        this.ms = d.getUTCMilliseconds();
        this.second = d.getUTCSeconds();
        this.minute = d.getUTCMinutes();
        this.hour = d.getUTCHours();
        this.day = d.getUTCDate();
        this.month = d.getUTCMonth();
        this.year = d.getUTCFullYear();
        return true;
    } else {
        return false;
    }
};
CronDate.prototype.fromString = function(str) {
    return this.fromDate(minitz.fromTZISO(str, this.tz));
};
CronDate.prototype.findNext = function(options, target, pattern, offset) {
    const originalTarget = this[target];
    let lastDayOfMonth;
    if (pattern.lastDayOfMonth || pattern.lastWeekdayOfMonth) {
        if (this.month !== 1) {
            lastDayOfMonth = DaysOfMonth[this.month];
        } else {
            lastDayOfMonth = new Date(Date.UTC(this.year, this.month + 1, 0, 0, 0, 0, 0)).getUTCDate();
        }
    }
    const fDomWeekDay = !pattern.starDOW && target == "day" ? new Date(Date.UTC(this.year, this.month, 1, 0, 0, 0, 0)).getUTCDay() : undefined;
    for(let i = this[target] + offset; i < pattern[target].length; i++){
        let match = pattern[target][i];
        if (target === "day" && pattern.lastDayOfMonth && i - offset == lastDayOfMonth) {
            match = true;
        }
        if (target === "day" && !pattern.starDOW) {
            let dowMatch = pattern.dayOfWeek[(fDomWeekDay + (i - offset - 1)) % 7];
            if (dowMatch && pattern.lastWeekdayOfMonth) {
                dowMatch = dowMatch && i - offset > lastDayOfMonth - 7;
            }
            if (options.legacyMode && !pattern.starDOM) {
                match = match || dowMatch;
            } else {
                match = match && dowMatch;
            }
        }
        if (match) {
            this[target] = i - offset;
            return originalTarget !== this[target] ? 2 : 1;
        }
    }
    return 3;
};
CronDate.prototype.recurse = function(pattern, options, doing) {
    const res = this.findNext(options, RecursionSteps[doing][0], pattern, RecursionSteps[doing][2]);
    if (res > 1) {
        let resetLevel = doing + 1;
        while(resetLevel < RecursionSteps.length){
            this[RecursionSteps[resetLevel][0]] = -RecursionSteps[resetLevel][2];
            resetLevel++;
        }
        if (res === 3) {
            this[RecursionSteps[doing][1]]++;
            this[RecursionSteps[doing][0]] = -RecursionSteps[doing][2];
            this.apply();
            return this.recurse(pattern, options, 0);
        } else if (this.apply()) {
            return this.recurse(pattern, options, doing - 1);
        }
    }
    doing += 1;
    if (doing >= RecursionSteps.length) {
        return this;
    } else if (this.year >= 3000) {
        return null;
    } else {
        return this.recurse(pattern, options, doing);
    }
};
CronDate.prototype.increment = function(pattern, options, hasPreviousRun) {
    this.second += options.interval > 1 && hasPreviousRun ? options.interval : 1;
    this.ms = 0;
    this.apply();
    return this.recurse(pattern, options, 0);
};
CronDate.prototype.getDate = function(internal) {
    if (internal || this.tz === void 0) {
        return new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.ms);
    } else {
        if (typeof this.tz === "number") {
            return new Date(Date.UTC(this.year, this.month, this.day, this.hour, this.minute - this.tz, this.second, this.ms));
        } else {
            return minitz(this.year, this.month + 1, this.day, this.hour, this.minute, this.second, this.tz);
        }
    }
};
CronDate.prototype.getTime = function() {
    return this.getDate().getTime();
};
function CronPattern(pattern, timezone) {
    this.pattern = pattern;
    this.timezone = timezone;
    this.second = Array(60).fill(0);
    this.minute = Array(60).fill(0);
    this.hour = Array(24).fill(0);
    this.day = Array(31).fill(0);
    this.month = Array(12).fill(0);
    this.dayOfWeek = Array(8).fill(0);
    this.lastDayOfMonth = false;
    this.lastWeekdayOfMonth = false;
    this.starDOM = false;
    this.starDOW = false;
    this.parse();
}
CronPattern.prototype.parse = function() {
    if (!(typeof this.pattern === "string" || this.pattern.constructor === String)) {
        throw new TypeError("CronPattern: Pattern has to be of type string.");
    }
    if (this.pattern.indexOf("@") >= 0) this.pattern = this.handleNicknames(this.pattern).trim();
    const parts = this.pattern.replace(/\s+/g, " ").split(" ");
    if (parts.length < 5 || parts.length > 6) {
        throw new TypeError("CronPattern: invalid configuration format ('" + this.pattern + "'), exacly five or six space separated parts required.");
    }
    if (parts.length === 5) {
        parts.unshift("0");
    }
    if (parts[3].indexOf("L") >= 0) {
        parts[3] = parts[3].replace("L", "");
        this.lastDayOfMonth = true;
    }
    if (parts[5].indexOf("L") >= 0) {
        parts[5] = parts[5].replace("L", "");
        this.lastWeekdayOfMonth = true;
    }
    if (parts[3] == "*") {
        this.starDOM = true;
    }
    if (parts[4].length >= 3) parts[4] = this.replaceAlphaMonths(parts[4]);
    if (parts[5].length >= 3) parts[5] = this.replaceAlphaDays(parts[5]);
    if (parts[5] == "*") {
        this.starDOW = true;
    }
    if (this.pattern.indexOf("?") >= 0) {
        const initDate = new CronDate(new Date(), this.timezone).getDate(true);
        parts[0] = parts[0].replace("?", initDate.getSeconds());
        parts[1] = parts[1].replace("?", initDate.getMinutes());
        parts[2] = parts[2].replace("?", initDate.getHours());
        if (!this.starDOM) parts[3] = parts[3].replace("?", initDate.getDate());
        parts[4] = parts[4].replace("?", initDate.getMonth() + 1);
        if (!this.starDOW) parts[5] = parts[5].replace("?", initDate.getDay());
    }
    this.throwAtIllegalCharacters(parts);
    this.partToArray("second", parts[0], 0);
    this.partToArray("minute", parts[1], 0);
    this.partToArray("hour", parts[2], 0);
    this.partToArray("day", parts[3], -1);
    this.partToArray("month", parts[4], -1);
    this.partToArray("dayOfWeek", parts[5], 0);
    if (this.dayOfWeek[7]) {
        this.dayOfWeek[0] = 1;
    }
};
CronPattern.prototype.partToArray = function(type, conf, valueIndexOffset) {
    const arr = this[type];
    if (conf === "*") return arr.fill(1);
    const split = conf.split(",");
    if (split.length > 1) {
        for(let i = 0; i < split.length; i++){
            this.partToArray(type, split[i], valueIndexOffset);
        }
    } else if (conf.indexOf("-") !== -1 && conf.indexOf("/") !== -1) {
        this.handleRangeWithStepping(conf, type, valueIndexOffset);
    } else if (conf.indexOf("-") !== -1) {
        this.handleRange(conf, type, valueIndexOffset);
    } else if (conf.indexOf("/") !== -1) {
        this.handleStepping(conf, type, valueIndexOffset);
    } else if (conf !== "") {
        this.handleNumber(conf, type, valueIndexOffset);
    }
};
CronPattern.prototype.throwAtIllegalCharacters = function(parts) {
    const reValidCron = /[^/*0-9,-]+/;
    for(let i = 0; i < parts.length; i++){
        if (reValidCron.test(parts[i])) {
            throw new TypeError("CronPattern: configuration entry " + i + " (" + parts[i] + ") contains illegal characters.");
        }
    }
};
CronPattern.prototype.handleNumber = function(conf, type, valueIndexOffset) {
    const i = parseInt(conf, 10) + valueIndexOffset;
    if (isNaN(i)) {
        throw new TypeError("CronPattern: " + type + " is not a number: '" + conf + "'");
    }
    if (i < 0 || i >= this[type].length) {
        throw new TypeError("CronPattern: " + type + " value out of range: '" + conf + "'");
    }
    this[type][i] = 1;
};
CronPattern.prototype.handleRangeWithStepping = function(conf, type, valueIndexOffset) {
    const matches = conf.match(/^(\d+)-(\d+)\/(\d+)$/);
    if (matches === null) throw new TypeError("CronPattern: Syntax error, illegal range with stepping: '" + conf + "'");
    let [, lower, upper, steps] = matches;
    lower = parseInt(lower, 10) + valueIndexOffset;
    upper = parseInt(upper, 10) + valueIndexOffset;
    steps = parseInt(steps, 10);
    if (isNaN(lower)) throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");
    if (isNaN(upper)) throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");
    if (isNaN(steps)) throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");
    if (steps === 0) throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");
    if (steps > this[type].length) throw new TypeError("CronPattern: Syntax error, steps cannot be greater than maximum value of part (" + this[type].length + ")");
    if (lower < 0 || upper >= this[type].length) throw new TypeError("CronPattern: Value out of range: '" + conf + "'");
    if (lower > upper) throw new TypeError("CronPattern: From value is larger than to value: '" + conf + "'");
    for(let i = lower; i <= upper; i += steps){
        this[type][i] = 1;
    }
};
CronPattern.prototype.handleRange = function(conf, type, valueIndexOffset) {
    const split = conf.split("-");
    if (split.length !== 2) {
        throw new TypeError("CronPattern: Syntax error, illegal range: '" + conf + "'");
    }
    const lower = parseInt(split[0], 10) + valueIndexOffset, upper = parseInt(split[1], 10) + valueIndexOffset;
    if (isNaN(lower)) {
        throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");
    } else if (isNaN(upper)) {
        throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");
    }
    if (lower < 0 || upper >= this[type].length) {
        throw new TypeError("CronPattern: Value out of range: '" + conf + "'");
    }
    if (lower > upper) {
        throw new TypeError("CronPattern: From value is larger than to value: '" + conf + "'");
    }
    for(let i = lower; i <= upper; i++){
        this[type][i] = 1;
    }
};
CronPattern.prototype.handleStepping = function(conf, type) {
    const split = conf.split("/");
    if (split.length !== 2) {
        throw new TypeError("CronPattern: Syntax error, illegal stepping: '" + conf + "'");
    }
    let start = 0;
    if (split[0] !== "*") {
        start = parseInt(split[0], 10);
    }
    const steps = parseInt(split[1], 10);
    if (isNaN(steps)) throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");
    if (steps === 0) throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");
    if (steps > this[type].length) throw new TypeError("CronPattern: Syntax error, max steps for part is (" + this[type].length + ")");
    for(let i = start; i < this[type].length; i += steps){
        this[type][i] = 1;
    }
};
CronPattern.prototype.replaceAlphaDays = function(conf) {
    return conf.replace(/-sun/gi, "-7").replace(/sun/gi, "0").replace(/mon/gi, "1").replace(/tue/gi, "2").replace(/wed/gi, "3").replace(/thu/gi, "4").replace(/fri/gi, "5").replace(/sat/gi, "6");
};
CronPattern.prototype.replaceAlphaMonths = function(conf) {
    return conf.replace(/jan/gi, "1").replace(/feb/gi, "2").replace(/mar/gi, "3").replace(/apr/gi, "4").replace(/may/gi, "5").replace(/jun/gi, "6").replace(/jul/gi, "7").replace(/aug/gi, "8").replace(/sep/gi, "9").replace(/oct/gi, "10").replace(/nov/gi, "11").replace(/dec/gi, "12");
};
CronPattern.prototype.handleNicknames = function(pattern) {
    const cleanPattern = pattern.trim().toLowerCase();
    if (cleanPattern === "@yearly" || cleanPattern === "@annually") {
        return "0 0 1 1 *";
    } else if (cleanPattern === "@monthly") {
        return "0 0 1 * *";
    } else if (cleanPattern === "@weekly") {
        return "0 0 * * 0";
    } else if (cleanPattern === "@daily") {
        return "0 0 * * *";
    } else if (cleanPattern === "@hourly") {
        return "0 * * * *";
    } else {
        return pattern;
    }
};
function isFunction(v) {
    return Object.prototype.toString.call(v) === "[object Function]" || "function" === typeof v || v instanceof Function;
}
function unrefTimer(timer) {
    if (typeof Deno !== "undefined" && typeof Deno.unrefTimer !== "undefined") {
        Deno.unrefTimer(timer);
    } else if (timer && typeof timer.unref !== "undefined") {
        timer.unref();
    }
}
const maxDelay = 30 * 1000;
const scheduledJobs = [];
function Cron(pattern, fnOrOptions1, fnOrOptions2) {
    if (!(this instanceof Cron)) {
        return new Cron(pattern, fnOrOptions1, fnOrOptions2);
    }
    let options, func;
    if (isFunction(fnOrOptions1)) {
        func = fnOrOptions1;
    } else if (typeof fnOrOptions1 === "object") {
        options = fnOrOptions1;
    } else if (fnOrOptions1 !== void 0) {
        throw new Error("Cron: Invalid argument passed for optionsIn. Should be one of function, or object (options).");
    }
    if (isFunction(fnOrOptions2)) {
        func = fnOrOptions2;
    } else if (typeof fnOrOptions2 === "object") {
        options = fnOrOptions2;
    } else if (fnOrOptions2 !== void 0) {
        throw new Error("Cron: Invalid argument passed for funcIn. Should be one of function, or object (options).");
    }
    this.name = options ? options.name : void 0;
    this.options = CronOptions(options);
    this._states = {
        kill: false,
        blocking: false,
        previousRun: void 0,
        currentRun: void 0,
        once: void 0,
        currentTimeout: void 0,
        maxRuns: options ? options.maxRuns : void 0,
        paused: options ? options.paused : false,
        pattern: void 0
    };
    if (pattern && (pattern instanceof Date || typeof pattern === "string" && pattern.indexOf(":") > 0)) {
        this._states.once = new CronDate(pattern, this.options.timezone || this.options.utcOffset);
    } else {
        this._states.pattern = new CronPattern(pattern, this.options.timezone);
    }
    if (this.name) {
        const existing = scheduledJobs.find((j)=>j.name === this.name);
        if (existing) {
            throw new Error("Cron: Tried to initialize new named job '" + this.name + "', but name already taken.");
        } else {
            scheduledJobs.push(this);
        }
    }
    if (func !== void 0) {
        this.fn = func;
        this.schedule();
    }
    return this;
}
Cron.prototype.nextRun = function(prev) {
    const next = this._next(prev);
    return next ? next.getDate() : null;
};
Cron.prototype.nextRuns = function(n, previous) {
    if (n > this._states.maxRuns) {
        n = this._states.maxRuns;
    }
    const enumeration = [];
    let prev = previous || this._states.currentRun;
    while(n-- && (prev = this.nextRun(prev))){
        enumeration.push(prev);
    }
    return enumeration;
};
Cron.prototype.getPattern = function() {
    return this._states.pattern ? this._states.pattern.pattern : void 0;
};
Cron.prototype.isRunning = function() {
    const msLeft = this.msToNext(this._states.currentRun);
    const isRunning = !this._states.paused;
    const isScheduled = this.fn !== void 0;
    const notIsKilled = !this._states.kill;
    return isRunning && isScheduled && notIsKilled && msLeft !== null;
};
Cron.prototype.isStopped = function() {
    return this._states.kill;
};
Cron.prototype.isBusy = function() {
    return this._states.blocking;
};
Cron.prototype.currentRun = function() {
    return this._states.currentRun ? this._states.currentRun.getDate() : null;
};
Cron.prototype.previousRun = function() {
    return this._states.previousRun ? this._states.previousRun.getDate() : null;
};
Cron.prototype.msToNext = function(prev) {
    const next = this._next(prev);
    prev = new CronDate(prev, this.options.timezone || this.options.utcOffset);
    if (next) {
        return next.getTime(true) - prev.getTime(true);
    } else {
        return null;
    }
};
Cron.prototype.stop = function() {
    this._states.kill = true;
    if (this._states.currentTimeout) {
        clearTimeout(this._states.currentTimeout);
    }
    const jobIndex = scheduledJobs.indexOf(this);
    if (jobIndex >= 0) {
        scheduledJobs.splice(jobIndex, 1);
    }
};
Cron.prototype.pause = function() {
    this._states.paused = true;
    return !this._states.kill;
};
Cron.prototype.resume = function() {
    this._states.paused = false;
    return !this._states.kill;
};
Cron.prototype.schedule = function(func, partial) {
    if (func && this.fn) {
        throw new Error("Cron: It is not allowed to schedule two functions using the same Croner instance.");
    } else if (func) {
        this.fn = func;
    }
    let waitMs = this.msToNext(partial ? partial : this._states.currentRun);
    const target = this.nextRun(partial ? partial : this._states.currentRun);
    if (waitMs === null || target === null) return this;
    if (waitMs > maxDelay) {
        waitMs = maxDelay;
    }
    this._states.currentTimeout = setTimeout(()=>this._checkTrigger(target), waitMs);
    if (this._states.currentTimeout && this.options.unref) {
        unrefTimer(this._states.currentTimeout);
    }
    return this;
};
Cron.prototype._trigger = async function(initiationDate) {
    this._states.blocking = true;
    this._states.currentRun = new CronDate(void 0, this.options.timezone || this.options.utcOffset);
    if (this.options.catch) {
        try {
            await this.fn(this, this.options.context);
        } catch (_e) {
            if (isFunction(this.options.catch)) {
                this.options.catch(_e, this);
            }
        }
    } else {
        await this.fn(this, this.options.context);
    }
    this._states.previousRun = new CronDate(initiationDate, this.options.timezone || this.options.utcOffset);
    this._states.blocking = false;
};
Cron.prototype.trigger = async function() {
    await this._trigger();
};
Cron.prototype._checkTrigger = function(target) {
    const now = new Date(), shouldRun = !this._states.paused && now.getTime() >= target, isBlocked = this._states.blocking && this.options.protect;
    if (shouldRun && !isBlocked) {
        this._states.maxRuns--;
        this._trigger();
    } else {
        if (shouldRun && isBlocked && isFunction(this.options.protect)) {
            setTimeout(()=>this.options.protect(this), 0);
        }
    }
    this.schedule(undefined, now);
};
Cron.prototype._next = function(prev) {
    const hasPreviousRun = prev || this._states.currentRun ? true : false;
    prev = new CronDate(prev, this.options.timezone || this.options.utcOffset);
    if (this.options.startAt && prev && prev.getTime() < this.options.startAt.getTime()) {
        prev = this.options.startAt;
    }
    const nextRun = this._states.once || new CronDate(prev, this.options.timezone || this.options.utcOffset).increment(this._states.pattern, this.options, hasPreviousRun);
    if (this._states.once && this._states.once.getTime() <= prev.getTime()) {
        return null;
    } else if (nextRun === null || this._states.maxRuns <= 0 || this._states.kill || this.options.stopAt && nextRun.getTime() >= this.options.stopAt.getTime()) {
        return null;
    } else {
        return nextRun;
    }
};
Cron.Cron = Cron;
Cron.scheduledJobs = scheduledJobs;
var util;
(function(util) {
    util.assertEqual = (val1)=>val1;
    function assertIs(_arg) {}
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items)=>{
        const obj = {};
        for (const item of items){
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj)=>{
        const validKeys = objectKeys(obj).filter((k)=>typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys){
            filtered[k] = obj[k];
        }
        return objectValues(filtered);
    };
    var objectValues = util.objectValues = (obj)=>{
        return objectKeys(obj).map(function(e) {
            return obj[e];
        });
    };
    var objectKeys = util.objectKeys = typeof Object.keys === "function" ? (obj)=>Object.keys(obj) : (object)=>{
        const keys = [];
        for(const key in object){
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                keys.push(key);
            }
        }
        return keys;
    };
    util.find = (arr, checker)=>{
        for (const item of arr){
            if (checker(item)) return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function" ? (val1)=>Number.isInteger(val1) : (val1)=>typeof val1 === "number" && isFinite(val1) && Math.floor(val1) === val1;
    function joinValues(array, separator = " | ") {
        return array.map((val1)=>typeof val1 === "string" ? `'${val1}'` : val1).join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value1)=>{
        if (typeof value1 === "bigint") {
            return value1.toString();
        }
        return value1;
    };
})(util || (util = {}));
var objectUtil;
(function(objectUtil) {
    objectUtil.mergeShapes = (first, second)=>{
        return {
            ...first,
            ...second
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
]);
const getParsedType = (data)=>{
    const t = typeof data;
    switch(t){
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};
const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
]);
class ZodError extends Error {
    issues = [];
    get errors() {
        return this.issues;
    }
    constructor(issues){
        super();
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
        } else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper || function(issue) {
            return issue.message;
        };
        const fieldErrors = {
            _errors: []
        };
        const processError = (error)=>{
            for (const issue of error.issues){
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                } else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                } else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                } else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                } else {
                    let curr = fieldErrors;
                    let i = 0;
                    while(i < issue.path.length){
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || {
                                _errors: []
                            };
                        } else {
                            curr[el] = curr[el] || {
                                _errors: []
                            };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static create = (issues)=>{
        const error = new ZodError(issues);
        return error;
    };
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    addIssue = (sub)=>{
        this.issues = [
            ...this.issues,
            sub
        ];
    };
    addIssues = (subs = [])=>{
        this.issues = [
            ...this.issues,
            ...subs
        ];
    };
    flatten(mapper = (issue)=>issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues){
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            } else {
                formErrors.push(mapper(sub));
            }
        }
        return {
            formErrors,
            fieldErrors
        };
    }
    get formErrors() {
        return this.flatten();
    }
}
const errorMap = (issue, _ctx)=>{
    let message;
    switch(issue.code){
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            } else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                } else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                } else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                } else {
                    util.assertNever(issue.validation);
                }
            } else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            } else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util.assertNever(issue);
    }
    return {
        message
    };
};
let overrideErrorMap = errorMap;
function getErrorMap() {
    return overrideErrorMap;
}
const makeIssue = (params)=>{
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [
        ...path,
        ...issueData.path || []
    ];
    const fullIssue = {
        ...issueData,
        path: fullPath
    };
    let errorMessage = "";
    const maps = errorMaps.filter((m)=>!!m).slice().reverse();
    for (const map of maps){
        errorMessage = map(fullIssue, {
            data,
            defaultError: errorMessage
        }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
    };
};
function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
        ].filter((x)=>!!x)
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    value = "valid";
    dirty() {
        if (this.value === "valid") this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted") this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results){
            if (s.status === "aborted") return INVALID;
            if (s.status === "dirty") status.dirty();
            arrayValue.push(s.value);
        }
        return {
            status: status.value,
            value: arrayValue
        };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs){
            syncPairs.push({
                key: await pair.key,
                value: await pair.value
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs){
            const { key, value: value1 } = pair;
            if (key.status === "aborted") return INVALID;
            if (value1.status === "aborted") return INVALID;
            if (key.status === "dirty") status.dirty();
            if (value1.status === "dirty") status.dirty();
            if (typeof value1.value !== "undefined" || pair.alwaysSet) {
                finalObject[key.value] = value1.value;
            }
        }
        return {
            status: status.value,
            value: finalObject
        };
    }
}
const INVALID = Object.freeze({
    status: "aborted"
});
const DIRTY = (value1)=>({
        status: "dirty",
        value: value1
    });
const OK = (value1)=>({
        status: "valid",
        value: value1
    });
const isAborted = (x)=>x.status === "aborted";
const isDirty = (x)=>x.status === "dirty";
const isValid = (x)=>x.status === "valid";
const isAsync = (x)=>typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil) {
    errorUtil.errToObj = (message)=>typeof message === "string" ? {
            message
        } : message || {};
    errorUtil.toString = (message)=>typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
    parent;
    data;
    _path;
    _key;
    _cachedPath = [];
    constructor(parent, value1, path, key){
        this.parent = parent;
        this.data = value1;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            } else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result)=>{
    if (isValid(result)) {
        return {
            success: true,
            data: result.value
        };
    } else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error () {
                if (this._error) return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            }
        };
    }
};
function processCreateParams(params) {
    if (!params) return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap) return {
        errorMap: errorMap,
        description
    };
    const customMap = (iss, ctx)=>{
        if (iss.code !== "invalid_type") return {
            message: ctx.defaultError
        };
        if (typeof ctx.data === "undefined") {
            return {
                message: required_error ?? ctx.defaultError
            };
        }
        return {
            message: invalid_type_error ?? ctx.defaultError
        };
    };
    return {
        errorMap: customMap,
        description
    };
}
class ZodType {
    _type;
    _output;
    _input;
    _def;
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
        };
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent
            }
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        const ctx = {
            common: {
                issues: [],
                async: params?.async ?? false,
                contextualErrorMap: params?.errorMap
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
        };
        const result = this._parseSync({
            data,
            path: ctx.path,
            parent: ctx
        });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params?.errorMap,
                async: true
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    spa = this.safeParseAsync;
    refine(check, message) {
        const getIssueProperties = (val1)=>{
            if (typeof message === "string" || typeof message === "undefined") {
                return {
                    message
                };
            } else if (typeof message === "function") {
                return message(val1);
            } else {
                return message;
            }
        };
        return this._refinement((val1, ctx)=>{
            const result = check(val1);
            const setError = ()=>ctx.addIssue({
                    code: ZodIssueCode.custom,
                    ...getIssueProperties(val1)
                });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data)=>{
                    if (!data) {
                        setError();
                        return false;
                    } else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            } else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val1, ctx)=>{
            if (!check(val1)) {
                ctx.addIssue(typeof refinementData === "function" ? refinementData(val1, ctx) : refinementData);
                return false;
            } else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "refinement",
                refinement
            }
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    constructor(def){
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this, this._def);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([
            this,
            option
        ], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "transform",
                transform
            }
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : ()=>def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def)
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : ()=>def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args)=>{
    if (args.precision) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
    } else if (args.precision === 0) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
    } else {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
    }
};
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks){
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message
                        });
                    } else if (tooSmall) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message
                        });
                    }
                    status.dirty();
                }
            } else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "emoji") {
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "url") {
                try {
                    new URL(input.data);
                } catch  {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "trim") {
                input.data = input.data.trim();
            } else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: {
                            includes: check.value,
                            position: check.position
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            } else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            } else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: {
                            startsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: {
                            endsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    _regex = (regex, validation, message)=>this.refinement((data)=>regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message)
        });
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    email(message) {
        return this._addCheck({
            kind: "email",
            ...errorUtil.errToObj(message)
        });
    }
    url(message) {
        return this._addCheck({
            kind: "url",
            ...errorUtil.errToObj(message)
        });
    }
    emoji(message) {
        return this._addCheck({
            kind: "emoji",
            ...errorUtil.errToObj(message)
        });
    }
    uuid(message) {
        return this._addCheck({
            kind: "uuid",
            ...errorUtil.errToObj(message)
        });
    }
    cuid(message) {
        return this._addCheck({
            kind: "cuid",
            ...errorUtil.errToObj(message)
        });
    }
    cuid2(message) {
        return this._addCheck({
            kind: "cuid2",
            ...errorUtil.errToObj(message)
        });
    }
    ulid(message) {
        return this._addCheck({
            kind: "ulid",
            ...errorUtil.errToObj(message)
        });
    }
    ip(options) {
        return this._addCheck({
            kind: "ip",
            ...errorUtil.errToObj(options)
        });
    }
    datetime(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                message: options
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            offset: options?.offset ?? false,
            ...errorUtil.errToObj(options?.message)
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message)
        });
    }
    includes(value1, options) {
        return this._addCheck({
            kind: "includes",
            value: value1,
            position: options?.position,
            ...errorUtil.errToObj(options?.message)
        });
    }
    startsWith(value1, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value1,
            ...errorUtil.errToObj(message)
        });
    }
    endsWith(value1, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value1,
            ...errorUtil.errToObj(message)
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message)
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message)
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil.errToObj(message)
        });
    }
    nonempty = (message)=>this.min(1, errorUtil.errToObj(message));
    trim = ()=>new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "trim"
                }
            ]
        });
    toLowerCase = ()=>new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toLowerCase"
                }
            ]
        });
    toUpperCase = ()=>new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toUpperCase"
                }
            ]
        });
    get isDatetime() {
        return !!this._def.checks.find((ch)=>ch.kind === "datetime");
    }
    get isEmail() {
        return !!this._def.checks.find((ch)=>ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch)=>ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch)=>ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch)=>ch.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch)=>ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch)=>ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch)=>ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch)=>ch.kind === "ip");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
    static create = (params)=>{
        return new ZodString({
            checks: [],
            typeName: ZodFirstPartyTypeKind.ZodString,
            coerce: params?.coerce ?? false,
            ...processCreateParams(params)
        });
    };
}
function floatSafeRemainder(val1, step) {
    const valDecCount = (val1.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val1.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks){
            if (check.kind === "int") {
                if (!util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message
                    });
                    status.dirty();
                }
            } else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    static create = (params)=>{
        return new ZodNumber({
            checks: [],
            typeName: ZodFirstPartyTypeKind.ZodNumber,
            coerce: params?.coerce || false,
            ...processCreateParams(params)
        });
    };
    gte(value1, message) {
        return this.setLimit("min", value1, true, errorUtil.toString(message));
    }
    min = this.gte;
    gt(value1, message) {
        return this.setLimit("min", value1, false, errorUtil.toString(message));
    }
    lte(value1, message) {
        return this.setLimit("max", value1, true, errorUtil.toString(message));
    }
    max = this.lte;
    lt(value1, message) {
        return this.setLimit("max", value1, false, errorUtil.toString(message));
    }
    setLimit(kind, value1, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value: value1,
                    inclusive,
                    message: errorUtil.toString(message)
                }
            ]
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message)
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
        });
    }
    multipleOf(value1, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value1,
            message: errorUtil.toString(message)
        });
    }
    step = this.multipleOf;
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message)
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message)
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message)
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch)=>ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
                return true;
            } else if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            } else if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
class ZodBigInt extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.bigint,
                received: ctx.parsedType
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks){
            if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    static create = (params)=>{
        return new ZodBigInt({
            checks: [],
            typeName: ZodFirstPartyTypeKind.ZodBigInt,
            coerce: params?.coerce ?? false,
            ...processCreateParams(params)
        });
    };
    gte(value1, message) {
        return this.setLimit("min", value1, true, errorUtil.toString(message));
    }
    min = this.gte;
    gt(value1, message) {
        return this.setLimit("min", value1, false, errorUtil.toString(message));
    }
    lte(value1, message) {
        return this.setLimit("max", value1, true, errorUtil.toString(message));
    }
    max = this.lte;
    lt(value1, message) {
        return this.setLimit("max", value1, false, errorUtil.toString(message));
    }
    setLimit(kind, value1, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value: value1,
                    inclusive,
                    message: errorUtil.toString(message)
                }
            ]
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
        });
    }
    multipleOf(value1, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value1,
            message: errorUtil.toString(message)
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
}
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType
            });
            return INVALID;
        }
        return OK(input.data);
    }
    static create = (params)=>{
        return new ZodBoolean({
            typeName: ZodFirstPartyTypeKind.ZodBoolean,
            coerce: params?.coerce || false,
            ...processCreateParams(params)
        });
    };
}
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks){
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime())
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message)
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message)
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
    static create = (params)=>{
        return new ZodDate({
            checks: [],
            coerce: params?.coerce || false,
            typeName: ZodFirstPartyTypeKind.ZodDate,
            ...processCreateParams(params)
        });
    };
}
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: ctx.parsedType
            });
            return INVALID;
        }
        return OK(input.data);
    }
    static create = (params)=>{
        return new ZodSymbol({
            typeName: ZodFirstPartyTypeKind.ZodSymbol,
            ...processCreateParams(params)
        });
    };
}
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType
            });
            return INVALID;
        }
        return OK(input.data);
    }
    params;
    static create = (params)=>{
        return new ZodUndefined({
            typeName: ZodFirstPartyTypeKind.ZodUndefined,
            ...processCreateParams(params)
        });
    };
}
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType
            });
            return INVALID;
        }
        return OK(input.data);
    }
    static create = (params)=>{
        return new ZodNull({
            typeName: ZodFirstPartyTypeKind.ZodNull,
            ...processCreateParams(params)
        });
    };
}
class ZodAny extends ZodType {
    _any = true;
    _parse(input) {
        return OK(input.data);
    }
    static create = (params)=>{
        return new ZodAny({
            typeName: ZodFirstPartyTypeKind.ZodAny,
            ...processCreateParams(params)
        });
    };
}
class ZodUnknown extends ZodType {
    _unknown = true;
    _parse(input) {
        return OK(input.data);
    }
    static create = (params)=>{
        return new ZodUnknown({
            typeName: ZodFirstPartyTypeKind.ZodUnknown,
            ...processCreateParams(params)
        });
    };
}
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType
        });
        return INVALID;
    }
    static create = (params)=>{
        return new ZodNever({
            typeName: ZodFirstPartyTypeKind.ZodNever,
            ...processCreateParams(params)
        });
    };
}
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType
            });
            return INVALID;
        }
        return OK(input.data);
    }
    static create = (params)=>{
        return new ZodVoid({
            typeName: ZodFirstPartyTypeKind.ZodVoid,
            ...processCreateParams(params)
        });
    };
}
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType
            });
            return INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                addIssueToContext(ctx, {
                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                    minimum: tooSmall ? def.exactLength.value : undefined,
                    maximum: tooBig ? def.exactLength.value : undefined,
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([
                ...ctx.data
            ].map((item, i)=>{
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result)=>{
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = [
            ...ctx.data
        ].map((item, i)=>{
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: {
                value: minLength,
                message: errorUtil.toString(message)
            }
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: {
                value: maxLength,
                message: errorUtil.toString(message)
            }
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: {
                value: len,
                message: errorUtil.toString(message)
            }
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
    static create = (schema, params)=>{
        return new ZodArray({
            type: schema,
            minLength: null,
            maxLength: null,
            exactLength: null,
            typeName: ZodFirstPartyTypeKind.ZodArray,
            ...processCreateParams(params)
        });
    };
}
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for(const key in schema.shape){
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: ()=>newShape
        });
    } else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element)
        });
    } else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));
    } else {
        return schema;
    }
}
class ZodObject extends ZodType {
    _cached = null;
    _getCached() {
        if (this._cached !== null) return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return this._cached = {
            shape,
            keys
        };
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for(const key in ctx.data){
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys){
            const keyValidator = shape[key];
            const value1 = ctx.data[key];
            pairs.push({
                key: {
                    status: "valid",
                    value: key
                },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value1, ctx.path, key)),
                alwaysSet: key in ctx.data
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys){
                    pairs.push({
                        key: {
                            status: "valid",
                            value: key
                        },
                        value: {
                            status: "valid",
                            value: ctx.data[key]
                        }
                    });
                }
            } else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys
                    });
                    status.dirty();
                }
            } else if (unknownKeys === "strip") {} else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        } else {
            const catchall = this._def.catchall;
            for (const key of extraKeys){
                const value1 = ctx.data[key];
                pairs.push({
                    key: {
                        status: "valid",
                        value: key
                    },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value1, ctx.path, key)),
                    alwaysSet: key in ctx.data
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve().then(async ()=>{
                const syncPairs = [];
                for (const pair of pairs){
                    const key = await pair.key;
                    syncPairs.push({
                        key,
                        value: await pair.value,
                        alwaysSet: pair.alwaysSet
                    });
                }
                return syncPairs;
            }).then((syncPairs)=>{
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        } else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...message !== undefined ? {
                errorMap: (issue, ctx)=>{
                    const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
                    if (issue.code === "unrecognized_keys") return {
                        message: errorUtil.errToObj(message).message ?? defaultError
                    };
                    return {
                        message: defaultError
                    };
                }
            } : {}
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip"
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough"
        });
    }
    nonstrict = this.passthrough;
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: ()=>({
                    ...this._def.shape(),
                    ...augmentation
                })
        });
    }
    augment = this.extend;
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: ()=>({
                    ...this._def.shape(),
                    ...merging._def.shape()
                }),
            typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
    }
    setKey(key, schema) {
        return this.augment({
            [key]: schema
        });
    }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index
        });
    }
    pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key)=>{
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: ()=>shape
        });
    }
    omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key)=>{
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: ()=>shape
        });
    }
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key)=>{
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            } else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: ()=>newShape
        });
    }
    required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key)=>{
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            } else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while(newField instanceof ZodOptional){
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: ()=>newShape
        });
    }
    keyof() {
        return createZodEnum(util.objectKeys(this.shape));
    }
    static create = (shape, params)=>{
        return new ZodObject({
            shape: ()=>shape,
            unknownKeys: "strip",
            catchall: ZodNever.create(),
            typeName: ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params)
        });
    };
    static strictCreate = (shape, params)=>{
        return new ZodObject({
            shape: ()=>shape,
            unknownKeys: "strict",
            catchall: ZodNever.create(),
            typeName: ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params)
        });
    };
    static lazycreate = (shape, params)=>{
        return new ZodObject({
            shape,
            unknownKeys: "strip",
            catchall: ZodNever.create(),
            typeName: ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params)
        });
    };
}
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            for (const result of results){
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results){
                if (result.result.status === "dirty") {
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            const unionErrors = results.map((result)=>new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option)=>{
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx
                    }),
                    ctx: childCtx
                };
            })).then(handleResults);
        } else {
            let dirty = undefined;
            const issues = [];
            for (const option of options){
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: []
                    },
                    parent: null
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx
                });
                if (result.status === "valid") {
                    return result;
                } else if (result.status === "dirty" && !dirty) {
                    dirty = {
                        result,
                        ctx: childCtx
                    };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues)=>new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
    static create = (types, params)=>{
        return new ZodUnion({
            options: types,
            typeName: ZodFirstPartyTypeKind.ZodUnion,
            ...processCreateParams(params)
        });
    };
}
const getDiscriminator = (type)=>{
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
        return [
            type.value
        ];
    } else if (type instanceof ZodEnum) {
        return type.options;
    } else if (type instanceof ZodNativeEnum) {
        return Object.keys(type.enum);
    } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
        return [
            undefined
        ];
    } else if (type instanceof ZodNull) {
        return [
            null
        ];
    } else {
        return null;
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [
                    discriminator
                ]
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
        } else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    static create(discriminator, options, params) {
        const optionsMap = new Map();
        for (const type of options){
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value1 of discriminatorValues){
                if (optionsMap.has(value1)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value1)}`);
                }
                optionsMap.set(value1, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params)
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return {
            valid: true,
            data: a
        };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util.objectKeys(b);
        const sharedKeys = util.objectKeys(a).filter((key)=>bKeys.indexOf(key) !== -1);
        const newObj = {
            ...a,
            ...b
        };
        for (const key of sharedKeys){
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return {
                    valid: false
                };
            }
            newObj[key] = sharedValue.data;
        }
        return {
            valid: true,
            data: newObj
        };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return {
                valid: false
            };
        }
        const newArray = [];
        for(let index = 0; index < a.length; index++){
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return {
                    valid: false
                };
            }
            newArray.push(sharedValue.data);
        }
        return {
            valid: true,
            data: newArray
        };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
        return {
            valid: true,
            data: a
        };
    } else {
        return {
            valid: false
        };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight)=>{
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return {
                status: status.value,
                value: merged.data
            };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                })
            ]).then(([left, right])=>handleParsed(left, right));
        } else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }));
        }
    }
    static create = (left, right, params)=>{
        return new ZodIntersection({
            left: left,
            right: right,
            typeName: ZodFirstPartyTypeKind.ZodIntersection,
            ...processCreateParams(params)
        });
    };
}
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array"
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array"
            });
            status.dirty();
        }
        const items = [
            ...ctx.data
        ].map((item, itemIndex)=>{
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema) return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x)=>!!x);
        if (ctx.common.async) {
            return Promise.all(items).then((results)=>{
                return ParseStatus.mergeArray(status, results);
            });
        } else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest
        });
    }
    static create = (schemas, params)=>{
        if (!Array.isArray(schemas)) {
            throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        }
        return new ZodTuple({
            items: schemas,
            typeName: ZodFirstPartyTypeKind.ZodTuple,
            rest: null,
            ...processCreateParams(params)
        });
    };
}
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for(const key in ctx.data){
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third)
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second)
        });
    }
}
class ZodMap extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [
            ...ctx.data.entries()
        ].map(([key, value1], index)=>{
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [
                    index,
                    "key"
                ])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value1, ctx.path, [
                    index,
                    "value"
                ]))
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async ()=>{
                for (const pair of pairs){
                    const key = await pair.key;
                    const value1 = await pair.value;
                    if (key.status === "aborted" || value1.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value1.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value1.value);
                }
                return {
                    status: status.value,
                    value: finalMap
                };
            });
        } else {
            const finalMap = new Map();
            for (const pair of pairs){
                const key = pair.key;
                const value1 = pair.value;
                if (key.status === "aborted" || value1.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value1.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value1.value);
            }
            return {
                status: status.value,
                value: finalMap
            };
        }
    }
    static create = (keyType, valueType, params)=>{
        return new ZodMap({
            valueType,
            keyType,
            typeName: ZodFirstPartyTypeKind.ZodMap,
            ...processCreateParams(params)
        });
    };
}
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements){
                if (element.status === "aborted") return INVALID;
                if (element.status === "dirty") status.dirty();
                parsedSet.add(element.value);
            }
            return {
                status: status.value,
                value: parsedSet
            };
        }
        const elements = [
            ...ctx.data.values()
        ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements)=>finalizeSet(elements));
        } else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: {
                value: minSize,
                message: errorUtil.toString(message)
            }
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: {
                value: maxSize,
                message: errorUtil.toString(message)
            }
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
    static create = (valueType, params)=>{
        return new ZodSet({
            valueType,
            minSize: null,
            maxSize: null,
            typeName: ZodFirstPartyTypeKind.ZodSet,
            ...processCreateParams(params)
        });
    };
}
class ZodFunction extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap
                ].filter((x)=>!!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error
                }
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap
                ].filter((x)=>!!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error
                }
            });
        }
        const params = {
            errorMap: ctx.common.contextualErrorMap
        };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            return OK(async (...args)=>{
                const error = new ZodError([]);
                const parsedArgs = await this._def.args.parseAsync(args, params).catch((e)=>{
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await fn(...parsedArgs);
                const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e)=>{
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        } else {
            return OK((...args)=>{
                const parsedArgs = this._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([
                        makeArgsIssue(args, parsedArgs.error)
                    ]);
                }
                const result = fn(...parsedArgs.data);
                const parsedReturns = this._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([
                        makeReturnsIssue(result, parsedReturns.error)
                    ]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    validate = this.implement;
    static create(args, returns, params) {
        return new ZodFunction({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params)
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        });
    }
    static create = (getter, params)=>{
        return new ZodLazy({
            getter: getter,
            typeName: ZodFirstPartyTypeKind.ZodLazy,
            ...processCreateParams(params)
        });
    };
}
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value
            });
            return INVALID;
        }
        return {
            status: "valid",
            value: input.data
        };
    }
    get value() {
        return this._def.value;
    }
    static create = (value1, params)=>{
        return new ZodLiteral({
            value: value1,
            typeName: ZodFirstPartyTypeKind.ZodLiteral,
            ...processCreateParams(params)
        });
    };
}
function createZodEnum(values, params) {
    return new ZodEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type
            });
            return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val1 of this._def.values){
            enumValues[val1] = val1;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val1 of this._def.values){
            enumValues[val1] = val1;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val1 of this._def.values){
            enumValues[val1] = val1;
        }
        return enumValues;
    }
    extract(values) {
        return ZodEnum.create(values);
    }
    exclude(values) {
        return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)));
    }
    static create = createZodEnum;
}
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type
            });
            return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
    static create = (values, params)=>{
        return new ZodNativeEnum({
            values: values,
            typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
            ...processCreateParams(params)
        });
    };
}
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data)=>{
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap
            });
        }));
    }
    static create = (schema, params)=>{
        return new ZodPromise({
            type: schema,
            typeName: ZodFirstPartyTypeKind.ZodPromise,
            ...processCreateParams(params)
        });
    };
}
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data);
            if (ctx.common.async) {
                return Promise.resolve(processed).then((processed)=>{
                    return this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx
                    });
                });
            } else {
                return this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx
                });
            }
        }
        const checkCtx = {
            addIssue: (arg)=>{
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                } else {
                    status.dirty();
                }
            },
            get path () {
                return ctx.path;
            }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "refinement") {
            const executeRefinement = (acc)=>{
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (inner.status === "aborted") return INVALID;
                if (inner.status === "dirty") status.dirty();
                executeRefinement(inner.value);
                return {
                    status: status.value,
                    value: inner.value
                };
            } else {
                return this._def.schema._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }).then((inner)=>{
                    if (inner.status === "aborted") return INVALID;
                    if (inner.status === "dirty") status.dirty();
                    return executeRefinement(inner.value).then(()=>{
                        return {
                            status: status.value,
                            value: inner.value
                        };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (!isValid(base)) return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return {
                    status: status.value,
                    value: result
                };
            } else {
                return this._def.schema._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }).then((base)=>{
                    if (!isValid(base)) return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({
                            status: status.value,
                            value: result
                        }));
                });
            }
        }
        util.assertNever(effect);
    }
    static create = (schema, effect, params)=>{
        return new ZodEffects({
            schema,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect,
            ...processCreateParams(params)
        });
    };
    static createWithPreprocess = (preprocess, schema, params)=>{
        return new ZodEffects({
            schema,
            effect: {
                type: "preprocess",
                transform: preprocess
            },
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            ...processCreateParams(params)
        });
    };
}
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
    static create = (type, params)=>{
        return new ZodOptional({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodOptional,
            ...processCreateParams(params)
        });
    };
}
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
    static create = (type, params)=>{
        return new ZodNullable({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodNullable,
            ...processCreateParams(params)
        });
    };
}
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
    static create = (type, params)=>{
        return new ZodDefault({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
            defaultValue: typeof params.default === "function" ? params.default : ()=>params.default,
            ...processCreateParams(params)
        });
    };
}
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: []
            }
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx
            }
        });
        if (isAsync(result)) {
            return result.then((result)=>{
                return {
                    status: "valid",
                    value: result.status === "valid" ? result.value : this._def.catchValue({
                        get error () {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data
                    })
                };
            });
        } else {
            return {
                status: "valid",
                value: result.status === "valid" ? result.value : this._def.catchValue({
                    get error () {
                        return new ZodError(newCtx.common.issues);
                    },
                    input: newCtx.data
                })
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
    static create = (type, params)=>{
        return new ZodCatch({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
            catchValue: typeof params.catch === "function" ? params.catch : ()=>params.catch,
            ...processCreateParams(params)
        });
    };
}
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType
            });
            return INVALID;
        }
        return {
            status: "valid",
            value: input.data
        };
    }
    static create = (params)=>{
        return new ZodNaN({
            typeName: ZodFirstPartyTypeKind.ZodNaN,
            ...processCreateParams(params)
        });
    };
}
Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async ()=>{
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (inResult.status === "aborted") return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return DIRTY(inResult.value);
                } else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx
                    });
                }
            };
            return handleAsync();
        } else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
            if (inResult.status === "aborted") return INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value
                };
            } else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
    }
}
({
    object: ZodObject.lazycreate
});
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
ZodString.create;
ZodNumber.create;
ZodNaN.create;
ZodBigInt.create;
ZodBoolean.create;
ZodDate.create;
ZodSymbol.create;
ZodUndefined.create;
ZodNull.create;
ZodAny.create;
ZodUnknown.create;
ZodNever.create;
ZodVoid.create;
ZodArray.create;
ZodObject.create;
ZodObject.strictCreate;
ZodUnion.create;
ZodDiscriminatedUnion.create;
ZodIntersection.create;
ZodTuple.create;
ZodRecord.create;
ZodMap.create;
ZodSet.create;
ZodFunction.create;
ZodLazy.create;
ZodLiteral.create;
ZodEnum.create;
ZodNativeEnum.create;
ZodPromise.create;
ZodEffects.create;
ZodOptional.create;
ZodNullable.create;
ZodEffects.createWithPreprocess;
ZodPipeline.create;
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert1(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
const { hasOwn: hasOwn1 } = Object;
const osType1 = (()=>{
    const { Deno: Deno1 } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator: navigator1 } = globalThis;
    if (navigator1?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows1 = osType1 === "windows";
const CHAR_FORWARD_SLASH1 = 47;
function assertPath1(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator1(code) {
    return code === 47;
}
function isPathSeparator1(code) {
    return isPosixPathSeparator1(code) || code === 92;
}
function isWindowsDeviceRoot1(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString1(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH1;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format1(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (base === sep) return dir;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS1 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace1(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS1[c] ?? c;
    });
}
function lastPathSegment1(path, isSep, start = 0) {
    let matchedNonSeparator = false;
    let end = path.length;
    for(let i = path.length - 1; i >= start; --i){
        if (isSep(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                start = i + 1;
                break;
            }
        } else if (!matchedNonSeparator) {
            matchedNonSeparator = true;
            end = i + 1;
        }
    }
    return path.slice(start, end);
}
function stripTrailingSeparators1(segment, isSep) {
    if (segment.length <= 1) {
        return segment;
    }
    let end = segment.length;
    for(let i = segment.length - 1; i > 0; i--){
        if (isSep(segment.charCodeAt(i))) {
            end = i;
        } else {
            break;
        }
    }
    return segment.slice(0, end);
}
function stripSuffix1(name, suffix) {
    if (suffix.length >= name.length) {
        return name;
    }
    const lenDiff = name.length - suffix.length;
    for(let i = suffix.length - 1; i >= 0; --i){
        if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
            return name;
        }
    }
    return name.slice(0, -suffix.length);
}
const sep2 = "\\";
const delimiter3 = ";";
function resolve3(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1 } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath1(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator1(code)) {
                isAbsolute = true;
                if (isPathSeparator1(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator1(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot1(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator1(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator1(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize4(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            isAbsolute = true;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString1(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator1);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator1(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator1(code)) {
        return true;
    } else if (isWindowsDeviceRoot1(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator1(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join4(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert1(firstPart != null);
    if (isPathSeparator1(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator1(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator1(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator1(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize4(joined);
}
function relative3(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    const fromOrig = resolve3(from);
    const toOrig = resolve3(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath3(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve3(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator1(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return stripTrailingSeparators1(path.slice(0, end), isPosixPathSeparator1);
}
function basename3(path, suffix = "") {
    assertPath1(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    let start = 0;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot1(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    const lastSegment = lastPathSegment1(path, isPathSeparator1, start);
    const strippedSegment = stripTrailingSeparators1(lastSegment, isPathSeparator1);
    return suffix ? stripSuffix1(strippedSegment, suffix) : strippedSegment;
}
function extname3(path) {
    assertPath1(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format3(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("\\", pathObject);
}
function parse3(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            ret.base = "\\";
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        ret.root = ret.dir = path;
        ret.base = "\\";
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    ret.base = ret.base || "\\";
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl3(path) {
    if (!isAbsolute3(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod2 = {
    sep: sep2,
    delimiter: delimiter3,
    resolve: resolve3,
    normalize: normalize4,
    isAbsolute: isAbsolute3,
    join: join4,
    relative: relative3,
    toNamespacedPath: toNamespacedPath3,
    dirname: dirname3,
    basename: basename3,
    extname: extname3,
    format: format3,
    parse: parse3,
    fromFileUrl: fromFileUrl3,
    toFileUrl: toFileUrl3
};
const sep3 = "/";
const delimiter4 = ":";
function resolve4(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1 } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath1(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = isPosixPathSeparator1(path.charCodeAt(0));
    }
    resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize5(path) {
    assertPath1(path);
    if (path.length === 0) return ".";
    const isAbsolute = isPosixPathSeparator1(path.charCodeAt(0));
    const trailingSeparator = isPosixPathSeparator1(path.charCodeAt(path.length - 1));
    path = normalizeString1(path, !isAbsolute, "/", isPosixPathSeparator1);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute4(path) {
    assertPath1(path);
    return path.length > 0 && isPosixPathSeparator1(path.charCodeAt(0));
}
function join5(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize5(joined);
}
function relative4(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    from = resolve4(from);
    to = resolve4(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (!isPosixPathSeparator1(from.charCodeAt(fromStart))) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (!isPosixPathSeparator1(to.charCodeAt(toStart))) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (isPosixPathSeparator1(to.charCodeAt(toStart + i))) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (isPosixPathSeparator1(from.charCodeAt(fromStart + i))) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (isPosixPathSeparator1(fromCode)) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || isPosixPathSeparator1(from.charCodeAt(i))) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (isPosixPathSeparator1(to.charCodeAt(toStart))) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath4(path) {
    return path;
}
function dirname4(path) {
    if (path.length === 0) return ".";
    let end = -1;
    let matchedNonSeparator = false;
    for(let i = path.length - 1; i >= 1; --i){
        if (isPosixPathSeparator1(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                end = i;
                break;
            }
        } else {
            matchedNonSeparator = true;
        }
    }
    if (end === -1) {
        return isPosixPathSeparator1(path.charCodeAt(0)) ? "/" : ".";
    }
    return stripTrailingSeparators1(path.slice(0, end), isPosixPathSeparator1);
}
function basename4(path, suffix = "") {
    assertPath1(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    const lastSegment = lastPathSegment1(path, isPosixPathSeparator1);
    const strippedSegment = stripTrailingSeparators1(lastSegment, isPosixPathSeparator1);
    return suffix ? stripSuffix1(strippedSegment, suffix) : strippedSegment;
}
function extname4(path) {
    assertPath1(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format4(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("/", pathObject);
}
function parse4(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = isPosixPathSeparator1(path.charCodeAt(0));
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        ret.base = ret.base || "/";
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) {
        ret.dir = stripTrailingSeparators1(path.slice(0, startPart - 1), isPosixPathSeparator1);
    } else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl4(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl4(path) {
    if (!isAbsolute4(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod3 = {
    sep: sep3,
    delimiter: delimiter4,
    resolve: resolve4,
    normalize: normalize5,
    isAbsolute: isAbsolute4,
    join: join5,
    relative: relative4,
    toNamespacedPath: toNamespacedPath4,
    dirname: dirname4,
    basename: basename4,
    extname: extname4,
    format: format4,
    parse: parse4,
    fromFileUrl: fromFileUrl4,
    toFileUrl: toFileUrl4
};
const SEP = isWindows1 ? "\\" : "/";
const SEP_PATTERN = isWindows1 ? /[\\/]+/ : /\/+/;
function common(paths, sep = SEP) {
    const [first = "", ...remaining] = paths;
    if (first === "" || remaining.length === 0) {
        return first.substring(0, first.lastIndexOf(sep) + 1);
    }
    const parts = first.split(sep);
    let endOfPrefix = parts.length;
    for (const path of remaining){
        const compare = path.split(sep);
        for(let i = 0; i < endOfPrefix; i++){
            if (compare[i] !== parts[i]) {
                endOfPrefix = i;
            }
        }
        if (endOfPrefix === 0) {
            return "";
        }
    }
    const prefix = parts.slice(0, endOfPrefix).join(sep);
    return prefix.endsWith(sep) ? prefix : `${prefix}${sep}`;
}
const path2 = isWindows1 ? mod2 : mod3;
const { join: join6, normalize: normalize6 } = path2;
const regExpEscapeChars = [
    "!",
    "$",
    "(",
    ")",
    "*",
    "+",
    ".",
    "=",
    "?",
    "[",
    "\\",
    "^",
    "{",
    "|"
];
const rangeEscapeChars = [
    "-",
    "\\",
    "]"
];
function globToRegExp(glob, { extended = true, globstar: globstarOption = true, os = osType1, caseInsensitive = false } = {}) {
    if (glob == "") {
        return /(?!)/;
    }
    const sep = os == "windows" ? "(?:\\\\|/)+" : "/+";
    const sepMaybe = os == "windows" ? "(?:\\\\|/)*" : "/*";
    const seps = os == "windows" ? [
        "\\",
        "/"
    ] : [
        "/"
    ];
    const globstar = os == "windows" ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*" : "(?:[^/]*(?:/|$)+)*";
    const wildcard = os == "windows" ? "[^\\\\/]*" : "[^/]*";
    const escapePrefix = os == "windows" ? "`" : "\\";
    let newLength = glob.length;
    for(; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--);
    glob = glob.slice(0, newLength);
    let regExpString = "";
    for(let j = 0; j < glob.length;){
        let segment = "";
        const groupStack = [];
        let inRange = false;
        let inEscape = false;
        let endsWithSep = false;
        let i = j;
        for(; i < glob.length && !seps.includes(glob[i]); i++){
            if (inEscape) {
                inEscape = false;
                const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
                segment += escapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
                continue;
            }
            if (glob[i] == escapePrefix) {
                inEscape = true;
                continue;
            }
            if (glob[i] == "[") {
                if (!inRange) {
                    inRange = true;
                    segment += "[";
                    if (glob[i + 1] == "!") {
                        i++;
                        segment += "^";
                    } else if (glob[i + 1] == "^") {
                        i++;
                        segment += "\\^";
                    }
                    continue;
                } else if (glob[i + 1] == ":") {
                    let k = i + 1;
                    let value1 = "";
                    while(glob[k + 1] != null && glob[k + 1] != ":"){
                        value1 += glob[k + 1];
                        k++;
                    }
                    if (glob[k + 1] == ":" && glob[k + 2] == "]") {
                        i = k + 2;
                        if (value1 == "alnum") segment += "\\dA-Za-z";
                        else if (value1 == "alpha") segment += "A-Za-z";
                        else if (value1 == "ascii") segment += "\x00-\x7F";
                        else if (value1 == "blank") segment += "\t ";
                        else if (value1 == "cntrl") segment += "\x00-\x1F\x7F";
                        else if (value1 == "digit") segment += "\\d";
                        else if (value1 == "graph") segment += "\x21-\x7E";
                        else if (value1 == "lower") segment += "a-z";
                        else if (value1 == "print") segment += "\x20-\x7E";
                        else if (value1 == "punct") {
                            segment += "!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_‘{|}~";
                        } else if (value1 == "space") segment += "\\s\v";
                        else if (value1 == "upper") segment += "A-Z";
                        else if (value1 == "word") segment += "\\w";
                        else if (value1 == "xdigit") segment += "\\dA-Fa-f";
                        continue;
                    }
                }
            }
            if (glob[i] == "]" && inRange) {
                inRange = false;
                segment += "]";
                continue;
            }
            if (inRange) {
                if (glob[i] == "\\") {
                    segment += `\\\\`;
                } else {
                    segment += glob[i];
                }
                continue;
            }
            if (glob[i] == ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += ")";
                const type = groupStack.pop();
                if (type == "!") {
                    segment += wildcard;
                } else if (type != "@") {
                    segment += type;
                }
                continue;
            }
            if (glob[i] == "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i] == "+" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("+");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "@" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("@");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "?") {
                if (extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("?");
                    segment += "(?:";
                } else {
                    segment += ".";
                }
                continue;
            }
            if (glob[i] == "!" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("!");
                segment += "(?!";
                continue;
            }
            if (glob[i] == "{") {
                groupStack.push("BRACE");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
                groupStack.pop();
                segment += ")";
                continue;
            }
            if (glob[i] == "," && groupStack[groupStack.length - 1] == "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i] == "*") {
                if (extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("*");
                    segment += "(?:";
                } else {
                    const prevChar = glob[i - 1];
                    let numStars = 1;
                    while(glob[i + 1] == "*"){
                        i++;
                        numStars++;
                    }
                    const nextChar = glob[i + 1];
                    if (globstarOption && numStars == 2 && [
                        ...seps,
                        undefined
                    ].includes(prevChar) && [
                        ...seps,
                        undefined
                    ].includes(nextChar)) {
                        segment += globstar;
                        endsWithSep = true;
                    } else {
                        segment += wildcard;
                    }
                }
                continue;
            }
            segment += regExpEscapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
        }
        if (groupStack.length > 0 || inRange || inEscape) {
            segment = "";
            for (const c of glob.slice(j, i)){
                segment += regExpEscapeChars.includes(c) ? `\\${c}` : c;
                endsWithSep = false;
            }
        }
        regExpString += segment;
        if (!endsWithSep) {
            regExpString += i < glob.length ? sep : sepMaybe;
            endsWithSep = true;
        }
        while(seps.includes(glob[i]))i++;
        if (!(i > j)) {
            throw new Error("Assertion failure: i > j (potential infinite loop)");
        }
        j = i;
    }
    regExpString = `^${regExpString}$`;
    return new RegExp(regExpString, caseInsensitive ? "i" : "");
}
function isGlob(str) {
    const chars = {
        "{": "}",
        "(": ")",
        "[": "]"
    };
    const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
    if (str === "") {
        return false;
    }
    let match;
    while(match = regex.exec(str)){
        if (match[2]) return true;
        let idx = match.index + match[0].length;
        const open = match[1];
        const close = open ? chars[open] : null;
        if (open && close) {
            const n = str.indexOf(close, idx);
            if (n !== -1) {
                idx = n + 1;
            }
        }
        str = str.slice(idx);
    }
    return false;
}
function normalizeGlob(glob, { globstar = false } = {}) {
    if (glob.match(/\0/g)) {
        throw new Error(`Glob contains invalid characters: "${glob}"`);
    }
    if (!globstar) {
        return normalize6(glob);
    }
    const s = SEP_PATTERN.source;
    const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
    return normalize6(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}
function joinGlobs(globs, { extended = true, globstar = false } = {}) {
    if (!globstar || globs.length == 0) {
        return join6(...globs);
    }
    if (globs.length === 0) return ".";
    let joined;
    for (const glob of globs){
        const path = glob;
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `${SEP}${path}`;
        }
    }
    if (!joined) return ".";
    return normalizeGlob(joined, {
        extended,
        globstar
    });
}
const path3 = isWindows1 ? mod2 : mod3;
const { basename: basename5, delimiter: delimiter5, dirname: dirname5, extname: extname5, format: format5, fromFileUrl: fromFileUrl5, isAbsolute: isAbsolute5, join: join7, normalize: normalize7, parse: parse5, relative: relative5, resolve: resolve5, toFileUrl: toFileUrl5, toNamespacedPath: toNamespacedPath5 } = path3;
const mod4 = {
    SEP: SEP,
    SEP_PATTERN: SEP_PATTERN,
    win32: mod2,
    posix: mod3,
    basename: basename5,
    delimiter: delimiter5,
    dirname: dirname5,
    extname: extname5,
    format: format5,
    fromFileUrl: fromFileUrl5,
    isAbsolute: isAbsolute5,
    join: join7,
    normalize: normalize7,
    parse: parse5,
    relative: relative5,
    resolve: resolve5,
    toFileUrl: toFileUrl5,
    toNamespacedPath: toNamespacedPath5,
    common,
    globToRegExp,
    isGlob,
    normalizeGlob,
    joinGlobs
};
function existsSync(path, options) {
    try {
        const stat = Deno.statSync(path);
        if (options && (options.isReadable || options.isDirectory || options.isFile)) {
            if (options.isDirectory && options.isFile) {
                throw new TypeError("ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together.");
            }
            if (options.isDirectory && !stat.isDirectory || options.isFile && !stat.isFile) {
                return false;
            }
            if (options.isReadable) {
                if (stat.mode == null) {
                    return true;
                }
                if (Deno.uid() == stat.uid) {
                    return (stat.mode & 0o400) == 0o400;
                } else if (Deno.gid() == stat.gid) {
                    return (stat.mode & 0o040) == 0o040;
                }
                return (stat.mode & 0o004) == 0o004;
            }
        }
        return true;
    } catch (error) {
        if (error instanceof Deno.errors.NotFound) {
            return false;
        }
        if (error instanceof Deno.errors.PermissionDenied) {
            if (Deno.permissions.querySync({
                name: "read",
                path
            }).state === "granted") {
                return !options?.isReadable;
            }
        }
        throw error;
    }
}
new Deno.errors.AlreadyExists("dest already exists.");
var EOL1;
(function(EOL) {
    EOL["LF"] = "\n";
    EOL["CRLF"] = "\r\n";
})(EOL1 || (EOL1 = {}));
const serviceFileTemplate = `[Unit]
Description={{name}} (Deno Service)

[Service]
ExecStart=/bin/sh -c "{{command}}"
Restart=always
RestartSec=30
Environment={{path}}
{{extraEnvs}}
WorkingDirectory={{workingDirectory}}
{{extraServiceContent}}

[Install]
WantedBy={{wantedByTarget}}
`;
class SystemdService {
    constructor(){}
    async install(config, onlyGenerate) {
        const serviceFileName = `${config.name}.service`;
        const servicePathUser = `${config.home}/.config/systemd/user/${serviceFileName}`;
        const servicePathSystem = `/etc/systemd/system/${serviceFileName}`;
        const servicePath = config.system ? servicePathSystem : servicePathUser;
        if (existsSync(servicePathUser)) {
            console.error(`Service '${config.name}' already exists in '${servicePathUser}'. Exiting.`);
            Deno.exit(1);
        }
        if (existsSync(servicePathSystem)) {
            console.error(`Service '${config.name}' already exists in '${servicePathSystem}'. Exiting.`);
            Deno.exit(1);
        }
        if (!config.system && !onlyGenerate) {
            if (!config.user) {
                throw new Error("Username not found in $USER, must be specified using the --username flag.");
            }
            const enableLingerCommand = new Deno.Command("loginctl", {
                args: [
                    "enable-linger",
                    config.user
                ]
            });
            const enableLinger = enableLingerCommand.spawn();
            const status = await enableLinger.status;
            if (!status.success) {
                throw new Error("Failed to enable linger for user mode.");
            }
        }
        const serviceFileContent = this.generateConfig(config);
        if (onlyGenerate) {
            console.log("\nThis is a dry-run, nothing will be written to disk or installed.");
            console.log("\nPath: ", servicePath);
            console.log("\nConfiguration:\n");
            console.log(serviceFileContent);
        } else if (config.system) {
            const tempFilePath = await Deno.makeTempFile();
            await Deno.writeTextFile(tempFilePath, serviceFileContent);
            console.log("\Service installer do not have (and should not have) root permissions, so the next steps have to be carried out manually.");
            console.log(`\nStep 1: The systemd configuration has been saved to a temporary file, copy this file to the correct location using the following command:`);
            console.log(`\n  sudo cp ${tempFilePath} ${servicePath}`);
            console.log(`\nStep 2: Reload systemd configuration`);
            console.log(`\n  sudo systemctl daemon-reload`);
            console.log(`\nStep 3: Enable the service`);
            console.log(`\n  sudo systemctl enable ${config.name}`);
            console.log(`\nStep 4: Start the service now`);
            console.log(`\n  sudo systemctl start ${config.name}\n`);
        } else {
            const serviceDir = mod4.dirname(servicePath);
            await Deno.mkdir(serviceDir, {
                recursive: true
            });
            await Deno.writeTextFile(servicePath, serviceFileContent);
            const daemonReloadCommand = new Deno.Command("systemctl", {
                args: [
                    config.system ? "" : "--user",
                    "daemon-reload"
                ],
                stderr: "piped",
                stdout: "piped"
            });
            const daemonReload = daemonReloadCommand.spawn();
            const daemonReloadOutput = await daemonReload.output();
            const daemonReloadText = new TextDecoder().decode(daemonReloadOutput.stderr);
            if (!daemonReloadOutput.success) {
                await this.rollback(servicePath, config.system);
                throw new Error("Failed to reload daemon, rolled back any changes. Error: \n" + daemonReloadText);
            }
            const enableServiceCommand = new Deno.Command("systemctl", {
                args: [
                    config.system ? "" : "--user",
                    "enable",
                    config.name
                ],
                stderr: "piped",
                stdout: "piped"
            });
            const enableService = enableServiceCommand.spawn();
            const enableServiceOutput = await enableService.output();
            const enableServiceText = new TextDecoder().decode(enableServiceOutput.stderr);
            if (!enableServiceOutput.success) {
                await this.rollback(servicePath, config.system);
                throw new Error("Failed to enable service, rolled back any changes. Error: \n" + enableServiceText);
            }
            const startServiceCommand = new Deno.Command("systemctl", {
                args: [
                    config.system ? "" : "--user",
                    "start",
                    config.name
                ],
                stderr: "piped",
                stdout: "piped"
            });
            const startService = startServiceCommand.spawn();
            const startServiceOutput = await startService.output();
            const startServiceText = new TextDecoder().decode(startServiceOutput.stderr);
            if (!startServiceOutput.success) {
                await this.rollback(servicePath, config.system);
                throw new Error("Failed to start service, rolled back any changes. Error: \n" + startServiceText);
            }
            console.log(`Service '${config.name}' installed at '${servicePath}' and enabled.`);
        }
    }
    async uninstall(config) {
        const serviceFileName = `${config.name}.service`;
        const servicePathUser = `${config.home}/.config/systemd/user/${serviceFileName}`;
        const servicePathSystem = `/etc/systemd/system/${serviceFileName}`;
        const servicePath = config.system ? servicePathSystem : servicePathUser;
        if (!existsSync(servicePath)) {
            console.error(`Service '${config.name}' does not exist. Exiting.`);
            Deno.exit(1);
        }
        try {
            await Deno.remove(servicePath);
            console.log(`Service '${config.name}' uninstalled successfully.`);
            if (config.system) {
                console.log("Please run the following command as root to reload the systemctl daemon:");
                console.log(`sudo systemctl daemon-reload`);
            } else {
                console.log("Please run the following command to reload the systemctl daemon:");
                console.log(`systemctl --user daemon-reload`);
            }
        } catch (error) {
            console.error(`Failed to uninstall service: Could not remove '${servicePath}'. Error:`, error.message);
        }
    }
    generateConfig(options) {
        const denoPath = Deno.execPath();
        const defaultPath = `PATH=${denoPath}:${options.home}/.deno/bin`;
        const envPath = options.path ? `${defaultPath}:${options.path.join(":")}` : defaultPath;
        const workingDirectory = options.cwd ? options.cwd : Deno.cwd();
        let serviceFileContent = serviceFileTemplate.replace("{{name}}", options.name);
        serviceFileContent = serviceFileContent.replace("{{command}}", options.cmd);
        serviceFileContent = serviceFileContent.replace("{{path}}", envPath);
        serviceFileContent = serviceFileContent.replace("{{workingDirectory}}", workingDirectory);
        if (options.system) {
            serviceFileContent = serviceFileContent.replace("{{extraServiceContent}}", `User=${options.user}`);
            serviceFileContent = serviceFileContent.replace("{{wantedByTarget}}", "multi-user.target");
        } else {
            serviceFileContent = serviceFileContent.replace("{{extraServiceContent}}", "");
            serviceFileContent = serviceFileContent.replace("{{wantedByTarget}}", "default.target");
        }
        if (options.env && options.env.length > 0) {
            let extraEnvs = "";
            for (const env of options.env){
                extraEnvs += `Environment=${env}\n`;
            }
            serviceFileContent = serviceFileContent.replace("{{extraEnvs}}", extraEnvs);
        } else {
            serviceFileContent = serviceFileContent.replace("{{extraEnvs}}", "");
        }
        return serviceFileContent;
    }
    async rollback(servicePath, system) {
        try {
            await Deno.remove(servicePath);
            const daemonReloadCommand = new Deno.Command("systemctl", {
                args: [
                    system ? "" : "--user",
                    "daemon-reload"
                ]
            });
            const daemonReload = daemonReloadCommand.spawn();
            const daemonStatus = await daemonReload.status;
            if (!daemonStatus.success) {
                throw new Error("Failed to reload daemon while rolling back.");
            }
            console.log(`Changes rolled back: Removed '${servicePath}'.`);
        } catch (error) {
            console.error(`Failed to rollback changes: Could not remove '${servicePath}'. Error:`, error.message);
        }
    }
}
const initScriptTemplate = `#!/bin/sh
### BEGIN INIT INFO
# Provides:          {{name}}
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: {{name}} (Deno Service)
# Description:       Start {{name}} service
### END INIT INFO

PATH={{path}}
{{extraEnvs}}

# Change the next line to match your installation
DENO_COMMAND="{{command}}"

case "$1" in
  start)
    echo "Starting {{name}}..."
    $DENO_COMMAND &
    echo $! > /var/run/{{name}}.pid
    ;;
  stop)
    echo "Stopping {{name}}..."
    PID=$(cat /var/run/{{name}}.pid)
    kill $PID
    rm /var/run/{{name}}.pid
    ;;
  restart)
    $0 stop
    $0 start
    ;;
  status)
    if [ -e /var/run/{{name}}.pid ]; then
      echo "{{name}} is running"
    else
      echo "{{name}} is not running"
    fi
    ;;
  *)
    echo "Usage: $0 {start|stop|restart|status}"
    exit 1
    ;;
esac

exit 0
`;
class InitService {
    generateConfig(config) {
        const denoPath = Deno.execPath();
        const command = config.cmd;
        const servicePath = `${config.path?.join(":")}:${denoPath}:${Deno.env.get("HOME")}/.deno/bin`;
        let initScriptContent = initScriptTemplate.replace(/{{name}}/g, config.name);
        initScriptContent = initScriptContent.replace("{{command}}", command);
        initScriptContent = initScriptContent.replace("{{path}}", servicePath);
        if (config.env && config.env.length > 0) {
            let extraEnvs = "";
            for (const env of config.env){
                extraEnvs += `${env}\n`;
            }
            initScriptContent = initScriptContent.replace("{{extraEnvs}}", extraEnvs);
        } else {
            initScriptContent = initScriptContent.replace("{{extraEnvs}}", "");
        }
        return initScriptContent;
    }
    async install(config, onlyGenerate) {
        const initScriptPath = `/etc/init.d/${config.name}`;
        if (existsSync(initScriptPath)) {
            console.error(`Service '${config.name}' already exists in '${initScriptPath}'. Exiting.`);
            Deno.exit(1);
        }
        const initScriptContent = this.generateConfig(config);
        if (onlyGenerate) {
            console.log("\nThis is a dry-run, nothing will be written to disk or installed.");
            console.log("\nPath: ", initScriptPath);
            console.log("\nConfiguration:\n");
            console.log(initScriptContent);
        } else {
            const tempFilePath = await Deno.makeTempFile();
            await Deno.writeTextFile(tempFilePath, initScriptContent);
            console.log("\nThe service installer does not have (and should not have) root permissions, so the next steps have to be carried out manually.");
            console.log(`\nStep 1: The init script has been saved to a temporary file, copy this file to the correct location using the following command:`);
            console.log(`\n  sudo cp ${tempFilePath} ${initScriptPath}`);
            console.log(`\nStep 2: Make the script executable:`);
            console.log(`\n  sudo chmod +x ${initScriptPath}`);
            console.log(`\nStep 3: Enable the service to start at boot:`);
            console.log(`\n  sudo update-rc.d ${config.name} defaults`);
            console.log(`\nStep 4: Start the service now`);
            console.log(`\n  sudo service ${config.name} start`);
        }
    }
    uninstall(config) {
        const initScriptPath = `/etc/init.d/${config.name}`;
        if (!existsSync(initScriptPath)) {
            console.error(`Service '${config.name}' does not exist in '${initScriptPath}'. Exiting.`);
            Deno.exit(1);
        }
        console.log("The uninstaller does not have (and should not have) root permissions, so the next steps have to be carried out manually.");
        console.log(`\nStep 1: Stop the service (if it's running):`);
        console.log(`\n  sudo service ${config.name} stop`);
        console.log(`\nStep 2: Disable the service from starting at boot:`);
        console.log(`\n  sudo update-rc.d -f ${config.name} remove`);
        console.log(`\nStep 3: Remove the init script:`);
        console.log(`\n  sudo rm ${initScriptPath}`);
    }
}
const upstartFileTemplate = `# {{name}} (Deno Service)

description "{{name}} Deno Service"
author "Service user"

start on (filesystem and net-device-up IFACE!=lo)
stop on runlevel [!2345]

respawn
respawn limit 10 5

env PATH={{path}}
{{extraEnvs}}

# Change the next line to match your service installation
env SERVICE_COMMAND="{{command}}"

exec $SERVICE_COMMAND
`;
class UpstartService {
    generateConfig(config) {
        const denoPath = Deno.execPath();
        const defaultPath = `${denoPath}:${Deno.env.get("HOME")}/.deno/bin`;
        const envPath = config.path ? `${defaultPath}:${config.path.join(":")}` : defaultPath;
        let upstartFileContent = upstartFileTemplate.replace(/{{name}}/g, config.name);
        upstartFileContent = upstartFileContent.replace("{{command}}", config.cmd);
        upstartFileContent = upstartFileContent.replace("{{path}}", envPath);
        if (config.env && config.env.length > 0) {
            let extraEnvs = "";
            for (const env of config.env){
                extraEnvs += `env ${env}\n`;
            }
            upstartFileContent = upstartFileContent.replace("{{extraEnvs}}", extraEnvs);
        } else {
            upstartFileContent = upstartFileContent.replace("{{extraEnvs}}", "");
        }
        return upstartFileContent;
    }
    async install(config, onlyGenerate) {
        const upstartFilePath = `/etc/init/${config.name}.conf`;
        if (existsSync(upstartFilePath)) {
            console.error(`Service '${config.name}' already exists in '${upstartFilePath}'. Exiting.`);
            Deno.exit(1);
        }
        const upstartFileContent = this.generateConfig(config);
        if (onlyGenerate) {
            console.log("\nThis is a dry-run, nothing will be written to disk or installed.");
            console.log("\nPath: ", upstartFilePath);
            console.log("\nConfiguration:\n");
            console.log(upstartFileContent);
        } else {
            const tempFilePath = await Deno.makeTempFile();
            await Deno.writeTextFile(tempFilePath, upstartFileContent);
            console.log("\Service installer do not have (and should not have) root permissions, so the next steps have to be carried out manually.");
            console.log(`\nStep 1: The upstart configuration has been saved to a temporary file, copy this file to the correct location using the following command:`);
            console.log(`\n  sudo cp ${tempFilePath} ${upstartFilePath}`);
            console.log(`\nStep 2: Start the service now`);
            console.log(`\n  sudo start ${config.name}\n`);
        }
    }
    async uninstall(config) {
        const upstartFilePath = `/etc/init/${config.name}.conf`;
        if (!existsSync(upstartFilePath)) {
            console.error(`Service '${config.name}' does not exist. Exiting.`);
            Deno.exit(1);
        }
        try {
            await Deno.remove(upstartFilePath);
            console.log(`Service '${config.name}' uninstalled successfully.`);
            console.log("Please run the following command as root to stop the service (if it's running):");
            console.log(`sudo stop ${config.name}`);
        } catch (error) {
            console.error(`Failed to uninstall service: Could not remove '${upstartFilePath}'. Error:`, error.message);
        }
    }
}
const plistTemplate = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>Label</key>
    <string>{{name}}</string>
    <key>ProgramArguments</key>
    <array>
{{command}}    </array>
    <key>EnvironmentVariables</key>
    <dict>
      <key>PATH</key>
      <string>{{path}}</string>
{{extraEnvs}}    </dict>
    <key>WorkingDirectory</key>
    <string>{{workingDirectory}}</string>
    <key>KeepAlive</key>
    <true/>
  </dict>
</plist>
`;
class LaunchdService {
    generateConfig(options) {
        const denoPath = Deno.execPath();
        const commandArgs = options.cmd.split(" ");
        const servicePath = `${options.path?.join(":")}:${denoPath}:${options.home}/.deno/bin`;
        const workingDirectory = options.cwd ? options.cwd : Deno.cwd();
        let plistContent = plistTemplate.replace(/{{name}}/g, options.name);
        plistContent = plistContent.replace(/{{path}}/g, servicePath);
        plistContent = plistContent.replace(/{{workingDirectory}}/g, workingDirectory);
        let programArguments = "";
        for (const arg of commandArgs){
            programArguments += `      <string>${arg}</string>\n`;
        }
        plistContent = plistContent.replace("{{command}}", programArguments);
        if (options.env && options.env.length > 0) {
            let extraEnvs = "";
            for (const env of options.env){
                const envSplit = env.split("=");
                extraEnvs += `      <key>${envSplit[0]}</key>\n      <string>${envSplit[1]}</string>\n`;
            }
            plistContent = plistContent.replace("{{extraEnvs}}", extraEnvs);
        } else {
            plistContent = plistContent.replace("{{extraEnvs}}", "");
        }
        return plistContent;
    }
    async install(config, onlyGenerate) {
        const plistFileName = `${config.name}.plist`;
        const plistPathUser = `${config.home}/Library/LaunchAgents/${plistFileName}`;
        const plistPathSystem = `/Library/LaunchDaemons/${plistFileName}`;
        const plistPath = config.system ? plistPathSystem : plistPathUser;
        if (existsSync(plistPathUser) || existsSync(plistPathSystem)) {
            console.error(`Service '${config.name}' already exists. Exiting.`);
            Deno.exit(1);
        }
        const plistContent = this.generateConfig(config);
        if (onlyGenerate) {
            console.log("\nThis is a dry-run, nothing will be written to disk or installed.");
            console.log("\nPath: ", plistPath);
            console.log("\nConfiguration:\n");
            console.log(plistContent);
        } else {
            const plistDir = mod4.dirname(plistPath);
            await Deno.mkdir(plistDir, {
                recursive: true
            });
            await Deno.writeTextFile(plistPath, plistContent);
            console.log(`Service '${config.name}' installed at '${plistPath}'.`);
            if (config.system) {
                console.log("Please run the following command as root to load the service:");
                console.log(`sudo launchctl load ${plistPath}`);
            } else {
                console.log("Please run the following command to load the service:");
                console.log(`launchctl load ${plistPath}`);
            }
        }
    }
    async rollback(plistPath) {
        try {
            await Deno.remove(plistPath);
            console.log(`Changes rolled back: Removed '${plistPath}'.`);
        } catch (error) {
            console.error(`Failed to rollback changes: Could not remove '${plistPath}'. Error: ${error.message}`);
        }
    }
    async uninstall(config) {
        const plistFileName = `${config.name}.plist`;
        const plistPathUser = `${config.home}/Library/LaunchAgents/${plistFileName}`;
        const plistPathSystem = `/Library/LaunchDaemons/${plistFileName}`;
        const plistPath = config.system ? plistPathSystem : plistPathUser;
        if (!existsSync(plistPath)) {
            console.error(`Service '${config.name}' does not exist. Exiting.`);
            Deno.exit(1);
        }
        try {
            await Deno.remove(plistPath);
            console.log(`Service '${config.name}' uninstalled successfully.`);
            if (config.system) {
                console.log("Please run the following command as root to unload the service (if it's running):");
                console.log(`sudo launchctl unload ${plistPath}`);
            } else {
                console.log("Please run the following command to unload the service (if it's running):");
                console.log(`launchctl unload ${plistPath}`);
            }
        } catch (error) {
            console.error(`Failed to uninstall service: Could not remove '${plistPath}'. Error:`, error.message);
        }
    }
}
class WindowsService {
    constructor(){}
    async install(config, onlyGenerate) {
        const batchFileName = `${config.name}.bat`;
        const serviceBatchPath = `${config.home}/.service/${batchFileName}`;
        if (existsSync(serviceBatchPath)) {
            console.error(`Service '${config.name}' already exists in '${serviceBatchPath}'. Exiting.`);
            Deno.exit(1);
        }
        const batchFileContent = this.generateConfig(config);
        if (onlyGenerate) {
            console.log("\nThis is a dry-run, nothing will be written to disk or installed.");
            console.log("\nPath: ", serviceBatchPath);
            console.log("\nConfiguration:\n");
            console.log(batchFileContent);
        } else {
            const serviceDirectory = `${config.home}/.service/`;
            if (!existsSync(serviceDirectory)) {
                await Deno.mkdir(serviceDirectory, {
                    recursive: true
                });
            }
            await Deno.writeTextFile(serviceBatchPath, batchFileContent);
            const scArgs = `create ${config.name} binPath="cmd.exe /C ${serviceBatchPath}" start= auto DisplayName= "${config.name}" obj= LocalSystem`;
            const psArgs = [
                "-Command",
                "Start-Process",
                "sc.exe",
                "-ArgumentList",
                `'${scArgs}'`,
                "-Verb",
                "RunAs"
            ];
            const installServiceCommand = new Deno.Command("powershell.exe", {
                args: psArgs,
                stderr: "piped",
                stdout: "piped"
            });
            const installService = installServiceCommand.spawn();
            installService.ref();
            const installServiceOutput = await installService.output();
            const installServiceText = new TextDecoder().decode(installServiceOutput.stderr);
            if (!installServiceOutput.success) {
                await this.rollback(serviceBatchPath);
                throw new Error("Failed to install service. Error: \n" + installServiceText);
            }
            console.log(`Service '${config.name}' installed at '${serviceBatchPath}' and enabled.`);
        }
    }
    async uninstall(config) {
        const batchFileName = `${config.name}.bat`;
        const serviceBatchPath = `${config.home}/.service/${batchFileName}`;
        if (!existsSync(serviceBatchPath)) {
            console.error(`Service '${config.name}' does not exist. Exiting.`);
            Deno.exit(1);
        }
        const scArgs = `delete ${config.name}`;
        const psArgs = [
            "-Command",
            "Start-Process",
            "sc.exe",
            "-ArgumentList",
            `'${scArgs}'`,
            "-Verb",
            "RunAs"
        ];
        const uninstallServiceCommand = new Deno.Command("powershell.exe", {
            args: psArgs,
            stderr: "piped",
            stdout: "piped"
        });
        const uninstallService = uninstallServiceCommand.spawn();
        uninstallService.ref();
        const uninstallServiceOutput = await uninstallService.output();
        const uninstallServiceText = new TextDecoder().decode(uninstallServiceOutput.stderr);
        if (!uninstallServiceOutput.success) {
            await this.rollback(serviceBatchPath);
            throw new Error("Failed to uninstall service. Error: \n" + uninstallServiceText);
        }
        try {
            await Deno.remove(serviceBatchPath);
            console.log(`Service '${config.name}' uninstalled successfully.`);
        } catch (error) {
            console.error(`Failed to uninstall service: Could not remove '${serviceBatchPath}'. Error:`, error.message);
        }
    }
    generateConfig(options) {
        const denoPath = Deno.execPath();
        const defaultPath = `%PATH%;${denoPath};${options.home}\\.deno\\bin`;
        const envPath = options.path ? `${defaultPath};${options.path.join(";")}` : defaultPath;
        const workingDirectory = options.cwd ? options.cwd : Deno.cwd();
        let batchFileContent = `@echo off\n`;
        batchFileContent += `cd "${workingDirectory}"\n`;
        batchFileContent += `set "PATH=${envPath}"\n`;
        if (options.env && options.env.length > 0) {
            for (const env of options.env){
                batchFileContent += `set "${env}"\n`;
            }
        }
        batchFileContent += `"${denoPath}" run -A --allow-ffi --unstable https://deno.land/x/windows_service@1.0.11/run.ts --serviceName ${options.name} -- ${options.cmd}\n`;
        return batchFileContent;
    }
    async rollback(serviceBatchPath) {
        try {
            await Deno.remove(serviceBatchPath);
            console.log(`Changes rolled back: Removed '${serviceBatchPath}'.`);
        } catch (error) {
            console.error(`Failed to rollback changes: Could not remove '${serviceBatchPath}'. Error:`, error.message);
        }
    }
}
class ServiceManager {
    managers = new Map();
    register(initSystem, manager) {
        this.managers.set(initSystem, manager);
    }
    async installService(initSystem, options, onlyGenerate) {
        const manager = this.managers.get(initSystem);
        if (!manager) {
            throw new Error(`Unsupported init system: ${initSystem}`);
        }
        await manager.install(options, onlyGenerate);
    }
    async generateConfig(initSystem, options) {
        const manager = this.managers.get(initSystem);
        if (!manager) {
            throw new Error(`Unsupported init system: ${initSystem}`);
        }
        return await manager.generateConfig(options);
    }
    async uninstallService(initSystem, options) {
        const manager = this.managers.get(initSystem);
        if (!manager) {
            throw new Error(`Unsupported init system: ${initSystem}`);
        }
        await manager.uninstall(options);
    }
}
const serviceManager = new ServiceManager();
serviceManager.register("systemd", new SystemdService());
serviceManager.register("sysvinit", new InitService());
serviceManager.register("docker-init", new InitService());
serviceManager.register("upstart", new UpstartService());
serviceManager.register("launchd", new LaunchdService());
serviceManager.register("windows", new WindowsService());
const { Deno: Deno2 } = globalThis;
const noColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : true;
let enabled = !noColor;
function setColorEnabled(value1) {
    if (noColor) {
        return;
    }
    enabled = value1;
}
function getColorEnabled() {
    return enabled;
}
function code(open, close) {
    return {
        open: `\x1b[${open.join(";")}m`,
        close: `\x1b[${close}m`,
        regexp: new RegExp(`\\x1b\\[${close}m`, "g")
    };
}
function run(str, code) {
    return enabled ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;
}
function reset(str) {
    return run(str, code([
        0
    ], 0));
}
function bold(str) {
    return run(str, code([
        1
    ], 22));
}
function dim(str) {
    return run(str, code([
        2
    ], 22));
}
function italic(str) {
    return run(str, code([
        3
    ], 23));
}
function underline(str) {
    return run(str, code([
        4
    ], 24));
}
function inverse(str) {
    return run(str, code([
        7
    ], 27));
}
function hidden(str) {
    return run(str, code([
        8
    ], 28));
}
function strikethrough(str) {
    return run(str, code([
        9
    ], 29));
}
function black(str) {
    return run(str, code([
        30
    ], 39));
}
function red(str) {
    return run(str, code([
        31
    ], 39));
}
function green(str) {
    return run(str, code([
        32
    ], 39));
}
function yellow(str) {
    return run(str, code([
        33
    ], 39));
}
function blue(str) {
    return run(str, code([
        34
    ], 39));
}
function magenta(str) {
    return run(str, code([
        35
    ], 39));
}
function cyan(str) {
    return run(str, code([
        36
    ], 39));
}
function white(str) {
    return run(str, code([
        37
    ], 39));
}
function gray(str) {
    return brightBlack(str);
}
function brightBlack(str) {
    return run(str, code([
        90
    ], 39));
}
function brightRed(str) {
    return run(str, code([
        91
    ], 39));
}
function brightGreen(str) {
    return run(str, code([
        92
    ], 39));
}
function brightYellow(str) {
    return run(str, code([
        93
    ], 39));
}
function brightBlue(str) {
    return run(str, code([
        94
    ], 39));
}
function brightMagenta(str) {
    return run(str, code([
        95
    ], 39));
}
function brightCyan(str) {
    return run(str, code([
        96
    ], 39));
}
function brightWhite(str) {
    return run(str, code([
        97
    ], 39));
}
function bgBlack(str) {
    return run(str, code([
        40
    ], 49));
}
function bgRed(str) {
    return run(str, code([
        41
    ], 49));
}
function bgGreen(str) {
    return run(str, code([
        42
    ], 49));
}
function bgYellow(str) {
    return run(str, code([
        43
    ], 49));
}
function bgBlue(str) {
    return run(str, code([
        44
    ], 49));
}
function bgMagenta(str) {
    return run(str, code([
        45
    ], 49));
}
function bgCyan(str) {
    return run(str, code([
        46
    ], 49));
}
function bgWhite(str) {
    return run(str, code([
        47
    ], 49));
}
function bgBrightBlack(str) {
    return run(str, code([
        100
    ], 49));
}
function bgBrightRed(str) {
    return run(str, code([
        101
    ], 49));
}
function bgBrightGreen(str) {
    return run(str, code([
        102
    ], 49));
}
function bgBrightYellow(str) {
    return run(str, code([
        103
    ], 49));
}
function bgBrightBlue(str) {
    return run(str, code([
        104
    ], 49));
}
function bgBrightMagenta(str) {
    return run(str, code([
        105
    ], 49));
}
function bgBrightCyan(str) {
    return run(str, code([
        106
    ], 49));
}
function bgBrightWhite(str) {
    return run(str, code([
        107
    ], 49));
}
function clampAndTruncate(n, max = 255, min = 0) {
    return Math.trunc(Math.max(Math.min(n, max), min));
}
function rgb8(str, color) {
    return run(str, code([
        38,
        5,
        clampAndTruncate(color)
    ], 39));
}
function bgRgb8(str, color) {
    return run(str, code([
        48,
        5,
        clampAndTruncate(color)
    ], 49));
}
function rgb24(str, color) {
    if (typeof color === "number") {
        return run(str, code([
            38,
            2,
            color >> 16 & 0xff,
            color >> 8 & 0xff,
            color & 0xff
        ], 39));
    }
    return run(str, code([
        38,
        2,
        clampAndTruncate(color.r),
        clampAndTruncate(color.g),
        clampAndTruncate(color.b)
    ], 39));
}
function bgRgb24(str, color) {
    if (typeof color === "number") {
        return run(str, code([
            48,
            2,
            color >> 16 & 0xff,
            color >> 8 & 0xff,
            color & 0xff
        ], 49));
    }
    return run(str, code([
        48,
        2,
        clampAndTruncate(color.r),
        clampAndTruncate(color.g),
        clampAndTruncate(color.b)
    ], 49));
}
const ANSI_PATTERN = new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");
function stripColor(string) {
    return string.replace(ANSI_PATTERN, "");
}
const mod5 = {
    setColorEnabled: setColorEnabled,
    getColorEnabled: getColorEnabled,
    reset: reset,
    bold: bold,
    dim: dim,
    italic: italic,
    underline: underline,
    inverse: inverse,
    hidden: hidden,
    strikethrough: strikethrough,
    black: black,
    red: red,
    green: green,
    yellow: yellow,
    blue: blue,
    magenta: magenta,
    cyan: cyan,
    white: white,
    gray: gray,
    brightBlack: brightBlack,
    brightRed: brightRed,
    brightGreen: brightGreen,
    brightYellow: brightYellow,
    brightBlue: brightBlue,
    brightMagenta: brightMagenta,
    brightCyan: brightCyan,
    brightWhite: brightWhite,
    bgBlack: bgBlack,
    bgRed: bgRed,
    bgGreen: bgGreen,
    bgYellow: bgYellow,
    bgBlue: bgBlue,
    bgMagenta: bgMagenta,
    bgCyan: bgCyan,
    bgWhite: bgWhite,
    bgBrightBlack: bgBrightBlack,
    bgBrightRed: bgBrightRed,
    bgBrightGreen: bgBrightGreen,
    bgBrightYellow: bgBrightYellow,
    bgBrightBlue: bgBrightBlue,
    bgBrightMagenta: bgBrightMagenta,
    bgBrightCyan: bgBrightCyan,
    bgBrightWhite: bgBrightWhite,
    rgb8: rgb8,
    bgRgb8: bgRgb8,
    rgb24: rgb24,
    bgRgb24: bgRgb24,
    stripColor: stripColor
};
const osType2 = (()=>{
    const { Deno: Deno1 } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator: navigator1 } = globalThis;
    if (navigator1?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows2 = osType2 === "windows";
const CHAR_FORWARD_SLASH2 = 47;
function assertPath2(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator2(code) {
    return code === 47;
}
function isPathSeparator2(code) {
    return isPosixPathSeparator2(code) || code === 92;
}
function isWindowsDeviceRoot2(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString2(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH2;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format2(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (base === sep) return dir;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS2 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace2(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS2[c] ?? c;
    });
}
function lastPathSegment2(path, isSep, start = 0) {
    let matchedNonSeparator = false;
    let end = path.length;
    for(let i = path.length - 1; i >= start; --i){
        if (isSep(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                start = i + 1;
                break;
            }
        } else if (!matchedNonSeparator) {
            matchedNonSeparator = true;
            end = i + 1;
        }
    }
    return path.slice(start, end);
}
function stripTrailingSeparators2(segment, isSep) {
    if (segment.length <= 1) {
        return segment;
    }
    let end = segment.length;
    for(let i = segment.length - 1; i > 0; i--){
        if (isSep(segment.charCodeAt(i))) {
            end = i;
        } else {
            break;
        }
    }
    return segment.slice(0, end);
}
function stripSuffix2(name, suffix) {
    if (suffix.length >= name.length) {
        return name;
    }
    const lenDiff = name.length - suffix.length;
    for(let i = suffix.length - 1; i >= 0; --i){
        if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
            return name;
        }
    }
    return name.slice(0, -suffix.length);
}
class DenoStdInternalError1 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert2(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError1(msg);
    }
}
const sep4 = "\\";
const delimiter6 = ";";
function resolve6(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1 } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath2(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator2(code)) {
                isAbsolute = true;
                if (isPathSeparator2(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator2(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot2(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator2(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator2(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString2(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator2);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize8(path) {
    assertPath2(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code)) {
            isAbsolute = true;
            if (isPathSeparator2(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot2(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator2(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator2(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString2(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator2);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator2(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute6(path) {
    assertPath2(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator2(code)) {
        return true;
    } else if (isWindowsDeviceRoot2(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator2(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join8(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath2(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert2(firstPart != null);
    if (isPathSeparator2(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator2(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator2(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator2(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize8(joined);
}
function relative6(from, to) {
    assertPath2(from);
    assertPath2(to);
    if (from === to) return "";
    const fromOrig = resolve6(from);
    const toOrig = resolve6(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath6(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve6(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot2(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname6(path) {
    assertPath2(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator2(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot2(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator2(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator2(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator2(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return stripTrailingSeparators2(path.slice(0, end), isPosixPathSeparator2);
}
function basename6(path, suffix = "") {
    assertPath2(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    let start = 0;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot2(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    const lastSegment = lastPathSegment2(path, isPathSeparator2, start);
    const strippedSegment = stripTrailingSeparators2(lastSegment, isPathSeparator2);
    return suffix ? stripSuffix2(strippedSegment, suffix) : strippedSegment;
}
function extname6(path) {
    assertPath2(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot2(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator2(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format6(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format2("\\", pathObject);
}
function parse6(path) {
    assertPath2(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code)) {
            rootEnd = 1;
            if (isPathSeparator2(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot2(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator2(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            ret.base = "\\";
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator2(code)) {
        ret.root = ret.dir = path;
        ret.base = "\\";
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator2(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    ret.base = ret.base || "\\";
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl6(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl6(path) {
    if (!isAbsolute6(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace2(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod6 = {
    sep: sep4,
    delimiter: delimiter6,
    resolve: resolve6,
    normalize: normalize8,
    isAbsolute: isAbsolute6,
    join: join8,
    relative: relative6,
    toNamespacedPath: toNamespacedPath6,
    dirname: dirname6,
    basename: basename6,
    extname: extname6,
    format: format6,
    parse: parse6,
    fromFileUrl: fromFileUrl6,
    toFileUrl: toFileUrl6
};
const sep5 = "/";
const delimiter7 = ":";
function resolve7(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1 } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath2(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = isPosixPathSeparator2(path.charCodeAt(0));
    }
    resolvedPath = normalizeString2(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator2);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize9(path) {
    assertPath2(path);
    if (path.length === 0) return ".";
    const isAbsolute = isPosixPathSeparator2(path.charCodeAt(0));
    const trailingSeparator = isPosixPathSeparator2(path.charCodeAt(path.length - 1));
    path = normalizeString2(path, !isAbsolute, "/", isPosixPathSeparator2);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute7(path) {
    assertPath2(path);
    return path.length > 0 && isPosixPathSeparator2(path.charCodeAt(0));
}
function join9(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath2(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize9(joined);
}
function relative7(from, to) {
    assertPath2(from);
    assertPath2(to);
    if (from === to) return "";
    from = resolve7(from);
    to = resolve7(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (!isPosixPathSeparator2(from.charCodeAt(fromStart))) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (!isPosixPathSeparator2(to.charCodeAt(toStart))) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (isPosixPathSeparator2(to.charCodeAt(toStart + i))) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (isPosixPathSeparator2(from.charCodeAt(fromStart + i))) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (isPosixPathSeparator2(fromCode)) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || isPosixPathSeparator2(from.charCodeAt(i))) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (isPosixPathSeparator2(to.charCodeAt(toStart))) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath7(path) {
    return path;
}
function dirname7(path) {
    if (path.length === 0) return ".";
    let end = -1;
    let matchedNonSeparator = false;
    for(let i = path.length - 1; i >= 1; --i){
        if (isPosixPathSeparator2(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                end = i;
                break;
            }
        } else {
            matchedNonSeparator = true;
        }
    }
    if (end === -1) {
        return isPosixPathSeparator2(path.charCodeAt(0)) ? "/" : ".";
    }
    return stripTrailingSeparators2(path.slice(0, end), isPosixPathSeparator2);
}
function basename7(path, suffix = "") {
    assertPath2(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    const lastSegment = lastPathSegment2(path, isPosixPathSeparator2);
    const strippedSegment = stripTrailingSeparators2(lastSegment, isPosixPathSeparator2);
    return suffix ? stripSuffix2(strippedSegment, suffix) : strippedSegment;
}
function extname7(path) {
    assertPath2(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator2(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format7(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format2("/", pathObject);
}
function parse7(path) {
    assertPath2(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = isPosixPathSeparator2(path.charCodeAt(0));
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator2(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        ret.base = ret.base || "/";
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) {
        ret.dir = stripTrailingSeparators2(path.slice(0, startPart - 1), isPosixPathSeparator2);
    } else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl7(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl7(path) {
    if (!isAbsolute7(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace2(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod7 = {
    sep: sep5,
    delimiter: delimiter7,
    resolve: resolve7,
    normalize: normalize9,
    isAbsolute: isAbsolute7,
    join: join9,
    relative: relative7,
    toNamespacedPath: toNamespacedPath7,
    dirname: dirname7,
    basename: basename7,
    extname: extname7,
    format: format7,
    parse: parse7,
    fromFileUrl: fromFileUrl7,
    toFileUrl: toFileUrl7
};
const SEP1 = isWindows2 ? "\\" : "/";
const SEP_PATTERN1 = isWindows2 ? /[\\/]+/ : /\/+/;
function common1(paths, sep = SEP1) {
    const [first = "", ...remaining] = paths;
    if (first === "" || remaining.length === 0) {
        return first.substring(0, first.lastIndexOf(sep) + 1);
    }
    const parts = first.split(sep);
    let endOfPrefix = parts.length;
    for (const path of remaining){
        const compare = path.split(sep);
        for(let i = 0; i < endOfPrefix; i++){
            if (compare[i] !== parts[i]) {
                endOfPrefix = i;
            }
        }
        if (endOfPrefix === 0) {
            return "";
        }
    }
    const prefix = parts.slice(0, endOfPrefix).join(sep);
    return prefix.endsWith(sep) ? prefix : `${prefix}${sep}`;
}
const path4 = isWindows2 ? mod6 : mod7;
const { join: join10, normalize: normalize10 } = path4;
const regExpEscapeChars1 = [
    "!",
    "$",
    "(",
    ")",
    "*",
    "+",
    ".",
    "=",
    "?",
    "[",
    "\\",
    "^",
    "{",
    "|"
];
const rangeEscapeChars1 = [
    "-",
    "\\",
    "]"
];
function globToRegExp1(glob, { extended = true, globstar: globstarOption = true, os = osType2, caseInsensitive = false } = {}) {
    if (glob == "") {
        return /(?!)/;
    }
    const sep = os == "windows" ? "(?:\\\\|/)+" : "/+";
    const sepMaybe = os == "windows" ? "(?:\\\\|/)*" : "/*";
    const seps = os == "windows" ? [
        "\\",
        "/"
    ] : [
        "/"
    ];
    const globstar = os == "windows" ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*" : "(?:[^/]*(?:/|$)+)*";
    const wildcard = os == "windows" ? "[^\\\\/]*" : "[^/]*";
    const escapePrefix = os == "windows" ? "`" : "\\";
    let newLength = glob.length;
    for(; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--);
    glob = glob.slice(0, newLength);
    let regExpString = "";
    for(let j = 0; j < glob.length;){
        let segment = "";
        const groupStack = [];
        let inRange = false;
        let inEscape = false;
        let endsWithSep = false;
        let i = j;
        for(; i < glob.length && !seps.includes(glob[i]); i++){
            if (inEscape) {
                inEscape = false;
                const escapeChars = inRange ? rangeEscapeChars1 : regExpEscapeChars1;
                segment += escapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
                continue;
            }
            if (glob[i] == escapePrefix) {
                inEscape = true;
                continue;
            }
            if (glob[i] == "[") {
                if (!inRange) {
                    inRange = true;
                    segment += "[";
                    if (glob[i + 1] == "!") {
                        i++;
                        segment += "^";
                    } else if (glob[i + 1] == "^") {
                        i++;
                        segment += "\\^";
                    }
                    continue;
                } else if (glob[i + 1] == ":") {
                    let k = i + 1;
                    let value1 = "";
                    while(glob[k + 1] != null && glob[k + 1] != ":"){
                        value1 += glob[k + 1];
                        k++;
                    }
                    if (glob[k + 1] == ":" && glob[k + 2] == "]") {
                        i = k + 2;
                        if (value1 == "alnum") segment += "\\dA-Za-z";
                        else if (value1 == "alpha") segment += "A-Za-z";
                        else if (value1 == "ascii") segment += "\x00-\x7F";
                        else if (value1 == "blank") segment += "\t ";
                        else if (value1 == "cntrl") segment += "\x00-\x1F\x7F";
                        else if (value1 == "digit") segment += "\\d";
                        else if (value1 == "graph") segment += "\x21-\x7E";
                        else if (value1 == "lower") segment += "a-z";
                        else if (value1 == "print") segment += "\x20-\x7E";
                        else if (value1 == "punct") {
                            segment += "!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_‘{|}~";
                        } else if (value1 == "space") segment += "\\s\v";
                        else if (value1 == "upper") segment += "A-Z";
                        else if (value1 == "word") segment += "\\w";
                        else if (value1 == "xdigit") segment += "\\dA-Fa-f";
                        continue;
                    }
                }
            }
            if (glob[i] == "]" && inRange) {
                inRange = false;
                segment += "]";
                continue;
            }
            if (inRange) {
                if (glob[i] == "\\") {
                    segment += `\\\\`;
                } else {
                    segment += glob[i];
                }
                continue;
            }
            if (glob[i] == ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += ")";
                const type = groupStack.pop();
                if (type == "!") {
                    segment += wildcard;
                } else if (type != "@") {
                    segment += type;
                }
                continue;
            }
            if (glob[i] == "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i] == "+" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("+");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "@" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("@");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "?") {
                if (extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("?");
                    segment += "(?:";
                } else {
                    segment += ".";
                }
                continue;
            }
            if (glob[i] == "!" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("!");
                segment += "(?!";
                continue;
            }
            if (glob[i] == "{") {
                groupStack.push("BRACE");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
                groupStack.pop();
                segment += ")";
                continue;
            }
            if (glob[i] == "," && groupStack[groupStack.length - 1] == "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i] == "*") {
                if (extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("*");
                    segment += "(?:";
                } else {
                    const prevChar = glob[i - 1];
                    let numStars = 1;
                    while(glob[i + 1] == "*"){
                        i++;
                        numStars++;
                    }
                    const nextChar = glob[i + 1];
                    if (globstarOption && numStars == 2 && [
                        ...seps,
                        undefined
                    ].includes(prevChar) && [
                        ...seps,
                        undefined
                    ].includes(nextChar)) {
                        segment += globstar;
                        endsWithSep = true;
                    } else {
                        segment += wildcard;
                    }
                }
                continue;
            }
            segment += regExpEscapeChars1.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
        }
        if (groupStack.length > 0 || inRange || inEscape) {
            segment = "";
            for (const c of glob.slice(j, i)){
                segment += regExpEscapeChars1.includes(c) ? `\\${c}` : c;
                endsWithSep = false;
            }
        }
        regExpString += segment;
        if (!endsWithSep) {
            regExpString += i < glob.length ? sep : sepMaybe;
            endsWithSep = true;
        }
        while(seps.includes(glob[i]))i++;
        if (!(i > j)) {
            throw new Error("Assertion failure: i > j (potential infinite loop)");
        }
        j = i;
    }
    regExpString = `^${regExpString}$`;
    return new RegExp(regExpString, caseInsensitive ? "i" : "");
}
function isGlob1(str) {
    const chars = {
        "{": "}",
        "(": ")",
        "[": "]"
    };
    const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
    if (str === "") {
        return false;
    }
    let match;
    while(match = regex.exec(str)){
        if (match[2]) return true;
        let idx = match.index + match[0].length;
        const open = match[1];
        const close = open ? chars[open] : null;
        if (open && close) {
            const n = str.indexOf(close, idx);
            if (n !== -1) {
                idx = n + 1;
            }
        }
        str = str.slice(idx);
    }
    return false;
}
function normalizeGlob1(glob, { globstar = false } = {}) {
    if (glob.match(/\0/g)) {
        throw new Error(`Glob contains invalid characters: "${glob}"`);
    }
    if (!globstar) {
        return normalize10(glob);
    }
    const s = SEP_PATTERN1.source;
    const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
    return normalize10(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}
function joinGlobs1(globs, { extended = true, globstar = false } = {}) {
    if (!globstar || globs.length == 0) {
        return join10(...globs);
    }
    if (globs.length === 0) return ".";
    let joined;
    for (const glob of globs){
        const path = glob;
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `${SEP1}${path}`;
        }
    }
    if (!joined) return ".";
    return normalizeGlob1(joined, {
        extended,
        globstar
    });
}
const path5 = isWindows2 ? mod6 : mod7;
const { basename: basename8, delimiter: delimiter8, dirname: dirname8, extname: extname8, format: format8, fromFileUrl: fromFileUrl8, isAbsolute: isAbsolute8, join: join11, normalize: normalize11, parse: parse8, relative: relative8, resolve: resolve8, sep: sep6, toFileUrl: toFileUrl8, toNamespacedPath: toNamespacedPath8 } = path5;
const mod8 = {
    SEP: SEP1,
    SEP_PATTERN: SEP_PATTERN1,
    win32: mod6,
    posix: mod7,
    basename: basename8,
    delimiter: delimiter8,
    dirname: dirname8,
    extname: extname8,
    format: format8,
    fromFileUrl: fromFileUrl8,
    isAbsolute: isAbsolute8,
    join: join11,
    normalize: normalize11,
    parse: parse8,
    relative: relative8,
    resolve: resolve8,
    sep: sep6,
    toFileUrl: toFileUrl8,
    toNamespacedPath: toNamespacedPath8,
    common: common1,
    globToRegExp: globToRegExp1,
    isGlob: isGlob1,
    normalizeGlob: normalizeGlob1,
    joinGlobs: joinGlobs1
};
function isSubdir(src, dest, sep = sep6) {
    if (src === dest) {
        return false;
    }
    src = toPathString(src);
    const srcArray = src.split(sep);
    dest = toPathString(dest);
    const destArray = dest.split(sep);
    return srcArray.every((current, i)=>destArray[i] === current);
}
function getFileInfoType(fileInfo) {
    return fileInfo.isFile ? "file" : fileInfo.isDirectory ? "dir" : fileInfo.isSymlink ? "symlink" : undefined;
}
function createWalkEntrySync(path) {
    path = toPathString(path);
    path = normalize11(path);
    const name = basename8(path);
    const info = Deno.statSync(path);
    return {
        path,
        name,
        isFile: info.isFile,
        isDirectory: info.isDirectory,
        isSymlink: info.isSymlink
    };
}
async function createWalkEntry(path) {
    path = toPathString(path);
    path = normalize11(path);
    const name = basename8(path);
    const info = await Deno.stat(path);
    return {
        path,
        name,
        isFile: info.isFile,
        isDirectory: info.isDirectory,
        isSymlink: info.isSymlink
    };
}
function toPathString(path) {
    return path instanceof URL ? fromFileUrl8(path) : path;
}
async function emptyDir(dir) {
    try {
        const items = [];
        for await (const dirEntry of Deno.readDir(dir)){
            items.push(dirEntry);
        }
        while(items.length){
            const item = items.shift();
            if (item && item.name) {
                const filepath = join11(toPathString(dir), item.name);
                await Deno.remove(filepath, {
                    recursive: true
                });
            }
        }
    } catch (err) {
        if (!(err instanceof Deno.errors.NotFound)) {
            throw err;
        }
        await Deno.mkdir(dir, {
            recursive: true
        });
    }
}
function emptyDirSync(dir) {
    try {
        const items = [
            ...Deno.readDirSync(dir)
        ];
        while(items.length){
            const item = items.shift();
            if (item && item.name) {
                const filepath = join11(toPathString(dir), item.name);
                Deno.removeSync(filepath, {
                    recursive: true
                });
            }
        }
    } catch (err) {
        if (!(err instanceof Deno.errors.NotFound)) {
            throw err;
        }
        Deno.mkdirSync(dir, {
            recursive: true
        });
    }
}
async function ensureDir(dir) {
    try {
        await Deno.mkdir(dir, {
            recursive: true
        });
    } catch (err) {
        if (!(err instanceof Deno.errors.AlreadyExists)) {
            throw err;
        }
        const fileInfo = await Deno.lstat(dir);
        if (!fileInfo.isDirectory) {
            throw new Error(`Ensure path exists, expected 'dir', got '${getFileInfoType(fileInfo)}'`);
        }
    }
}
function ensureDirSync(dir) {
    try {
        Deno.mkdirSync(dir, {
            recursive: true
        });
    } catch (err) {
        if (!(err instanceof Deno.errors.AlreadyExists)) {
            throw err;
        }
        const fileInfo = Deno.lstatSync(dir);
        if (!fileInfo.isDirectory) {
            throw new Error(`Ensure path exists, expected 'dir', got '${getFileInfoType(fileInfo)}'`);
        }
    }
}
async function ensureFile(filePath) {
    try {
        const stat = await Deno.lstat(filePath);
        if (!stat.isFile) {
            throw new Error(`Ensure path exists, expected 'file', got '${getFileInfoType(stat)}'`);
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            await ensureDir(dirname8(toPathString(filePath)));
            await Deno.writeFile(filePath, new Uint8Array());
            return;
        }
        throw err;
    }
}
function ensureFileSync(filePath) {
    try {
        const stat = Deno.lstatSync(filePath);
        if (!stat.isFile) {
            throw new Error(`Ensure path exists, expected 'file', got '${getFileInfoType(stat)}'`);
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            ensureDirSync(dirname8(toPathString(filePath)));
            Deno.writeFileSync(filePath, new Uint8Array());
            return;
        }
        throw err;
    }
}
async function ensureLink(src, dest) {
    dest = toPathString(dest);
    await ensureDir(dirname8(dest));
    await Deno.link(toPathString(src), dest);
}
function ensureLinkSync(src, dest) {
    dest = toPathString(dest);
    ensureDirSync(dirname8(dest));
    Deno.linkSync(toPathString(src), dest);
}
function resolveSymlinkTarget(target, linkName) {
    if (typeof target != "string") return target;
    if (typeof linkName == "string") {
        return resolve8(dirname8(linkName), target);
    } else {
        return new URL(target, linkName);
    }
}
async function ensureSymlink(target, linkName) {
    const targetRealPath = resolveSymlinkTarget(target, linkName);
    const srcStatInfo = await Deno.lstat(targetRealPath);
    const srcFilePathType = getFileInfoType(srcStatInfo);
    await ensureDir(dirname8(toPathString(linkName)));
    const options = isWindows2 ? {
        type: srcFilePathType === "dir" ? "dir" : "file"
    } : undefined;
    try {
        await Deno.symlink(target, linkName, options);
    } catch (error) {
        if (!(error instanceof Deno.errors.AlreadyExists)) {
            throw error;
        }
    }
}
function ensureSymlinkSync(target, linkName) {
    const targetRealPath = resolveSymlinkTarget(target, linkName);
    const srcStatInfo = Deno.lstatSync(targetRealPath);
    const srcFilePathType = getFileInfoType(srcStatInfo);
    ensureDirSync(dirname8(toPathString(linkName)));
    const options = isWindows2 ? {
        type: srcFilePathType === "dir" ? "dir" : "file"
    } : undefined;
    try {
        Deno.symlinkSync(target, linkName, options);
    } catch (error) {
        if (!(error instanceof Deno.errors.AlreadyExists)) {
            throw error;
        }
    }
}
async function exists(path, options) {
    try {
        const stat = await Deno.stat(path);
        if (options && (options.isReadable || options.isDirectory || options.isFile)) {
            if (options.isDirectory && options.isFile) {
                throw new TypeError("ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together.");
            }
            if (options.isDirectory && !stat.isDirectory || options.isFile && !stat.isFile) {
                return false;
            }
            if (options.isReadable) {
                if (stat.mode == null) {
                    return true;
                }
                if (Deno.uid() == stat.uid) {
                    return (stat.mode & 0o400) == 0o400;
                } else if (Deno.gid() == stat.gid) {
                    return (stat.mode & 0o040) == 0o040;
                }
                return (stat.mode & 0o004) == 0o004;
            }
        }
        return true;
    } catch (error) {
        if (error instanceof Deno.errors.NotFound) {
            return false;
        }
        if (error instanceof Deno.errors.PermissionDenied) {
            if ((await Deno.permissions.query({
                name: "read",
                path
            })).state === "granted") {
                return !options?.isReadable;
            }
        }
        throw error;
    }
}
function existsSync1(path, options) {
    try {
        const stat = Deno.statSync(path);
        if (options && (options.isReadable || options.isDirectory || options.isFile)) {
            if (options.isDirectory && options.isFile) {
                throw new TypeError("ExistsOptions.options.isDirectory and ExistsOptions.options.isFile must not be true together.");
            }
            if (options.isDirectory && !stat.isDirectory || options.isFile && !stat.isFile) {
                return false;
            }
            if (options.isReadable) {
                if (stat.mode == null) {
                    return true;
                }
                if (Deno.uid() == stat.uid) {
                    return (stat.mode & 0o400) == 0o400;
                } else if (Deno.gid() == stat.gid) {
                    return (stat.mode & 0o040) == 0o040;
                }
                return (stat.mode & 0o004) == 0o004;
            }
        }
        return true;
    } catch (error) {
        if (error instanceof Deno.errors.NotFound) {
            return false;
        }
        if (error instanceof Deno.errors.PermissionDenied) {
            if (Deno.permissions.querySync({
                name: "read",
                path
            }).state === "granted") {
                return !options?.isReadable;
            }
        }
        throw error;
    }
}
class WalkError extends Error {
    cause;
    name = "WalkError";
    path;
    constructor(cause, path){
        super(`${cause instanceof Error ? cause.message : cause} for path "${path}"`);
        this.path = path;
        this.cause = cause;
    }
}
function include(path, exts, match, skip) {
    if (exts && !exts.some((ext)=>path.endsWith(ext))) {
        return false;
    }
    if (match && !match.some((pattern)=>!!path.match(pattern))) {
        return false;
    }
    if (skip && skip.some((pattern)=>!!path.match(pattern))) {
        return false;
    }
    return true;
}
function wrapErrorWithPath(err, root) {
    if (err instanceof WalkError) return err;
    return new WalkError(err, root);
}
async function* walk(root, { maxDepth = Infinity, includeFiles = true, includeDirs = true, followSymlinks = false, exts = undefined, match = undefined, skip = undefined } = {}) {
    if (maxDepth < 0) {
        return;
    }
    root = toPathString(root);
    if (includeDirs && include(root, exts, match, skip)) {
        yield await createWalkEntry(root);
    }
    if (maxDepth < 1 || !include(root, undefined, undefined, skip)) {
        return;
    }
    try {
        for await (const entry of Deno.readDir(root)){
            assert2(entry.name != null);
            let path = join11(root, entry.name);
            let { isSymlink, isDirectory } = entry;
            if (isSymlink) {
                if (!followSymlinks) continue;
                path = await Deno.realPath(path);
                ({ isSymlink, isDirectory } = await Deno.lstat(path));
            }
            if (isSymlink || isDirectory) {
                yield* walk(path, {
                    maxDepth: maxDepth - 1,
                    includeFiles,
                    includeDirs,
                    followSymlinks,
                    exts,
                    match,
                    skip
                });
            } else if (includeFiles && include(path, exts, match, skip)) {
                yield {
                    path,
                    ...entry
                };
            }
        }
    } catch (err) {
        throw wrapErrorWithPath(err, normalize11(root));
    }
}
function* walkSync(root, { maxDepth = Infinity, includeFiles = true, includeDirs = true, followSymlinks = false, exts = undefined, match = undefined, skip = undefined } = {}) {
    root = toPathString(root);
    if (maxDepth < 0) {
        return;
    }
    if (includeDirs && include(root, exts, match, skip)) {
        yield createWalkEntrySync(root);
    }
    if (maxDepth < 1 || !include(root, undefined, undefined, skip)) {
        return;
    }
    let entries;
    try {
        entries = Deno.readDirSync(root);
    } catch (err) {
        throw wrapErrorWithPath(err, normalize11(root));
    }
    for (const entry of entries){
        assert2(entry.name != null);
        let path = join11(root, entry.name);
        let { isSymlink, isDirectory } = entry;
        if (isSymlink) {
            if (!followSymlinks) continue;
            path = Deno.realPathSync(path);
            ({ isSymlink, isDirectory } = Deno.lstatSync(path));
        }
        if (isSymlink || isDirectory) {
            yield* walkSync(path, {
                maxDepth: maxDepth - 1,
                includeFiles,
                includeDirs,
                followSymlinks,
                exts,
                match,
                skip
            });
        } else if (includeFiles && include(path, exts, match, skip)) {
            yield {
                path,
                ...entry
            };
        }
    }
}
function split(path) {
    const s = SEP_PATTERN1.source;
    const segments = path.replace(new RegExp(`^${s}|${s}$`, "g"), "").split(SEP_PATTERN1);
    const isAbsolute_ = isAbsolute8(path);
    return {
        segments,
        isAbsolute: isAbsolute_,
        hasTrailingSep: !!path.match(new RegExp(`${s}$`)),
        winRoot: isWindows2 && isAbsolute_ ? segments.shift() : undefined
    };
}
function throwUnlessNotFound(error) {
    if (!(error instanceof Deno.errors.NotFound)) {
        throw error;
    }
}
function comparePath(a, b) {
    if (a.path < b.path) return -1;
    if (a.path > b.path) return 1;
    return 0;
}
async function* expandGlob(glob, { root = Deno.cwd(), exclude = [], includeDirs = true, extended = true, globstar = true, caseInsensitive, followSymlinks } = {}) {
    const globOptions = {
        extended,
        globstar,
        caseInsensitive
    };
    const absRoot = resolve8(root);
    const resolveFromRoot = (path)=>resolve8(absRoot, path);
    const excludePatterns = exclude.map(resolveFromRoot).map((s)=>globToRegExp1(s, globOptions));
    const shouldInclude = (path)=>!excludePatterns.some((p)=>!!path.match(p));
    const { segments, isAbsolute: isGlobAbsolute, hasTrailingSep, winRoot } = split(toPathString(glob));
    let fixedRoot = isGlobAbsolute ? winRoot != undefined ? winRoot : "/" : absRoot;
    while(segments.length > 0 && !isGlob1(segments[0])){
        const seg = segments.shift();
        assert2(seg != null);
        fixedRoot = joinGlobs1([
            fixedRoot,
            seg
        ], globOptions);
    }
    let fixedRootInfo;
    try {
        fixedRootInfo = await createWalkEntry(fixedRoot);
    } catch (error) {
        return throwUnlessNotFound(error);
    }
    async function* advanceMatch(walkInfo, globSegment) {
        if (!walkInfo.isDirectory) {
            return;
        } else if (globSegment == "..") {
            const parentPath = joinGlobs1([
                walkInfo.path,
                ".."
            ], globOptions);
            try {
                if (shouldInclude(parentPath)) {
                    return yield await createWalkEntry(parentPath);
                }
            } catch (error) {
                throwUnlessNotFound(error);
            }
            return;
        } else if (globSegment == "**") {
            return yield* walk(walkInfo.path, {
                skip: excludePatterns,
                maxDepth: globstar ? Infinity : 1,
                followSymlinks
            });
        }
        const globPattern = globToRegExp1(globSegment, globOptions);
        for await (const walkEntry of walk(walkInfo.path, {
            maxDepth: 1,
            skip: excludePatterns,
            followSymlinks
        })){
            if (walkEntry.path != walkInfo.path && walkEntry.name.match(globPattern)) {
                yield walkEntry;
            }
        }
    }
    let currentMatches = [
        fixedRootInfo
    ];
    for (const segment of segments){
        const nextMatchMap = new Map();
        await Promise.all(currentMatches.map(async (currentMatch)=>{
            for await (const nextMatch of advanceMatch(currentMatch, segment)){
                nextMatchMap.set(nextMatch.path, nextMatch);
            }
        }));
        currentMatches = [
            ...nextMatchMap.values()
        ].sort(comparePath);
    }
    if (hasTrailingSep) {
        currentMatches = currentMatches.filter((entry)=>entry.isDirectory);
    }
    if (!includeDirs) {
        currentMatches = currentMatches.filter((entry)=>!entry.isDirectory);
    }
    yield* currentMatches;
}
function* expandGlobSync(glob, { root = Deno.cwd(), exclude = [], includeDirs = true, extended = true, globstar = true, caseInsensitive, followSymlinks } = {}) {
    const globOptions = {
        extended,
        globstar,
        caseInsensitive
    };
    const absRoot = resolve8(root);
    const resolveFromRoot = (path)=>resolve8(absRoot, path);
    const excludePatterns = exclude.map(resolveFromRoot).map((s)=>globToRegExp1(s, globOptions));
    const shouldInclude = (path)=>!excludePatterns.some((p)=>!!path.match(p));
    const { segments, isAbsolute: isGlobAbsolute, hasTrailingSep, winRoot } = split(toPathString(glob));
    let fixedRoot = isGlobAbsolute ? winRoot != undefined ? winRoot : "/" : absRoot;
    while(segments.length > 0 && !isGlob1(segments[0])){
        const seg = segments.shift();
        assert2(seg != null);
        fixedRoot = joinGlobs1([
            fixedRoot,
            seg
        ], globOptions);
    }
    let fixedRootInfo;
    try {
        fixedRootInfo = createWalkEntrySync(fixedRoot);
    } catch (error) {
        return throwUnlessNotFound(error);
    }
    function* advanceMatch(walkInfo, globSegment) {
        if (!walkInfo.isDirectory) {
            return;
        } else if (globSegment == "..") {
            const parentPath = joinGlobs1([
                walkInfo.path,
                ".."
            ], globOptions);
            try {
                if (shouldInclude(parentPath)) {
                    return yield createWalkEntrySync(parentPath);
                }
            } catch (error) {
                throwUnlessNotFound(error);
            }
            return;
        } else if (globSegment == "**") {
            return yield* walkSync(walkInfo.path, {
                skip: excludePatterns,
                maxDepth: globstar ? Infinity : 1,
                followSymlinks
            });
        }
        const globPattern = globToRegExp1(globSegment, globOptions);
        for (const walkEntry of walkSync(walkInfo.path, {
            maxDepth: 1,
            skip: excludePatterns,
            followSymlinks
        })){
            if (walkEntry.path != walkInfo.path && walkEntry.name.match(globPattern)) {
                yield walkEntry;
            }
        }
    }
    let currentMatches = [
        fixedRootInfo
    ];
    for (const segment of segments){
        const nextMatchMap = new Map();
        for (const currentMatch of currentMatches){
            for (const nextMatch of advanceMatch(currentMatch, segment)){
                nextMatchMap.set(nextMatch.path, nextMatch);
            }
        }
        currentMatches = [
            ...nextMatchMap.values()
        ].sort(comparePath);
    }
    if (hasTrailingSep) {
        currentMatches = currentMatches.filter((entry)=>entry.isDirectory);
    }
    if (!includeDirs) {
        currentMatches = currentMatches.filter((entry)=>!entry.isDirectory);
    }
    yield* currentMatches;
}
const EXISTS_ERROR = new Deno.errors.AlreadyExists("dest already exists.");
async function move(src, dest, { overwrite = false } = {}) {
    const srcStat = await Deno.stat(src);
    if (srcStat.isDirectory && isSubdir(src, dest)) {
        throw new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    if (overwrite) {
        try {
            await Deno.remove(dest, {
                recursive: true
            });
        } catch (error) {
            if (!(error instanceof Deno.errors.NotFound)) {
                throw error;
            }
        }
    } else {
        try {
            await Deno.lstat(dest);
            return Promise.reject(EXISTS_ERROR);
        } catch  {}
    }
    await Deno.rename(src, dest);
}
function moveSync(src, dest, { overwrite = false } = {}) {
    const srcStat = Deno.statSync(src);
    if (srcStat.isDirectory && isSubdir(src, dest)) {
        throw new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    if (overwrite) {
        try {
            Deno.removeSync(dest, {
                recursive: true
            });
        } catch (error) {
            if (!(error instanceof Deno.errors.NotFound)) {
                throw error;
            }
        }
    } else {
        try {
            Deno.lstatSync(dest);
            throw EXISTS_ERROR;
        } catch (error) {
            if (error === EXISTS_ERROR) {
                throw error;
            }
        }
    }
    Deno.renameSync(src, dest);
}
async function ensureValidCopy(src, dest, options) {
    let destStat;
    try {
        destStat = await Deno.lstat(dest);
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return;
        }
        throw err;
    }
    if (options.isFolder && !destStat.isDirectory) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!options.overwrite) {
        throw new Deno.errors.AlreadyExists(`'${dest}' already exists.`);
    }
    return destStat;
}
function ensureValidCopySync(src, dest, options) {
    let destStat;
    try {
        destStat = Deno.lstatSync(dest);
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return;
        }
        throw err;
    }
    if (options.isFolder && !destStat.isDirectory) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!options.overwrite) {
        throw new Deno.errors.AlreadyExists(`'${dest}' already exists.`);
    }
    return destStat;
}
async function copyFile(src, dest, options) {
    await ensureValidCopy(src, dest, options);
    await Deno.copyFile(src, dest);
    if (options.preserveTimestamps) {
        const statInfo = await Deno.stat(src);
        assert2(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
        assert2(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
        await Deno.utime(dest, statInfo.atime, statInfo.mtime);
    }
}
function copyFileSync(src, dest, options) {
    ensureValidCopySync(src, dest, options);
    Deno.copyFileSync(src, dest);
    if (options.preserveTimestamps) {
        const statInfo = Deno.statSync(src);
        assert2(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
        assert2(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
        Deno.utimeSync(dest, statInfo.atime, statInfo.mtime);
    }
}
async function copySymLink(src, dest, options) {
    await ensureValidCopy(src, dest, options);
    const originSrcFilePath = await Deno.readLink(src);
    const type = getFileInfoType(await Deno.lstat(src));
    if (isWindows2) {
        await Deno.symlink(originSrcFilePath, dest, {
            type: type === "dir" ? "dir" : "file"
        });
    } else {
        await Deno.symlink(originSrcFilePath, dest);
    }
    if (options.preserveTimestamps) {
        const statInfo = await Deno.lstat(src);
        assert2(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
        assert2(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
        await Deno.utime(dest, statInfo.atime, statInfo.mtime);
    }
}
function copySymlinkSync(src, dest, options) {
    ensureValidCopySync(src, dest, options);
    const originSrcFilePath = Deno.readLinkSync(src);
    const type = getFileInfoType(Deno.lstatSync(src));
    if (isWindows2) {
        Deno.symlinkSync(originSrcFilePath, dest, {
            type: type === "dir" ? "dir" : "file"
        });
    } else {
        Deno.symlinkSync(originSrcFilePath, dest);
    }
    if (options.preserveTimestamps) {
        const statInfo = Deno.lstatSync(src);
        assert2(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
        assert2(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
        Deno.utimeSync(dest, statInfo.atime, statInfo.mtime);
    }
}
async function copyDir(src, dest, options) {
    const destStat = await ensureValidCopy(src, dest, {
        ...options,
        isFolder: true
    });
    if (!destStat) {
        await ensureDir(dest);
    }
    if (options.preserveTimestamps) {
        const srcStatInfo = await Deno.stat(src);
        assert2(srcStatInfo.atime instanceof Date, `statInfo.atime is unavailable`);
        assert2(srcStatInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
        await Deno.utime(dest, srcStatInfo.atime, srcStatInfo.mtime);
    }
    src = toPathString(src);
    dest = toPathString(dest);
    for await (const entry of Deno.readDir(src)){
        const srcPath = join11(src, entry.name);
        const destPath = join11(dest, basename8(srcPath));
        if (entry.isSymlink) {
            await copySymLink(srcPath, destPath, options);
        } else if (entry.isDirectory) {
            await copyDir(srcPath, destPath, options);
        } else if (entry.isFile) {
            await copyFile(srcPath, destPath, options);
        }
    }
}
function copyDirSync(src, dest, options) {
    const destStat = ensureValidCopySync(src, dest, {
        ...options,
        isFolder: true
    });
    if (!destStat) {
        ensureDirSync(dest);
    }
    if (options.preserveTimestamps) {
        const srcStatInfo = Deno.statSync(src);
        assert2(srcStatInfo.atime instanceof Date, `statInfo.atime is unavailable`);
        assert2(srcStatInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
        Deno.utimeSync(dest, srcStatInfo.atime, srcStatInfo.mtime);
    }
    src = toPathString(src);
    dest = toPathString(dest);
    for (const entry of Deno.readDirSync(src)){
        assert2(entry.name != null, "file.name must be set");
        const srcPath = join11(src, entry.name);
        const destPath = join11(dest, basename8(srcPath));
        if (entry.isSymlink) {
            copySymlinkSync(srcPath, destPath, options);
        } else if (entry.isDirectory) {
            copyDirSync(srcPath, destPath, options);
        } else if (entry.isFile) {
            copyFileSync(srcPath, destPath, options);
        }
    }
}
async function copy1(src, dest, options = {}) {
    src = resolve8(toPathString(src));
    dest = resolve8(toPathString(dest));
    if (src === dest) {
        throw new Error("Source and destination cannot be the same.");
    }
    const srcStat = await Deno.lstat(src);
    if (srcStat.isDirectory && isSubdir(src, dest)) {
        throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    if (srcStat.isSymlink) {
        await copySymLink(src, dest, options);
    } else if (srcStat.isDirectory) {
        await copyDir(src, dest, options);
    } else if (srcStat.isFile) {
        await copyFile(src, dest, options);
    }
}
function copySync(src, dest, options = {}) {
    src = resolve8(toPathString(src));
    dest = resolve8(toPathString(dest));
    if (src === dest) {
        throw new Error("Source and destination cannot be the same.");
    }
    const srcStat = Deno.lstatSync(src);
    if (srcStat.isDirectory && isSubdir(src, dest)) {
        throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    if (srcStat.isSymlink) {
        copySymlinkSync(src, dest, options);
    } else if (srcStat.isDirectory) {
        copyDirSync(src, dest, options);
    } else if (srcStat.isFile) {
        copyFileSync(src, dest, options);
    }
}
var EOL2;
(function(EOL) {
    EOL["LF"] = "\n";
    EOL["CRLF"] = "\r\n";
})(EOL2 || (EOL2 = {}));
const regDetect = /(?:\r?\n)/g;
function detect(content) {
    const d = content.match(regDetect);
    if (!d || d.length === 0) {
        return null;
    }
    const hasCRLF = d.some((x)=>x === EOL2.CRLF);
    return hasCRLF ? EOL2.CRLF : EOL2.LF;
}
function format9(content, eol) {
    return content.replace(regDetect, eol);
}
const mod9 = {
    emptyDir,
    emptyDirSync,
    ensureDir,
    ensureDirSync,
    ensureFile,
    ensureFileSync,
    ensureLink,
    ensureLinkSync,
    ensureSymlink,
    ensureSymlinkSync,
    exists,
    existsSync: existsSync1,
    expandGlob,
    expandGlobSync,
    WalkError,
    walk,
    walkSync,
    move,
    moveSync,
    copy: copy1,
    copySync,
    EOL: EOL2,
    detect,
    format: format9
};
function copy2(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_READ = 32 * 1024;
const MAX_SIZE1 = 2 ** 32 - 2;
class Buffer1 {
    #buf;
    #off = 0;
    constructor(ab){
        this.#buf = ab === undefined ? new Uint8Array(0) : new Uint8Array(ab);
    }
    bytes(options = {
        copy: true
    }) {
        if (options.copy === false) return this.#buf.subarray(this.#off);
        return this.#buf.slice(this.#off);
    }
    empty() {
        return this.#buf.byteLength <= this.#off;
    }
    get length() {
        return this.#buf.byteLength - this.#off;
    }
    get capacity() {
        return this.#buf.buffer.byteLength;
    }
    truncate(n) {
        if (n === 0) {
            this.reset();
            return;
        }
        if (n < 0 || n > this.length) {
            throw Error("bytes.Buffer: truncation out of range");
        }
        this.#reslice(this.#off + n);
    }
    reset() {
        this.#reslice(0);
        this.#off = 0;
    }
    #tryGrowByReslice(n) {
        const l = this.#buf.byteLength;
        if (n <= this.capacity - l) {
            this.#reslice(l + n);
            return l;
        }
        return -1;
    }
    #reslice(len) {
        assert2(len <= this.#buf.buffer.byteLength);
        this.#buf = new Uint8Array(this.#buf.buffer, 0, len);
    }
    readSync(p) {
        if (this.empty()) {
            this.reset();
            if (p.byteLength === 0) {
                return 0;
            }
            return null;
        }
        const nread = copy2(this.#buf.subarray(this.#off), p);
        this.#off += nread;
        return nread;
    }
    read(p) {
        const rr = this.readSync(p);
        return Promise.resolve(rr);
    }
    writeSync(p) {
        const m = this.#grow(p.byteLength);
        return copy2(p, this.#buf, m);
    }
    write(p) {
        const n = this.writeSync(p);
        return Promise.resolve(n);
    }
    #grow(n) {
        const m = this.length;
        if (m === 0 && this.#off !== 0) {
            this.reset();
        }
        const i = this.#tryGrowByReslice(n);
        if (i >= 0) {
            return i;
        }
        const c = this.capacity;
        if (n <= Math.floor(c / 2) - m) {
            copy2(this.#buf.subarray(this.#off), this.#buf);
        } else if (c + n > MAX_SIZE1) {
            throw new Error("The buffer cannot be grown beyond the maximum size.");
        } else {
            const buf = new Uint8Array(Math.min(2 * c + n, MAX_SIZE1));
            copy2(this.#buf.subarray(this.#off), buf);
            this.#buf = buf;
        }
        this.#off = 0;
        this.#reslice(Math.min(m + n, MAX_SIZE1));
        return m;
    }
    grow(n) {
        if (n < 0) {
            throw Error("Buffer.grow: negative count");
        }
        const m = this.#grow(n);
        this.#reslice(m);
    }
    async readFrom(r) {
        let n = 0;
        const tmp = new Uint8Array(MIN_READ);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = await r.read(buf);
            if (nread === null) {
                return n;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n += nread;
        }
    }
    readFromSync(r) {
        let n = 0;
        const tmp = new Uint8Array(MIN_READ);
        while(true){
            const shouldGrow = this.capacity - this.length < MIN_READ;
            const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
            const nread = r.readSync(buf);
            if (nread === null) {
                return n;
            }
            if (shouldGrow) this.writeSync(buf.subarray(0, nread));
            else this.#reslice(this.length + nread);
            n += nread;
        }
    }
}
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    partial;
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
}
class PartialReadError extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader ? r : new BufReader(r, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i = 100; i > 0; i--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert2(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r) {
        this.#reset(this.#buf, r);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p.byteLength >= this.#buf.byteLength) {
                const rr = await this.#rd.read(p);
                const nread = rr ?? 0;
                assert2(nread >= 0, "negative read");
                return rr;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert2(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy2(this.#buf.subarray(this.#r, this.#w), p, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = p.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = p.subarray(0, bytesRead);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c = this.#buf[this.#r];
        this.#r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF);
        } catch (err) {
            let partial;
            if (err instanceof PartialReadError) {
                partial = err.partial;
                assert2(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
                assert2(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i = this.#buf.subarray(this.#r + s, this.#w).indexOf(delim);
            if (i >= 0) {
                i += s;
                slice = this.#buf.subarray(this.#r, this.#r + i + 1);
                this.#r += i + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = slice;
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n) {
        if (n < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = this.#buf.subarray(this.#r, this.#w);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n) {
            throw new BufferFullError(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n);
    }
}
async function writeAll(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w.write(arr.subarray(nwritten));
    }
}
function writeAllSync(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += w.writeSync(arr.subarray(nwritten));
    }
}
function readerFromStreamReader(streamReader) {
    const buffer = new Buffer1();
    return {
        async read (p) {
            if (buffer.empty()) {
                const res = await streamReader.read();
                if (res.done) {
                    return null;
                }
                await writeAll(buffer, res.value);
            }
            return buffer.read(p);
        }
    };
}
function dataDir() {
    switch(Deno.build.os){
        case "linux":
            {
                const xdg = Deno.env.get("XDG_DATA_HOME");
                if (xdg) return xdg;
                const home = Deno.env.get("HOME");
                if (home) return `${home}/.local/share`;
                break;
            }
        case "darwin":
            {
                const home = Deno.env.get("HOME");
                if (home) return `${home}/Library/Application Support`;
                break;
            }
        case "windows":
            return Deno.env.get("LOCALAPPDATA") ?? null;
    }
    return null;
}
function noop(...args) {}
function createWeakMap() {
    if (typeof WeakMap !== "undefined") {
        return new WeakMap();
    } else {
        return fakeSetOrMap();
    }
}
function fakeSetOrMap() {
    return {
        add: noop,
        delete: noop,
        get: noop,
        set: noop,
        has (k) {
            return false;
        }
    };
}
const hop = Object.prototype.hasOwnProperty;
const has = function(obj, prop) {
    return hop.call(obj, prop);
};
function extend(target, source) {
    for(const prop in source){
        if (has(source, prop)) {
            target[prop] = source[prop];
        }
    }
    return target;
}
const reLeadingNewline = /^[ \t]*(?:\r\n|\r|\n)/;
const reTrailingNewline = /(?:\r\n|\r|\n)[ \t]*$/;
const reStartsWithNewlineOrIsEmpty = /^(?:[\r\n]|$)/;
const reDetectIndentation = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/;
const reOnlyWhitespaceWithAtLeastOneNewline = /^[ \t]*[\r\n][ \t\r\n]*$/;
function _outdentArray(strings, firstInterpolatedValueSetsIndentationLevel, options) {
    let indentationLevel = 0;
    const match = strings[0].match(reDetectIndentation);
    if (match) {
        indentationLevel = match[1].length;
    }
    const reSource = `(\\r\\n|\\r|\\n).{0,${indentationLevel}}`;
    const reMatchIndent = new RegExp(reSource, "g");
    if (firstInterpolatedValueSetsIndentationLevel) {
        strings = strings.slice(1);
    }
    const { newline, trimLeadingNewline, trimTrailingNewline } = options;
    const normalizeNewlines = typeof newline === "string";
    const l = strings.length;
    const outdentedStrings = strings.map((v, i)=>{
        v = v.replace(reMatchIndent, "$1");
        if (i === 0 && trimLeadingNewline) {
            v = v.replace(reLeadingNewline, "");
        }
        if (i === l - 1 && trimTrailingNewline) {
            v = v.replace(reTrailingNewline, "");
        }
        if (normalizeNewlines) {
            v = v.replace(/\r\n|\n|\r/g, (_)=>newline);
        }
        return v;
    });
    return outdentedStrings;
}
function concatStringsAndValues(strings, values) {
    let ret = "";
    for(let i = 0, l = strings.length; i < l; i++){
        ret += strings[i];
        if (i < l - 1) {
            ret += values[i];
        }
    }
    return ret;
}
function isTemplateStringsArray(v) {
    return has(v, "raw") && has(v, "length");
}
function createInstance(options) {
    const arrayAutoIndentCache = createWeakMap();
    const arrayFirstInterpSetsIndentCache = createWeakMap();
    function outdent(stringsOrOptions, ...values) {
        if (isTemplateStringsArray(stringsOrOptions)) {
            const strings = stringsOrOptions;
            const firstInterpolatedValueSetsIndentationLevel = (values[0] === outdent || values[0] === defaultOutdent) && reOnlyWhitespaceWithAtLeastOneNewline.test(strings[0]) && reStartsWithNewlineOrIsEmpty.test(strings[1]);
            const cache = firstInterpolatedValueSetsIndentationLevel ? arrayFirstInterpSetsIndentCache : arrayAutoIndentCache;
            let renderedArray = cache.get(strings);
            if (!renderedArray) {
                renderedArray = _outdentArray(strings, firstInterpolatedValueSetsIndentationLevel, options);
                cache.set(strings, renderedArray);
            }
            if (values.length === 0) {
                return renderedArray[0];
            }
            const rendered = concatStringsAndValues(renderedArray, firstInterpolatedValueSetsIndentationLevel ? values.slice(1) : values);
            return rendered;
        } else {
            return createInstance(extend(extend({}, options), stringsOrOptions || {}));
        }
    }
    const fullOutdent = extend(outdent, {
        string (str) {
            return _outdentArray([
                str
            ], false, options)[0];
        }
    });
    return fullOutdent;
}
const defaultOutdent = createInstance({
    trimLeadingNewline: true,
    trimTrailingNewline: true
});
if (typeof module !== "undefined") {
    try {
        module.exports = defaultOutdent;
        Object.defineProperty(defaultOutdent, "__esModule", {
            value: true
        });
        defaultOutdent.default = defaultOutdent;
        defaultOutdent.outdent = defaultOutdent;
    } catch (e) {}
}
class RealEnvironment {
    env(key) {
        return Deno.env.get(key);
    }
    stat(path) {
        return Deno.stat(path);
    }
    statSync(path) {
        return Deno.statSync(path);
    }
    get os() {
        return Deno.build.os;
    }
}
async function which(command, environment = new RealEnvironment()) {
    const systemInfo = getSystemInfo(command, environment);
    if (systemInfo == null) {
        return undefined;
    }
    for (const pathItem of systemInfo.pathItems){
        const filePath = pathItem + command;
        if (systemInfo.pathExts) {
            for (const pathExt of systemInfo.pathExts){
                const filePath = pathItem + command + pathExt;
                if (await pathMatches(environment, filePath)) {
                    return filePath;
                }
            }
        } else {
            if (await pathMatches(environment, filePath)) {
                return filePath;
            }
        }
    }
    return undefined;
}
async function pathMatches(environment, path) {
    try {
        const result = await environment.stat(path);
        return result.isFile;
    } catch (err) {
        if (err instanceof Deno.errors.PermissionDenied) {
            throw err;
        }
        return false;
    }
}
function whichSync(command, environment = new RealEnvironment()) {
    const systemInfo = getSystemInfo(command, environment);
    if (systemInfo == null) {
        return undefined;
    }
    for (const pathItem of systemInfo.pathItems){
        const filePath = pathItem + command;
        if (pathMatchesSync(environment, filePath)) {
            return filePath;
        }
        if (systemInfo.pathExts) {
            for (const pathExt of systemInfo.pathExts){
                const filePath = pathItem + command + pathExt;
                if (pathMatchesSync(environment, filePath)) {
                    return filePath;
                }
            }
        }
    }
    return undefined;
}
function pathMatchesSync(environment, path) {
    try {
        const result = environment.statSync(path);
        return result.isFile;
    } catch (err) {
        if (err instanceof Deno.errors.PermissionDenied) {
            throw err;
        }
        return false;
    }
}
function getSystemInfo(command, environment) {
    const isWindows = environment.os === "windows";
    const envValueSeparator = isWindows ? ";" : ":";
    const path = environment.env("PATH");
    const pathSeparator = isWindows ? "\\" : "/";
    if (path == null) {
        return undefined;
    }
    return {
        pathItems: splitEnvValue(path).map((item)=>normalizeDir(item)),
        pathExts: getPathExts(),
        isNameMatch: isWindows ? (a, b)=>a.toLowerCase() === b.toLowerCase() : (a, b)=>a === b
    };
    function getPathExts() {
        if (!isWindows) {
            return undefined;
        }
        const pathExtText = environment.env("PATHEXT") ?? ".EXE;.CMD;.BAT;.COM";
        const pathExts = splitEnvValue(pathExtText);
        const lowerCaseCommand = command.toLowerCase();
        for (const pathExt of pathExts){
            if (lowerCaseCommand.endsWith(pathExt.toLowerCase())) {
                return undefined;
            }
        }
        return pathExts;
    }
    function splitEnvValue(value1) {
        return value1.split(envValueSeparator).map((item)=>item.trim()).filter((item)=>item.length > 0);
    }
    function normalizeDir(dirPath) {
        if (!dirPath.endsWith(pathSeparator)) {
            dirPath += pathSeparator;
        }
        return dirPath;
    }
}
const importMeta = {
    url: "https://deno.land/x/dax@0.33.0/src/lib/rs_lib.generated.js",
    main: false
};
let wasm1;
const heap1 = new Array(32).fill(undefined);
heap1.push(undefined, null, true, false);
function getObject1(idx) {
    return heap1[idx];
}
let heap_next1 = heap1.length;
function dropObject1(idx) {
    if (idx < 36) return;
    heap1[idx] = heap_next1;
    heap_next1 = idx;
}
function takeObject1(idx) {
    const ret = getObject1(idx);
    dropObject1(idx);
    return ret;
}
const cachedTextDecoder1 = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
});
cachedTextDecoder1.decode();
let cachedUint8Memory01 = new Uint8Array();
function getUint8Memory01() {
    if (cachedUint8Memory01.byteLength === 0) {
        cachedUint8Memory01 = new Uint8Array(wasm1.memory.buffer);
    }
    return cachedUint8Memory01;
}
function getStringFromWasm01(ptr, len) {
    return cachedTextDecoder1.decode(getUint8Memory01().subarray(ptr, ptr + len));
}
function addHeapObject1(obj) {
    if (heap_next1 === heap1.length) heap1.push(heap1.length + 1);
    const idx = heap_next1;
    heap_next1 = heap1[idx];
    heap1[idx] = obj;
    return idx;
}
function isLikeNone1(x) {
    return x === undefined || x === null;
}
let cachedFloat64Memory0 = new Float64Array();
function getFloat64Memory0() {
    if (cachedFloat64Memory0.byteLength === 0) {
        cachedFloat64Memory0 = new Float64Array(wasm1.memory.buffer);
    }
    return cachedFloat64Memory0;
}
let cachedInt32Memory01 = new Int32Array();
function getInt32Memory01() {
    if (cachedInt32Memory01.byteLength === 0) {
        cachedInt32Memory01 = new Int32Array(wasm1.memory.buffer);
    }
    return cachedInt32Memory01;
}
let WASM_VECTOR_LEN1 = 0;
const cachedTextEncoder1 = new TextEncoder("utf-8");
const encodeString1 = function(arg, view) {
    return cachedTextEncoder1.encodeInto(arg, view);
};
function passStringToWasm01(arg, malloc, realloc) {
    if (realloc === undefined) {
        const buf = cachedTextEncoder1.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory01().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN1 = buf.length;
        return ptr;
    }
    let len = arg.length;
    let ptr = malloc(len);
    const mem = getUint8Memory01();
    let offset = 0;
    for(; offset < len; offset++){
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }
    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory01().subarray(ptr + offset, ptr + len);
        const ret = encodeString1(arg, view);
        offset += ret.written;
    }
    WASM_VECTOR_LEN1 = offset;
    return ptr;
}
let cachedBigInt64Memory0 = new BigInt64Array();
function getBigInt64Memory0() {
    if (cachedBigInt64Memory0.byteLength === 0) {
        cachedBigInt64Memory0 = new BigInt64Array(wasm1.memory.buffer);
    }
    return cachedBigInt64Memory0;
}
function debugString(val1) {
    const type = typeof val1;
    if (type == "number" || type == "boolean" || val1 == null) {
        return `${val1}`;
    }
    if (type == "string") {
        return `"${val1}"`;
    }
    if (type == "symbol") {
        const description = val1.description;
        if (description == null) {
            return "Symbol";
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == "function") {
        const name = val1.name;
        if (typeof name == "string" && name.length > 0) {
            return `Function(${name})`;
        } else {
            return "Function";
        }
    }
    if (Array.isArray(val1)) {
        const length = val1.length;
        let debug = "[";
        if (length > 0) {
            debug += debugString(val1[0]);
        }
        for(let i = 1; i < length; i++){
            debug += ", " + debugString(val1[i]);
        }
        debug += "]";
        return debug;
    }
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val1));
    let className;
    if (builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        return toString.call(val1);
    }
    if (className == "Object") {
        try {
            return "Object(" + JSON.stringify(val1) + ")";
        } catch (_) {
            return "Object";
        }
    }
    if (val1 instanceof Error) {
        return `${val1.name}: ${val1.message}\n${val1.stack}`;
    }
    return className;
}
function parse9(command) {
    try {
        const retptr = wasm1.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm01(command, wasm1.__wbindgen_malloc, wasm1.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN1;
        wasm1.parse(retptr, ptr0, len0);
        var r0 = getInt32Memory01()[retptr / 4 + 0];
        var r1 = getInt32Memory01()[retptr / 4 + 1];
        var r2 = getInt32Memory01()[retptr / 4 + 2];
        if (r2) {
            throw takeObject1(r1);
        }
        return takeObject1(r0);
    } finally{
        wasm1.__wbindgen_add_to_stack_pointer(16);
    }
}
function static_text_render_text(items, cols, rows) {
    try {
        const retptr = wasm1.__wbindgen_add_to_stack_pointer(-16);
        wasm1.static_text_render_text(retptr, addHeapObject1(items), cols, rows);
        var r0 = getInt32Memory01()[retptr / 4 + 0];
        var r1 = getInt32Memory01()[retptr / 4 + 1];
        var r2 = getInt32Memory01()[retptr / 4 + 2];
        var r3 = getInt32Memory01()[retptr / 4 + 3];
        if (r3) {
            throw takeObject1(r2);
        }
        let v0;
        if (r0 !== 0) {
            v0 = getStringFromWasm01(r0, r1).slice();
            wasm1.__wbindgen_free(r0, r1 * 1);
        }
        return v0;
    } finally{
        wasm1.__wbindgen_add_to_stack_pointer(16);
    }
}
function static_text_clear_text(cols, rows) {
    try {
        const retptr = wasm1.__wbindgen_add_to_stack_pointer(-16);
        wasm1.static_text_clear_text(retptr, cols, rows);
        var r0 = getInt32Memory01()[retptr / 4 + 0];
        var r1 = getInt32Memory01()[retptr / 4 + 1];
        let v0;
        if (r0 !== 0) {
            v0 = getStringFromWasm01(r0, r1).slice();
            wasm1.__wbindgen_free(r0, r1 * 1);
        }
        return v0;
    } finally{
        wasm1.__wbindgen_add_to_stack_pointer(16);
    }
}
function static_text_render_once(items, cols, rows) {
    try {
        const retptr = wasm1.__wbindgen_add_to_stack_pointer(-16);
        wasm1.static_text_render_once(retptr, addHeapObject1(items), cols, rows);
        var r0 = getInt32Memory01()[retptr / 4 + 0];
        var r1 = getInt32Memory01()[retptr / 4 + 1];
        var r2 = getInt32Memory01()[retptr / 4 + 2];
        var r3 = getInt32Memory01()[retptr / 4 + 3];
        if (r3) {
            throw takeObject1(r2);
        }
        let v0;
        if (r0 !== 0) {
            v0 = getStringFromWasm01(r0, r1).slice();
            wasm1.__wbindgen_free(r0, r1 * 1);
        }
        return v0;
    } finally{
        wasm1.__wbindgen_add_to_stack_pointer(16);
    }
}
function strip_ansi_codes(text) {
    try {
        const retptr = wasm1.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm01(text, wasm1.__wbindgen_malloc, wasm1.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN1;
        wasm1.strip_ansi_codes(retptr, ptr0, len0);
        var r0 = getInt32Memory01()[retptr / 4 + 0];
        var r1 = getInt32Memory01()[retptr / 4 + 1];
        return getStringFromWasm01(r0, r1);
    } finally{
        wasm1.__wbindgen_add_to_stack_pointer(16);
        wasm1.__wbindgen_free(r0, r1);
    }
}
function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        wasm1.__wbindgen_exn_store(addHeapObject1(e));
    }
}
const imports1 = {
    __wbindgen_placeholder__: {
        __wbindgen_object_drop_ref: function(arg0) {
            takeObject1(arg0);
        },
        __wbindgen_error_new: function(arg0, arg1) {
            const ret = new Error(getStringFromWasm01(arg0, arg1));
            return addHeapObject1(ret);
        },
        __wbindgen_boolean_get: function(arg0) {
            const v = getObject1(arg0);
            const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
            return ret;
        },
        __wbindgen_is_bigint: function(arg0) {
            const ret = typeof getObject1(arg0) === "bigint";
            return ret;
        },
        __wbindgen_bigint_from_i64: function(arg0) {
            const ret = arg0;
            return addHeapObject1(ret);
        },
        __wbindgen_jsval_eq: function(arg0, arg1) {
            const ret = getObject1(arg0) === getObject1(arg1);
            return ret;
        },
        __wbindgen_number_get: function(arg0, arg1) {
            const obj = getObject1(arg1);
            const ret = typeof obj === "number" ? obj : undefined;
            getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone1(ret) ? 0 : ret;
            getInt32Memory01()[arg0 / 4 + 0] = !isLikeNone1(ret);
        },
        __wbindgen_string_get: function(arg0, arg1) {
            const obj = getObject1(arg1);
            const ret = typeof obj === "string" ? obj : undefined;
            var ptr0 = isLikeNone1(ret) ? 0 : passStringToWasm01(ret, wasm1.__wbindgen_malloc, wasm1.__wbindgen_realloc);
            var len0 = WASM_VECTOR_LEN1;
            getInt32Memory01()[arg0 / 4 + 1] = len0;
            getInt32Memory01()[arg0 / 4 + 0] = ptr0;
        },
        __wbindgen_is_object: function(arg0) {
            const val1 = getObject1(arg0);
            const ret = typeof val1 === "object" && val1 !== null;
            return ret;
        },
        __wbindgen_in: function(arg0, arg1) {
            const ret = getObject1(arg0) in getObject1(arg1);
            return ret;
        },
        __wbindgen_bigint_from_u64: function(arg0) {
            const ret = BigInt.asUintN(64, arg0);
            return addHeapObject1(ret);
        },
        __wbindgen_object_clone_ref: function(arg0) {
            const ret = getObject1(arg0);
            return addHeapObject1(ret);
        },
        __wbindgen_string_new: function(arg0, arg1) {
            const ret = getStringFromWasm01(arg0, arg1);
            return addHeapObject1(ret);
        },
        __wbindgen_jsval_loose_eq: function(arg0, arg1) {
            const ret = getObject1(arg0) == getObject1(arg1);
            return ret;
        },
        __wbg_set_20cbc34131e76824: function(arg0, arg1, arg2) {
            getObject1(arg0)[takeObject1(arg1)] = takeObject1(arg2);
        },
        __wbg_get_57245cc7d7c7619d: function(arg0, arg1) {
            const ret = getObject1(arg0)[arg1 >>> 0];
            return addHeapObject1(ret);
        },
        __wbg_length_6e3bbe7c8bd4dbd8: function(arg0) {
            const ret = getObject1(arg0).length;
            return ret;
        },
        __wbg_new_1d9a920c6bfc44a8: function() {
            const ret = new Array();
            return addHeapObject1(ret);
        },
        __wbindgen_is_function: function(arg0) {
            const ret = typeof getObject1(arg0) === "function";
            return ret;
        },
        __wbg_next_579e583d33566a86: function(arg0) {
            const ret = getObject1(arg0).next;
            return addHeapObject1(ret);
        },
        __wbg_next_aaef7c8aa5e212ac: function() {
            return handleError(function(arg0) {
                const ret = getObject1(arg0).next();
                return addHeapObject1(ret);
            }, arguments);
        },
        __wbg_done_1b73b0672e15f234: function(arg0) {
            const ret = getObject1(arg0).done;
            return ret;
        },
        __wbg_value_1ccc36bc03462d71: function(arg0) {
            const ret = getObject1(arg0).value;
            return addHeapObject1(ret);
        },
        __wbg_iterator_6f9d4f28845f426c: function() {
            const ret = Symbol.iterator;
            return addHeapObject1(ret);
        },
        __wbg_get_765201544a2b6869: function() {
            return handleError(function(arg0, arg1) {
                const ret = Reflect.get(getObject1(arg0), getObject1(arg1));
                return addHeapObject1(ret);
            }, arguments);
        },
        __wbg_call_97ae9d8645dc388b: function() {
            return handleError(function(arg0, arg1) {
                const ret = getObject1(arg0).call(getObject1(arg1));
                return addHeapObject1(ret);
            }, arguments);
        },
        __wbg_new_0b9bfdd97583284e: function() {
            const ret = new Object();
            return addHeapObject1(ret);
        },
        __wbg_set_a68214f35c417fa9: function(arg0, arg1, arg2) {
            getObject1(arg0)[arg1 >>> 0] = takeObject1(arg2);
        },
        __wbg_isArray_27c46c67f498e15d: function(arg0) {
            const ret = Array.isArray(getObject1(arg0));
            return ret;
        },
        __wbg_instanceof_ArrayBuffer_e5e48f4762c5610b: function(arg0) {
            let result;
            try {
                result = getObject1(arg0) instanceof ArrayBuffer;
            } catch  {
                result = false;
            }
            const ret = result;
            return ret;
        },
        __wbg_isSafeInteger_dfa0593e8d7ac35a: function(arg0) {
            const ret = Number.isSafeInteger(getObject1(arg0));
            return ret;
        },
        __wbg_entries_65a76a413fc91037: function(arg0) {
            const ret = Object.entries(getObject1(arg0));
            return addHeapObject1(ret);
        },
        __wbg_buffer_3f3d764d4747d564: function(arg0) {
            const ret = getObject1(arg0).buffer;
            return addHeapObject1(ret);
        },
        __wbg_new_8c3f0052272a457a: function(arg0) {
            const ret = new Uint8Array(getObject1(arg0));
            return addHeapObject1(ret);
        },
        __wbg_set_83db9690f9353e79: function(arg0, arg1, arg2) {
            getObject1(arg0).set(getObject1(arg1), arg2 >>> 0);
        },
        __wbg_length_9e1ae1900cb0fbd5: function(arg0) {
            const ret = getObject1(arg0).length;
            return ret;
        },
        __wbg_instanceof_Uint8Array_971eeda69eb75003: function(arg0) {
            let result;
            try {
                result = getObject1(arg0) instanceof Uint8Array;
            } catch  {
                result = false;
            }
            const ret = result;
            return ret;
        },
        __wbg_new_abda76e883ba8a5f: function() {
            const ret = new Error();
            return addHeapObject1(ret);
        },
        __wbg_stack_658279fe44541cf6: function(arg0, arg1) {
            const ret = getObject1(arg1).stack;
            const ptr0 = passStringToWasm01(ret, wasm1.__wbindgen_malloc, wasm1.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN1;
            getInt32Memory01()[arg0 / 4 + 1] = len0;
            getInt32Memory01()[arg0 / 4 + 0] = ptr0;
        },
        __wbg_error_f851667af71bcfc6: function(arg0, arg1) {
            try {
                console.error(getStringFromWasm01(arg0, arg1));
            } finally{
                wasm1.__wbindgen_free(arg0, arg1);
            }
        },
        __wbindgen_bigint_get_as_i64: function(arg0, arg1) {
            const v = getObject1(arg1);
            const ret = typeof v === "bigint" ? v : undefined;
            getBigInt64Memory0()[arg0 / 8 + 1] = isLikeNone1(ret) ? 0n : ret;
            getInt32Memory01()[arg0 / 4 + 0] = !isLikeNone1(ret);
        },
        __wbindgen_debug_string: function(arg0, arg1) {
            const ret = debugString(getObject1(arg1));
            const ptr0 = passStringToWasm01(ret, wasm1.__wbindgen_malloc, wasm1.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN1;
            getInt32Memory01()[arg0 / 4 + 1] = len0;
            getInt32Memory01()[arg0 / 4 + 0] = ptr0;
        },
        __wbindgen_throw: function(arg0, arg1) {
            throw new Error(getStringFromWasm01(arg0, arg1));
        },
        __wbindgen_memory: function() {
            const ret = wasm1.memory;
            return addHeapObject1(ret);
        }
    }
};
async function instantiate1(opts) {
    return (await instantiateWithInstance1(opts)).exports;
}
let instanceWithExports1;
let lastLoadPromise;
function instantiateWithInstance1(opts) {
    if (instanceWithExports1 != null) {
        return Promise.resolve(instanceWithExports1);
    }
    if (lastLoadPromise == null) {
        lastLoadPromise = (async ()=>{
            try {
                const instance = (await instantiateModule(opts ?? {})).instance;
                wasm1 = instance.exports;
                cachedInt32Memory01 = new Int32Array(wasm1.memory.buffer);
                cachedUint8Memory01 = new Uint8Array(wasm1.memory.buffer);
                instanceWithExports1 = {
                    instance,
                    exports: getWasmInstanceExports()
                };
                return instanceWithExports1;
            } finally{
                lastLoadPromise = null;
            }
        })();
    }
    return lastLoadPromise;
}
function getWasmInstanceExports() {
    return {
        parse: parse9,
        static_text_render_text,
        static_text_clear_text,
        static_text_render_once,
        strip_ansi_codes
    };
}
async function instantiateModule(opts) {
    const wasmUrl = opts.url ?? new URL("rs_lib_bg.wasm", importMeta.url);
    const decompress = opts.decompress;
    const isFile = wasmUrl.protocol === "file:";
    const isNode = globalThis.process?.versions?.node != null;
    if (isNode && isFile) {
        const wasmCode = await Deno.readFile(wasmUrl);
        return WebAssembly.instantiate(decompress ? decompress(wasmCode) : wasmCode, imports1);
    }
    switch(wasmUrl.protocol){
        case "file:":
        case "https:":
        case "http:":
            {
                if (isFile) {
                    if (typeof Deno !== "object") {
                        throw new Error("file urls are not supported in this environment");
                    }
                    if ("permissions" in Deno) {
                        await Deno.permissions.request({
                            name: "read",
                            path: wasmUrl
                        });
                    }
                } else if (typeof Deno === "object" && "permissions" in Deno) {
                    await Deno.permissions.request({
                        name: "net",
                        host: wasmUrl.host
                    });
                }
                const wasmResponse = await fetch(wasmUrl);
                if (decompress) {
                    const wasmCode = new Uint8Array(await wasmResponse.arrayBuffer());
                    return WebAssembly.instantiate(decompress(wasmCode), imports1);
                }
                if (isFile || wasmResponse.headers.get("content-type")?.toLowerCase().startsWith("application/wasm")) {
                    return WebAssembly.instantiateStreaming(wasmResponse, imports1);
                } else {
                    return WebAssembly.instantiate(await wasmResponse.arrayBuffer(), imports1);
                }
            }
        default:
            throw new Error(`Unsupported protocol: ${wasmUrl.protocol}`);
    }
}
const importMeta1 = {
    url: "https://deno.land/x/dax@0.33.0/src/lib/mod.ts",
    main: false
};
async function getWasmFileUrl() {
    const url = new URL("rs_lib_bg.wasm", importMeta1.url);
    if (url.protocol !== "file:") {
        return await cacheLocalDir(url) ?? url;
    }
    return url;
}
async function cacheLocalDir(url) {
    const localPath = await getUrlLocalPath(url);
    if (localPath == null) {
        return undefined;
    }
    if (!await mod9.exists(localPath)) {
        const fileBytes = await getUrlBytes(url);
        await Deno.writeFile(localPath, new Uint8Array(fileBytes));
    }
    return mod8.toFileUrl(localPath);
}
async function getUrlLocalPath(url) {
    try {
        const dataDirPath = await getInitializedLocalDataDirPath();
        const version = getUrlVersion(url);
        return mod8.join(dataDirPath, version + ".wasm");
    } catch  {
        return undefined;
    }
}
async function getInitializedLocalDataDirPath() {
    const dataDir1 = dataDir();
    if (dataDir1 == null) {
        throw new Error(`Could not find local data directory.`);
    }
    const dirPath = mod8.join(dataDir1, "dax");
    await mod9.ensureDir(dirPath);
    return dirPath;
}
function getUrlVersion(url) {
    const version = url.pathname.match(/([0-9]+)\.([0-9]+)\.([0-9]+)/)?.[0];
    if (version == null) {
        throw new Error(`Could not find version in url: ${url}`);
    }
    return version;
}
async function getUrlBytes(url) {
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`Error downloading ${url}: ${response.statusText}`);
    }
    return await response.arrayBuffer();
}
const wasmInstance = await instantiate1({
    url: await getWasmFileUrl()
});
const encoder = new TextEncoder();
var LoggerRefreshItemKind;
const decoder = new TextDecoder();
var Keys;
(function(Keys) {
    Keys[Keys["Up"] = 0] = "Up";
    Keys[Keys["Down"] = 1] = "Down";
    Keys[Keys["Left"] = 2] = "Left";
    Keys[Keys["Right"] = 3] = "Right";
    Keys[Keys["Enter"] = 4] = "Enter";
    Keys[Keys["Space"] = 5] = "Space";
    Keys[Keys["Backspace"] = 6] = "Backspace";
})(Keys || (Keys = {}));
async function* readKeys() {
    const { strip_ansi_codes } = wasmInstance;
    while(true){
        const buf = new Uint8Array(8);
        const byteCount = await Deno.read(Deno.stdin.rid, buf);
        if (byteCount == null) {
            break;
        }
        if (byteCount === 3) {
            if (buf[0] === 27 && buf[1] === 91) {
                if (buf[2] === 65) {
                    yield Keys.Up;
                    continue;
                } else if (buf[2] === 66) {
                    yield Keys.Down;
                    continue;
                } else if (buf[2] === 67) {
                    yield Keys.Right;
                    continue;
                } else if (buf[2] === 68) {
                    yield Keys.Left;
                    continue;
                }
            }
        } else if (byteCount === 1) {
            if (buf[0] === 3) {
                break;
            } else if (buf[0] === 13) {
                yield Keys.Enter;
                continue;
            } else if (buf[0] === 32) {
                yield Keys.Space;
                continue;
            } else if (buf[0] === 127) {
                yield Keys.Backspace;
                continue;
            }
        }
        const text = strip_ansi_codes(decoder.decode(buf.slice(0, byteCount ?? 0)));
        if (text.length > 0) {
            yield text;
        }
    }
}
function hideCursor() {
    Deno.stderr.writeSync(encoder.encode("\x1B[?25l"));
}
function showCursor() {
    Deno.stderr.writeSync(encoder.encode("\x1B[?25h"));
}
const isOutputTty = safeConsoleSize() != null && Deno.isatty(Deno.stderr.rid);
function resultOrExit(result) {
    if (result == null) {
        Deno.exit(130);
    } else {
        return result;
    }
}
(function(LoggerRefreshItemKind) {
    LoggerRefreshItemKind[LoggerRefreshItemKind["ProgressBars"] = 0] = "ProgressBars";
    LoggerRefreshItemKind[LoggerRefreshItemKind["Selection"] = 1] = "Selection";
})(LoggerRefreshItemKind || (LoggerRefreshItemKind = {}));
const refreshItems = {
    [LoggerRefreshItemKind.ProgressBars]: undefined,
    [LoggerRefreshItemKind.Selection]: undefined
};
function setItems(kind, items, size) {
    refreshItems[kind] = items;
    refresh(size);
}
const logger = {
    setItems,
    logOnce,
    logAboveStaticText
};
function createSelection(options) {
    if (!isOutputTty || !Deno.isatty(Deno.stdin.rid)) {
        throw new Error(`Cannot prompt when not a tty. (Prompt: '${options.message}')`);
    }
    if (safeConsoleSize() == null) {
        throw new Error(`Cannot prompt when can't get console size. (Prompt: '${options.message}')`);
    }
    return ensureSingleSelection(async ()=>{
        logger.setItems(LoggerRefreshItemKind.Selection, options.render());
        for await (const key of readKeys()){
            const keyResult = options.onKey(key);
            if (keyResult != null) {
                const size = Deno.consoleSize();
                logger.setItems(LoggerRefreshItemKind.Selection, [], size);
                if (options.noClear) {
                    logger.logOnce(options.render(), size);
                }
                return keyResult;
            }
            logger.setItems(LoggerRefreshItemKind.Selection, options.render());
        }
        logger.setItems(LoggerRefreshItemKind.Selection, []);
        return undefined;
    });
}
let lastPromise = Promise.resolve();
function ensureSingleSelection(action) {
    const currentLastPromise = lastPromise;
    const currentPromise = (async ()=>{
        try {
            await currentLastPromise;
        } catch  {}
        hideCursor();
        try {
            Deno.stdin.setRaw(true);
            try {
                return await action();
            } finally{
                Deno.stdin.setRaw(false);
            }
        } finally{
            showCursor();
        }
    })();
    lastPromise = currentPromise;
    return currentPromise;
}
function safeConsoleSize() {
    try {
        return Deno.consoleSize();
    } catch  {
        return undefined;
    }
}
const staticText = {
    set (items, size) {
        if (items.length === 0) {
            return this.clear(size);
        }
        const { columns, rows } = size ?? Deno.consoleSize();
        const newText = wasmInstance.static_text_render_text(items, columns, rows);
        if (newText != null) {
            Deno.stderr.writeSync(encoder.encode(newText));
        }
    },
    outputItems (items, size) {
        const { columns, rows } = size ?? Deno.consoleSize();
        const newText = wasmInstance.static_text_render_once(items, columns, rows);
        if (newText != null) {
            Deno.stderr.writeSync(encoder.encode(newText + "\n"));
        }
    },
    clear (size) {
        const { columns, rows } = size ?? Deno.consoleSize();
        const newText = wasmInstance.static_text_clear_text(columns, rows);
        if (newText != null) {
            Deno.stderr.writeSync(encoder.encode(newText));
        }
    }
};
function refresh(size) {
    if (!isOutputTty) {
        return;
    }
    const items = Object.values(refreshItems).flatMap((items)=>items ?? []);
    staticText.set(items, size);
}
function logAboveStaticText(inner, providedSize) {
    if (!isOutputTty) {
        inner();
        return;
    }
    const size = providedSize ?? safeConsoleSize();
    if (size != null) {
        staticText.clear(size);
    }
    inner();
    refresh(size);
}
function logOnce(items, size) {
    logAboveStaticText(()=>{
        staticText.outputItems(items, size);
    }, size);
}
function confirm(optsOrMessage, options) {
    return maybeConfirm(optsOrMessage, options).then(resultOrExit);
}
function maybeConfirm(optsOrMessage, options) {
    const opts = typeof optsOrMessage === "string" ? {
        message: optsOrMessage,
        ...options
    } : optsOrMessage;
    return createSelection({
        message: opts.message,
        noClear: opts.noClear,
        ...innerConfirm(opts)
    });
}
function innerConfirm(opts) {
    const drawState = {
        title: opts.message,
        default: opts.default,
        inputText: "",
        hasCompleted: false
    };
    return {
        render: ()=>render(drawState),
        onKey: (key)=>{
            switch(key){
                case "Y":
                case "y":
                    drawState.inputText = "Y";
                    break;
                case "N":
                case "n":
                    drawState.inputText = "N";
                    break;
                case Keys.Backspace:
                    drawState.inputText = "";
                    break;
                case Keys.Enter:
                    if (drawState.inputText.length === 0) {
                        if (drawState.default == null) {
                            return undefined;
                        }
                        drawState.inputText = drawState.default ? "Y" : "N";
                    }
                    drawState.hasCompleted = true;
                    return drawState.inputText === "Y" ? true : drawState.inputText === "N" ? false : drawState.default;
            }
        }
    };
}
function render(state) {
    return [
        mod5.bold(mod5.blue(state.title)) + " " + (state.hasCompleted ? "" : state.default == null ? "(Y/N) " : state.default ? "(Y/n) " : "(y/N) ") + state.inputText + (state.hasCompleted ? "" : "\u2588")
    ];
}
function multiSelect(opts) {
    return maybeMultiSelect(opts).then(resultOrExit);
}
function maybeMultiSelect(opts) {
    if (opts.options.length === 0) {
        throw new Error(`You must provide at least one option. (Prompt: '${opts.message}')`);
    }
    return createSelection({
        message: opts.message,
        noClear: opts.noClear,
        ...innerMultiSelect(opts)
    });
}
function innerMultiSelect(opts) {
    const drawState = {
        title: opts.message,
        activeIndex: 0,
        items: opts.options.map((option)=>{
            if (typeof option === "string") {
                option = {
                    text: option
                };
            }
            return {
                selected: option.selected ?? false,
                text: option.text
            };
        }),
        hasCompleted: false
    };
    return {
        render: ()=>render1(drawState),
        onKey: (key)=>{
            switch(key){
                case Keys.Up:
                    if (drawState.activeIndex === 0) {
                        drawState.activeIndex = drawState.items.length - 1;
                    } else {
                        drawState.activeIndex--;
                    }
                    break;
                case Keys.Down:
                    drawState.activeIndex = (drawState.activeIndex + 1) % drawState.items.length;
                    break;
                case Keys.Space:
                    {
                        const item = drawState.items[drawState.activeIndex];
                        item.selected = !item.selected;
                        break;
                    }
                case Keys.Enter:
                    drawState.hasCompleted = true;
                    return drawState.items.map((value1, index)=>[
                            value1,
                            index
                        ]).filter(([value1])=>value1.selected).map(([, index])=>index);
            }
            return undefined;
        }
    };
}
function render1(state) {
    const items = [];
    items.push(mod5.bold(mod5.blue(state.title)));
    if (state.hasCompleted) {
        if (state.items.some((i)=>i.selected)) {
            for (const item of state.items){
                if (item.selected) {
                    items.push({
                        text: ` - ${item.text}`,
                        indent: 3
                    });
                }
            }
        } else {
            items.push(mod5.italic(" <None>"));
        }
    } else {
        for (const [i, item] of state.items.entries()){
            const prefix = i === state.activeIndex ? "> " : "  ";
            items.push({
                text: `${prefix}[${item.selected ? "x" : " "}] ${item.text}`,
                indent: 6
            });
        }
    }
    return items;
}
const units = [
    "B",
    "KiB",
    "MiB",
    "GiB",
    "TiB",
    "PiB",
    "EiB",
    "ZiB",
    "YiB"
];
function humanDownloadSize(byteCount, totalBytes) {
    const exponent = Math.min(units.length - 1, Math.floor(Math.log(totalBytes) / Math.log(1024)));
    const unit = units[exponent];
    const prettyBytes = (Math.floor(byteCount / Math.pow(1024, exponent) * 100) / 100).toFixed(exponent === 0 ? 0 : 2);
    return `${prettyBytes} ${unit}`;
}
const intervalMs = 60;
const progressBars = [];
let renderIntervalId;
function addProgressBar(render) {
    const pb = {
        render
    };
    progressBars.push(pb);
    if (renderIntervalId == null && isOutputTty) {
        renderIntervalId = setInterval(forceRender, intervalMs);
    }
    return pb;
}
function removeProgressBar(pb) {
    const index = progressBars.indexOf(pb);
    if (index === -1) {
        return false;
    }
    progressBars.splice(index, 1);
    if (progressBars.length === 0) {
        clearInterval(renderIntervalId);
        logger.setItems(LoggerRefreshItemKind.ProgressBars, []);
        renderIntervalId = undefined;
    }
    return true;
}
function forceRender() {
    if (!isShowingProgressBars()) {
        return;
    }
    const size = Deno.consoleSize();
    const items = progressBars.map((p)=>p.render(size)).flat();
    logger.setItems(LoggerRefreshItemKind.ProgressBars, items, size);
}
function isShowingProgressBars() {
    return isOutputTty && progressBars.length > 0;
}
class ProgressBar {
    #state;
    #pb;
    #withCount = 0;
    #onLog;
    #noClear;
    constructor(onLog, opts){
        if (arguments.length !== 2) {
            throw new Error("Invalid usage. Create the progress bar via `$.progress`.");
        }
        this.#onLog = onLog;
        this.#state = {
            message: opts.message,
            prefix: opts.prefix,
            length: opts.length,
            currentPos: 0,
            tickCount: 0,
            hasCompleted: false,
            kind: "raw"
        };
        this.#pb = addProgressBar((size)=>{
            this.#state.tickCount++;
            return renderProgressBar(this.#state, size);
        });
        this.#noClear = opts.noClear ?? false;
        this.#logIfNonInteractive();
    }
    prefix(prefix) {
        this.#state.prefix = prefix;
        if (prefix != null && prefix.length > 0) {
            this.#logIfNonInteractive();
        }
        return this;
    }
    message(message) {
        this.#state.message = message;
        if (message != null && message.length > 0) {
            this.#logIfNonInteractive();
        }
        return this;
    }
    kind(kind) {
        this.#state.kind = kind;
        return this;
    }
    #logIfNonInteractive() {
        if (isOutputTty) {
            return;
        }
        let text = this.#state.prefix ?? "";
        if (text.length > 0) {
            text += " ";
        }
        text += this.#state.message ?? "";
        if (text.length > 0) {
            this.#onLog(text);
        }
    }
    position(position) {
        this.#state.currentPos = position;
        return this;
    }
    increment(inc = 1) {
        this.#state.currentPos += inc;
        return this;
    }
    length(size) {
        this.#state.length = size;
        return this;
    }
    noClear(value1 = true) {
        this.#noClear = value1;
        return this;
    }
    forceRender() {
        return forceRender();
    }
    finish() {
        if (removeProgressBar(this.#pb)) {
            this.#state.hasCompleted = true;
            if (this.#noClear) {
                const text = renderProgressBar(this.#state, safeConsoleSize()).map((item)=>typeof item === "string" ? item : item.text).join("\n");
                this.#onLog(text);
            }
        }
    }
    with(action) {
        this.#withCount++;
        let wasAsync = false;
        try {
            const result = action();
            if (result instanceof Promise) {
                wasAsync = true;
                return result.finally(()=>{
                    this.#decrementWith();
                });
            } else {
                return result;
            }
        } finally{
            if (!wasAsync) {
                this.#decrementWith();
            }
        }
    }
    #decrementWith() {
        this.#withCount--;
        if (this.#withCount === 0) {
            this.finish();
        }
    }
}
const tickStrings = [
    "⠋",
    "⠙",
    "⠹",
    "⠸",
    "⠼",
    "⠴",
    "⠦",
    "⠧",
    "⠇",
    "⠏"
];
function renderProgressBar(state, size) {
    if (state.hasCompleted) {
        let text = "";
        if (state.prefix != null) {
            text += mod5.green(state.prefix);
        }
        if (state.message != null) {
            if (text.length > 0) {
                text += " ";
            }
            text += state.message;
        }
        return text.length > 0 ? [
            text
        ] : [];
    } else if (state.length == null || state.length === 0) {
        let text = mod5.green(tickStrings[Math.abs(state.tickCount) % tickStrings.length]);
        if (state.prefix != null) {
            text += ` ${mod5.green(state.prefix)}`;
        }
        if (state.message != null) {
            text += ` ${state.message}`;
        }
        return [
            text
        ];
    } else {
        let firstLine = "";
        if (state.prefix != null) {
            firstLine += mod5.green(state.prefix);
        }
        if (state.message != null) {
            if (firstLine.length > 0) {
                firstLine += " ";
            }
            firstLine += state.message;
        }
        const percent = Math.min(state.currentPos / state.length, 1);
        const currentPosText = state.kind === "bytes" ? humanDownloadSize(state.currentPos, state.length) : state.currentPos.toString();
        const lengthText = state.kind === "bytes" ? humanDownloadSize(state.length, state.length) : state.length.toString();
        const maxWidth = size == null ? 75 : Math.max(10, Math.min(75, size.columns - 5));
        const sameLineTextWidth = 6 + lengthText.length * 2 + state.length.toString().length * 2;
        const totalBars = Math.max(1, maxWidth - sameLineTextWidth);
        const completedBars = Math.floor(totalBars * percent);
        let secondLine = "";
        secondLine += "[";
        if (completedBars != totalBars) {
            if (completedBars > 0) {
                secondLine += mod5.cyan("#".repeat(completedBars - 1) + ">");
            }
            secondLine += mod5.blue("-".repeat(totalBars - completedBars));
        } else {
            secondLine += mod5.cyan("#".repeat(completedBars));
        }
        secondLine += `] (${currentPosText}/${lengthText})`;
        const result = [];
        if (firstLine.length > 0) {
            result.push(firstLine);
        }
        result.push(secondLine);
        return result;
    }
}
const defaultMask = {
    char: "*",
    lastVisible: false
};
function prompt(optsOrMessage, options) {
    return maybePrompt(optsOrMessage, options).then(resultOrExit);
}
function maybePrompt(optsOrMessage, options) {
    const opts = typeof optsOrMessage === "string" ? {
        message: optsOrMessage,
        ...options
    } : optsOrMessage;
    return createSelection({
        message: opts.message,
        noClear: opts.noClear,
        ...innerPrompt(opts)
    });
}
function innerPrompt(opts) {
    let mask = opts.mask ?? false;
    if (mask && typeof mask === "boolean") {
        mask = defaultMask;
    }
    const drawState = {
        title: opts.message,
        inputText: opts.default ?? "",
        mask,
        hasCompleted: false
    };
    return {
        render: ()=>render2(drawState),
        onKey: (key)=>{
            if (typeof key === "string") {
                drawState.inputText += key;
            } else {
                switch(key){
                    case Keys.Space:
                        drawState.inputText += " ";
                        break;
                    case Keys.Backspace:
                        drawState.inputText = drawState.inputText.slice(0, -1);
                        break;
                    case Keys.Enter:
                        drawState.hasCompleted = true;
                        return drawState.inputText;
                }
            }
            return undefined;
        }
    };
}
function render2(state) {
    let { inputText } = state;
    if (state.mask) {
        const __char = state.mask.char ?? defaultMask.char;
        const lastVisible = state.mask.lastVisible ?? defaultMask.lastVisible;
        const shouldShowLast = lastVisible && !state.hasCompleted;
        const safeLengthMinusOne = Math.max(0, inputText.length - 1);
        const masked = __char.repeat(shouldShowLast ? safeLengthMinusOne : inputText.length);
        const unmasked = shouldShowLast ? inputText.slice(safeLengthMinusOne) : "";
        inputText = `${masked}${unmasked}`;
    }
    return [
        mod5.bold(mod5.blue(state.title)) + " " + inputText + (state.hasCompleted ? "" : "\u2588")
    ];
}
function select(opts) {
    return maybeSelect(opts).then(resultOrExit);
}
function maybeSelect(opts) {
    if (opts.options.length <= 1) {
        throw new Error(`You must provide at least two options. (Prompt: '${opts.message}')`);
    }
    return createSelection({
        message: opts.message,
        noClear: opts.noClear,
        ...innerSelect(opts)
    });
}
function innerSelect(opts) {
    const drawState = {
        title: opts.message,
        activeIndex: (opts.initialIndex ?? 0) % opts.options.length,
        items: opts.options,
        hasCompleted: false
    };
    return {
        render: ()=>render3(drawState),
        onKey: (key)=>{
            switch(key){
                case Keys.Up:
                    if (drawState.activeIndex === 0) {
                        drawState.activeIndex = drawState.items.length - 1;
                    } else {
                        drawState.activeIndex--;
                    }
                    break;
                case Keys.Down:
                    drawState.activeIndex = (drawState.activeIndex + 1) % drawState.items.length;
                    break;
                case Keys.Enter:
                    drawState.hasCompleted = true;
                    return drawState.activeIndex;
            }
        }
    };
}
function render3(state) {
    const items = [];
    items.push(mod5.bold(mod5.blue(state.title)));
    if (state.hasCompleted) {
        items.push({
            text: ` - ${state.items[state.activeIndex]}`,
            indent: 3
        });
    } else {
        for (const [i, text] of state.items.entries()){
            const prefix = i === state.activeIndex ? "> " : "  ";
            items.push({
                text: `${prefix}${text}`,
                indent: 4
            });
        }
    }
    return items;
}
function formatMillis(ms) {
    if (ms < 1000) {
        return `${formatValue(ms)} millisecond${ms === 1 ? "" : "s"}`;
    } else if (ms < 60 * 1000) {
        const s = ms / 1000;
        return `${formatValue(s)} ${pluralize("second", s)}`;
    } else {
        const mins = ms / 60 / 1000;
        return `${formatValue(mins)} ${pluralize("minute", mins)}`;
    }
    function formatValue(value1) {
        const text = value1.toFixed(2);
        if (text.endsWith(".00")) {
            return value1.toFixed(0);
        } else if (text.endsWith("0")) {
            return value1.toFixed(1);
        } else {
            return text;
        }
    }
    function pluralize(text, value1) {
        const suffix = value1 === 1 ? "" : "s";
        return text + suffix;
    }
}
function delayToIterator(delay) {
    if (typeof delay !== "number" && typeof delay !== "string") {
        return delay;
    }
    const ms = delayToMs(delay);
    return {
        next () {
            return ms;
        }
    };
}
function delayToMs(delay) {
    if (typeof delay === "number") {
        return delay;
    } else if (typeof delay === "string") {
        const msMatch = delay.match(/^([0-9]+)ms$/);
        if (msMatch != null) {
            return parseInt(msMatch[1], 10);
        }
        const secondsMatch = delay.match(/^([0-9]+\.?[0-9]*)s$/);
        if (secondsMatch != null) {
            return Math.round(parseFloat(secondsMatch[1]) * 1000);
        }
        const minutesMatch = delay.match(/^([0-9]+\.?[0-9]*)m$/);
        if (minutesMatch != null) {
            return Math.round(parseFloat(minutesMatch[1]) * 1000 * 60);
        }
        const minutesSecondsMatch = delay.match(/^([0-9]+\.?[0-9]*)m([0-9]+\.?[0-9]*)s$/);
        if (minutesSecondsMatch != null) {
            return Math.round(parseFloat(minutesSecondsMatch[1]) * 1000 * 60 + parseFloat(minutesSecondsMatch[2]) * 1000);
        }
        const hoursMatch = delay.match(/^([0-9]+\.?[0-9]*)h$/);
        if (hoursMatch != null) {
            return Math.round(parseFloat(hoursMatch[1]) * 1000 * 60 * 60);
        }
        const hoursMinutesMatch = delay.match(/^([0-9]+\.?[0-9]*)h([0-9]+\.?[0-9]*)m$/);
        if (hoursMinutesMatch != null) {
            return Math.round(parseFloat(hoursMinutesMatch[1]) * 1000 * 60 * 60 + parseFloat(hoursMinutesMatch[2]) * 1000 * 60);
        }
        const hoursMinutesSecondsMatch = delay.match(/^([0-9]+\.?[0-9]*)h([0-9]+\.?[0-9]*)m([0-9]+\.?[0-9]*)s$/);
        if (hoursMinutesSecondsMatch != null) {
            return Math.round(parseFloat(hoursMinutesSecondsMatch[1]) * 1000 * 60 * 60 + parseFloat(hoursMinutesSecondsMatch[2]) * 1000 * 60 + parseFloat(hoursMinutesSecondsMatch[3]) * 1000);
        }
    }
    throw new Error(`Unknown delay value: ${delay}`);
}
function filterEmptyRecordValues(record) {
    const result = {};
    for (const [key, value1] of Object.entries(record)){
        if (value1 != null) {
            result[key] = value1;
        }
    }
    return result;
}
function resolvePath(cwd, arg) {
    return mod8.resolve(mod8.isAbsolute(arg) ? arg : mod8.join(cwd, arg));
}
class Box {
    value;
    constructor(value1){
        this.value = value1;
    }
}
class TreeBox {
    #value;
    constructor(value1){
        this.#value = value1;
    }
    getValue() {
        let tree = this;
        while(tree.#value instanceof TreeBox){
            tree = tree.#value;
        }
        return tree.#value;
    }
    setValue(value1) {
        this.#value = value1;
    }
    createChild() {
        return new TreeBox(this);
    }
}
class LoggerTreeBox extends TreeBox {
    getValue() {
        const innerValue = super.getValue();
        return (...args)=>{
            return logger.logAboveStaticText(()=>{
                innerValue(...args);
            });
        };
    }
}
async function safeLstat(path) {
    try {
        return await Deno.lstat(path);
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return undefined;
        } else {
            throw err;
        }
    }
}
function getFileNameFromUrl(url) {
    const parsedUrl = url instanceof URL ? url : new URL(url);
    const fileName = parsedUrl.pathname.split("/").at(-1);
    return fileName?.length === 0 ? undefined : fileName;
}
async function getExecutableShebangFromPath(path) {
    try {
        const file = await Deno.open(path, {
            read: true
        });
        try {
            return await getExecutableShebang(file);
        } finally{
            try {
                file.close();
            } catch  {}
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err;
    }
}
const decoder1 = new TextDecoder();
async function getExecutableShebang(reader) {
    const text = "#!/usr/bin/env ";
    const buffer = new Uint8Array(text.length);
    const bytesReadCount = await reader.read(buffer);
    if (bytesReadCount !== text.length || decoder1.decode(buffer) !== text) {
        return undefined;
    }
    const bufReader = new BufReader(reader);
    const line = await bufReader.readLine();
    if (line == null) {
        return undefined;
    }
    const result = decoder1.decode(line.line).trim();
    const dashS = "-S ";
    if (result.startsWith(dashS)) {
        return {
            stringSplit: true,
            command: result.slice(dashS.length)
        };
    } else {
        return {
            stringSplit: false,
            command: result
        };
    }
}
function resultFromCode(code) {
    return {
        kind: "continue",
        code
    };
}
function getAbortedResult() {
    return {
        kind: "exit",
        code: 124
    };
}
async function cdCommand(context) {
    try {
        const dir = await executeCd(context.cwd, context.args);
        return {
            code: 0,
            kind: "continue",
            changes: [
                {
                    kind: "cd",
                    dir
                }
            ]
        };
    } catch (err) {
        context.stderr.writeLine(`cd: ${err?.message ?? err}`);
        return resultFromCode(1);
    }
}
async function executeCd(cwd, args) {
    const arg = parseArgs(args);
    const result = resolvePath(cwd, arg);
    if (!await isDirectory(result)) {
        throw new Error(`${result}: Not a directory`);
    }
    return result;
}
async function isDirectory(path) {
    try {
        const info = await Deno.stat(path);
        return info.isDirectory;
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return false;
        } else {
            throw err;
        }
    }
}
function parseArgs(args) {
    if (args.length === 0) {
        throw new Error("expected at least 1 argument");
    } else if (args.length > 1) {
        throw new Error("too many arguments");
    } else {
        return args[0];
    }
}
function printEnvCommand(context) {
    let args;
    if (Deno.build.os === "windows") {
        args = context.args.map((arg)=>arg.toUpperCase());
    } else {
        args = context.args;
    }
    try {
        const result = executePrintEnv(context.env, args);
        context.stdout.writeLine(result);
        if (args.some((arg)=>context.env[arg] === undefined)) {
            return resultFromCode(1);
        }
        return resultFromCode(0);
    } catch (err) {
        context.stderr.writeLine(`printenv: ${err?.message ?? err}`);
        return resultFromCode(1);
    }
}
function executePrintEnv(env, args) {
    const isWindows = Deno.build.os === "windows";
    if (args.length === 0) {
        return Object.entries(env).map(([key, val1])=>`${isWindows ? key.toUpperCase() : key}=${val1}`).join("\n");
    } else {
        if (isWindows) {
            args = args.map((arg)=>arg.toUpperCase());
        }
        return Object.entries(env).filter(([key])=>args.includes(key)).map(([_key, val1])=>val1).join("\n");
    }
}
function parseArgKinds(flags) {
    const result = [];
    let had_dash_dash = false;
    for (const arg of flags){
        if (had_dash_dash) {
            result.push({
                arg,
                kind: "Arg"
            });
        } else if (arg == "-") {
            result.push({
                arg: "-",
                kind: "Arg"
            });
        } else if (arg == "--") {
            had_dash_dash = true;
        } else if (arg.startsWith("--")) {
            result.push({
                arg: arg.replace(/^--/, ""),
                kind: "LongFlag"
            });
        } else if (arg.startsWith("-")) {
            const flags = arg.replace(/^-/, "");
            if (!isNaN(parseFloat(flags))) {
                result.push({
                    arg,
                    kind: "Arg"
                });
            } else {
                for (const c of flags){
                    result.push({
                        arg: c,
                        kind: "ShortFlag"
                    });
                }
            }
        } else {
            result.push({
                arg,
                kind: "Arg"
            });
        }
    }
    return result;
}
function bailUnsupported(arg) {
    switch(arg.kind){
        case "Arg":
            throw Error(`unsupported argument: ${arg.arg}`);
        case "ShortFlag":
            throw Error(`unsupported flag: -${arg.arg}`);
        case "LongFlag":
            throw Error(`unsupported flag: --${arg.arg}`);
    }
}
async function cpCommand(context) {
    try {
        await executeCp(context.cwd, context.args);
        return resultFromCode(0);
    } catch (err) {
        context.stderr.writeLine(`cp: ${err?.message ?? err}`);
        return resultFromCode(1);
    }
}
async function executeCp(cwd, args) {
    const flags = await parseCpArgs(cwd, args);
    for (const { from, to } of flags.operations){
        await doCopyOperation(flags, from, to);
    }
}
async function parseCpArgs(cwd, args) {
    const paths = [];
    let recursive = false;
    for (const arg of parseArgKinds(args)){
        if (arg.kind === "Arg") paths.push(arg.arg);
        else if (arg.arg === "recursive" && arg.kind === "LongFlag" || arg.arg === "r" && arg.kind == "ShortFlag" || arg.arg === "R" && arg.kind === "ShortFlag") {
            recursive = true;
        } else bailUnsupported(arg);
    }
    if (paths.length === 0) throw Error("missing file operand");
    else if (paths.length === 1) throw Error(`missing destination file operand after '${paths[0]}'`);
    return {
        recursive,
        operations: await getCopyAndMoveOperations(cwd, paths)
    };
}
async function doCopyOperation(flags, from, to) {
    const fromInfo = await safeLstat(from.path);
    if (fromInfo?.isDirectory) {
        if (flags.recursive) {
            const toInfo = await safeLstat(to.path);
            if (toInfo?.isFile) {
                throw Error("destination was a file");
            } else if (toInfo?.isSymlink) {
                throw Error("no support for copying to symlinks");
            } else if (fromInfo.isSymlink) {
                throw Error("no support for copying from symlinks");
            } else {
                await copyDirRecursively(from.path, to.path);
            }
        } else {
            throw Error("source was a directory; maybe specify -r");
        }
    } else {
        await Deno.copyFile(from.path, to.path);
    }
}
async function copyDirRecursively(from, to) {
    await Deno.mkdir(to, {
        recursive: true
    });
    const readDir = Deno.readDir(from);
    for await (const entry of readDir){
        const newFrom = mod8.join(from, mod8.basename(entry.name));
        const newTo = mod8.join(to, mod8.basename(entry.name));
        if (entry.isDirectory) {
            await copyDirRecursively(newFrom, newTo);
        } else if (entry.isFile) {
            await Deno.copyFile(newFrom, newTo);
        }
    }
}
async function mvCommand(context) {
    try {
        await executeMove(context.cwd, context.args);
        return resultFromCode(0);
    } catch (err) {
        context.stderr.writeLine(`mv: ${err?.message ?? err}`);
        return resultFromCode(1);
    }
}
async function executeMove(cwd, args) {
    const flags = await parseMvArgs(cwd, args);
    for (const { from, to } of flags.operations){
        await Deno.rename(from.path, to.path);
    }
}
async function parseMvArgs(cwd, args) {
    const paths = [];
    for (const arg of parseArgKinds(args)){
        if (arg.kind === "Arg") paths.push(arg.arg);
        else bailUnsupported(arg);
    }
    if (paths.length === 0) throw Error("missing operand");
    else if (paths.length === 1) throw Error(`missing destination file operand after '${paths[0]}'`);
    return {
        operations: await getCopyAndMoveOperations(cwd, paths)
    };
}
async function getCopyAndMoveOperations(cwd, paths) {
    const specified_destination = paths.splice(paths.length - 1, 1)[0];
    const destination = resolvePath(cwd, specified_destination);
    const fromArgs = paths;
    const operations = [];
    if (fromArgs.length > 1) {
        if (!await safeLstat(destination).then((p)=>p?.isDirectory)) {
            throw Error(`target '${specified_destination}' is not a directory`);
        }
        for (const from of fromArgs){
            const fromPath = resolvePath(cwd, from);
            const toPath = mod8.join(destination, mod8.basename(fromPath));
            operations.push({
                from: {
                    specified: from,
                    path: fromPath
                },
                to: {
                    specified: specified_destination,
                    path: toPath
                }
            });
        }
    } else {
        const fromPath = resolvePath(cwd, fromArgs[0]);
        const toPath = await safeLstat(destination).then((p)=>p?.isDirectory) ? calculateDestinationPath(destination, fromPath) : destination;
        operations.push({
            from: {
                specified: fromArgs[0],
                path: fromPath
            },
            to: {
                specified: specified_destination,
                path: toPath
            }
        });
    }
    return operations;
}
function calculateDestinationPath(destination, from) {
    return mod8.join(destination, mod8.basename(from));
}
function echoCommand(context) {
    context.stdout.writeLine(context.args.join(" "));
    return resultFromCode(0);
}
async function catCommand(context) {
    try {
        const exit_code = await executeCat(context);
        return resultFromCode(exit_code);
    } catch (err) {
        context.stderr.writeLine(`cat: ${err?.message ?? err}`);
        return resultFromCode(1);
    }
}
async function executeCat(context) {
    const flags = parseCatArgs(context.args);
    let exit_code = 0;
    const buf = new Uint8Array(1024);
    for (const path of flags.paths){
        if (path === "-") {
            if (typeof context.stdin === "object") {
                while(true){
                    const size = await context.stdin.read(buf);
                    if (!size || size === 0) break;
                    else context.stdout.writeSync(buf.slice(0, size));
                }
            } else {
                context.stdin;
                throw new Error(`not supported. stdin was '${context.stdin}'`);
            }
        } else {
            let file;
            try {
                file = Deno.openSync(mod8.join(context.cwd, path), {
                    read: true
                });
                while(true){
                    const size = file.readSync(buf);
                    if (!size || size === 0) break;
                    else context.stdout.writeSync(buf.slice(0, size));
                }
            } catch (err) {
                context.stderr.writeLine(`cat ${path}: ${err}`);
                exit_code = 1;
            } finally{
                if (file) file.close();
            }
        }
    }
    return exit_code;
}
function parseCatArgs(args) {
    const paths = [];
    for (const arg of parseArgKinds(args)){
        if (arg.kind === "Arg") paths.push(arg.arg);
        else bailUnsupported(arg);
    }
    if (paths.length === 0) paths.push("-");
    return {
        paths
    };
}
function exitCommand(context) {
    try {
        const code = parseArgs1(context.args);
        return {
            kind: "exit",
            code
        };
    } catch (err) {
        context.stderr.writeLine(`exit: ${err?.message ?? err}`);
        return {
            kind: "exit",
            code: 2
        };
    }
}
function parseArgs1(args) {
    if (args.length === 0) return 1;
    if (args.length > 1) throw new Error("too many arguments");
    const exitCode = parseInt(args[0], 10);
    if (isNaN(exitCode)) throw new Error("numeric argument required.");
    if (exitCode < 0) {
        const code = -exitCode % 256;
        return 256 - code;
    }
    return exitCode % 256;
}
function exportCommand(context) {
    const changes = [];
    for (const arg of context.args){
        const equalsIndex = arg.indexOf("=");
        if (equalsIndex >= 0) {
            changes.push({
                kind: "envvar",
                name: arg.substring(0, equalsIndex),
                value: arg.substring(equalsIndex + 1)
            });
        }
    }
    return {
        kind: "continue",
        code: 0,
        changes
    };
}
async function mkdirCommand(context) {
    try {
        await executeMkdir(context.cwd, context.args);
        return resultFromCode(0);
    } catch (err) {
        context.stderr.writeLine(`mkdir: ${err?.message ?? err}`);
        return resultFromCode(1);
    }
}
async function executeMkdir(cwd, args) {
    const flags = parseArgs2(args);
    for (const specifiedPath of flags.paths){
        const path = resolvePath(cwd, specifiedPath);
        const info = await safeLstat(path);
        if (info?.isFile || !flags.parents && info?.isDirectory) {
            throw Error(`cannot create directory '${specifiedPath}': File exists`);
        }
        if (flags.parents) {
            await Deno.mkdir(path, {
                recursive: true
            });
        } else {
            await Deno.mkdir(path);
        }
    }
}
function parseArgs2(args) {
    const result = {
        parents: false,
        paths: []
    };
    for (const arg of parseArgKinds(args)){
        if (arg.arg === "parents" && arg.kind === "LongFlag" || arg.arg === "p" && arg.kind == "ShortFlag") {
            result.parents = true;
        } else {
            if (arg.kind !== "Arg") bailUnsupported(arg);
            result.paths.push(arg.arg.trim());
        }
    }
    if (result.paths.length === 0) {
        throw Error("missing operand");
    }
    return result;
}
async function rmCommand(context) {
    try {
        await executeRemove(context.cwd, context.args);
        return resultFromCode(0);
    } catch (err) {
        context.stderr.writeLine(`rm: ${err?.message ?? err}`);
        return resultFromCode(1);
    }
}
async function executeRemove(cwd, args) {
    const flags = parseArgs3(args);
    await Promise.all(flags.paths.map((specifiedPath)=>{
        if (specifiedPath.length === 0) {
            throw new Error("Bug in dax. Specified path should have not been empty.");
        }
        const path = resolvePath(cwd, specifiedPath);
        if (path === "/") {
            throw new Error("Cannot delete root directory. Maybe bug in dax? Please report this.");
        }
        return Deno.remove(path, {
            recursive: flags.recursive
        }).catch((err)=>{
            if (flags.force && err instanceof Deno.errors.NotFound) {
                return Promise.resolve();
            } else {
                return Promise.reject(err);
            }
        });
    }));
}
function parseArgs3(args) {
    const result = {
        recursive: false,
        force: false,
        dir: false,
        paths: []
    };
    for (const arg of parseArgKinds(args)){
        if (arg.arg === "recursive" && arg.kind === "LongFlag" || arg.arg === "r" && arg.kind == "ShortFlag" || arg.arg === "R" && arg.kind === "ShortFlag") {
            result.recursive = true;
        } else if (arg.arg == "dir" && arg.kind === "LongFlag" || arg.arg == "d" && arg.kind === "ShortFlag") {
            result.dir = true;
        } else if (arg.arg == "force" && arg.kind === "LongFlag" || arg.arg == "f" && arg.kind === "ShortFlag") {
            result.force = true;
        } else {
            if (arg.kind !== "Arg") bailUnsupported1(arg);
            result.paths.push(arg.arg.trim());
        }
    }
    if (result.paths.length === 0) {
        throw Error("missing operand");
    }
    return result;
}
function bailUnsupported1(arg) {
    switch(arg.kind){
        case "Arg":
            throw Error(`unsupported argument: ${arg.arg}`);
        case "ShortFlag":
            throw Error(`unsupported flag: -${arg.arg}`);
        case "LongFlag":
            throw Error(`unsupported flag: --${arg.arg}`);
    }
}
function pwdCommand(context) {
    try {
        const output = executePwd(context.cwd, context.args);
        context.stdout.writeLine(output);
        return resultFromCode(0);
    } catch (err) {
        context.stderr.writeLine(`pwd: ${err?.message ?? err}`);
        return resultFromCode(1);
    }
}
function executePwd(cwd, args) {
    const flags = parseArgs4(args);
    if (flags.logical) {
        return mod8.resolve(cwd);
    } else {
        return cwd;
    }
}
function parseArgs4(args) {
    let logical = false;
    for (const arg of parseArgKinds(args)){
        if (arg.arg === "L" && arg.kind === "ShortFlag") {
            logical = true;
        } else if (arg.arg === "P" && arg.kind == "ShortFlag") {} else if (arg.kind === "Arg") {} else {
            bailUnsupported(arg);
        }
    }
    return {
        logical
    };
}
async function sleepCommand(context) {
    try {
        const ms = parseArgs5(context.args);
        await new Promise((resolve)=>{
            const timeoutId = setTimeout(listener, ms);
            context.signal.addEventListener("abort", listener);
            function listener() {
                resolve();
                clearInterval(timeoutId);
                context.signal.removeEventListener("abort", listener);
            }
        });
        if (context.signal.aborted) {
            return getAbortedResult();
        }
        return resultFromCode(0);
    } catch (err) {
        context.stderr.writeLine(`sleep: ${err?.message ?? err}`);
        return resultFromCode(1);
    }
}
function parseArgs5(args) {
    let totalTimeMs = 0;
    if (args.length === 0) {
        throw new Error("missing operand");
    }
    for (const arg of args){
        if (arg.startsWith("-")) {
            throw new Error(`unsupported: ${arg}`);
        }
        const value1 = parseFloat(arg);
        if (isNaN(value1)) {
            throw new Error(`error parsing argument '${arg}' to number.`);
        }
        totalTimeMs = value1 * 1000;
    }
    return totalTimeMs;
}
async function testCommand(context) {
    try {
        const [testFlag, testPath] = parseArgs6(context.cwd, context.args);
        let result;
        switch(testFlag){
            case "-f":
                result = (await safeLstat(testPath))?.isFile ?? false;
                break;
            case "-d":
                result = (await safeLstat(testPath))?.isDirectory ?? false;
                break;
            case "-e":
                result = await mod9.exists(testPath);
                break;
            case "-s":
                result = ((await safeLstat(testPath))?.size ?? 0) > 0;
                break;
            case "-L":
                result = (await safeLstat(testPath))?.isSymlink ?? false;
                break;
            default:
                throw new Error("unsupported test type");
        }
        return resultFromCode(result ? 0 : 1);
    } catch (err) {
        context.stderr.writeLine(`test: ${err?.message ?? err}`);
        return resultFromCode(2);
    }
}
function parseArgs6(cwd, args) {
    if (args.length !== 2) {
        throw new Error("expected 2 arguments");
    }
    if (args[0] == null || !args[0].startsWith("-")) {
        throw new Error("missing test type flag");
    }
    return [
        args[0],
        resolvePath(cwd, args[1])
    ];
}
async function touchCommand(context) {
    try {
        await executetouch(context.args);
        return resultFromCode(0);
    } catch (err) {
        context.stderr.writeLine(`touch: ${err?.message ?? err}`);
        return resultFromCode(1);
    }
}
async function executetouch(args) {
    const flags = parseArgs7(args);
    for (const path of flags.paths){
        const f = await Deno.create(path);
        f.close();
    }
}
function parseArgs7(args) {
    const paths = [];
    for (const arg of parseArgKinds(args)){
        if (arg.kind === "Arg") paths.push(arg.arg);
        else bailUnsupported(arg);
    }
    if (paths.length === 0) throw Error("missing file operand");
    return {
        paths
    };
}
function unsetCommand(context) {
    try {
        return {
            kind: "continue",
            code: 0,
            changes: parseNames(context.args).map((name)=>({
                    kind: "unsetvar",
                    name
                }))
        };
    } catch (err) {
        context.stderr.writeLine(`unset: ${err?.message ?? err}`);
        return resultFromCode(1);
    }
}
function parseNames(args) {
    if (args[0] === "-f") {
        throw Error(`unsupported flag: -f`);
    } else if (args[0] === "-v") {
        return args.slice(1);
    } else {
        return args;
    }
}
const encoder1 = new TextEncoder();
class NullPipeWriter {
    writeSync(p) {
        return p.length;
    }
}
class ShellPipeWriter {
    #kind;
    #inner;
    constructor(kind, inner){
        this.#kind = kind;
        this.#inner = inner;
    }
    get kind() {
        return this.#kind;
    }
    writeSync(p) {
        return this.#inner.writeSync(p);
    }
    writeText(text) {
        return writeAllSync(this, encoder1.encode(text));
    }
    writeLine(text) {
        return this.writeText(text + "\n");
    }
}
class CapturingBufferWriter {
    #buffer;
    #innerWriter;
    constructor(innerWriter, buffer){
        this.#innerWriter = innerWriter;
        this.#buffer = buffer;
    }
    getBuffer() {
        return this.#buffer;
    }
    writeSync(p) {
        const nWritten = this.#innerWriter.writeSync(p);
        this.#buffer.writeSync(p.slice(0, nWritten));
        return nWritten;
    }
}
const lineFeedCharCode = "\n".charCodeAt(0);
class InheritStaticTextBypassWriter {
    #buffer;
    #innerWriter;
    constructor(innerWriter){
        this.#innerWriter = innerWriter;
        this.#buffer = new Buffer1();
    }
    writeSync(p) {
        const index = p.findLastIndex((v)=>v === lineFeedCharCode);
        if (index === -1) {
            this.#buffer.writeSync(p);
        } else {
            this.#buffer.writeSync(p.slice(0, index + 1));
            this.flush();
            this.#buffer.writeSync(p.slice(index + 1));
        }
        return p.byteLength;
    }
    flush() {
        const bytes = this.#buffer.bytes({
            copy: false
        });
        logger.logAboveStaticText(()=>{
            writeAllSync(this.#innerWriter, bytes);
        });
        this.#buffer.reset();
    }
}
class PipedBuffer {
    #inner;
    #hasSet = false;
    constructor(){
        this.#inner = new Buffer1();
    }
    getBuffer() {
        if (this.#inner instanceof Buffer1) {
            return this.#inner;
        } else {
            return undefined;
        }
    }
    setError(err) {
        if ("setError" in this.#inner) {
            this.#inner.setError(err);
        }
    }
    close() {
        if ("close" in this.#inner) {
            this.#inner.close();
        }
    }
    writeSync(p) {
        return this.#inner.writeSync(p);
    }
    setListener(listener) {
        if (this.#hasSet) {
            throw new Error("Piping to multiple outputs is currently not supported.");
        }
        if (this.#inner instanceof Buffer1) {
            writeAllSync(listener, this.#inner.bytes({
                copy: false
            }));
        }
        this.#inner = listener;
        this.#hasSet = true;
    }
}
class RealEnv {
    setCwd(cwd) {
        Deno.chdir(cwd);
    }
    getCwd() {
        return Deno.cwd();
    }
    setEnvVar(key, value1) {
        if (value1 == null) {
            Deno.env.delete(key);
        } else {
            Deno.env.set(key, value1);
        }
    }
    getEnvVar(key) {
        return Deno.env.get(key);
    }
    getEnvVars() {
        return Deno.env.toObject();
    }
    clone() {
        return cloneEnv(this);
    }
}
class ShellEnv {
    #cwd;
    #envVars = {};
    setCwd(cwd) {
        this.#cwd = cwd;
    }
    getCwd() {
        if (this.#cwd == null) {
            throw new Error("The cwd must be initialized.");
        }
        return this.#cwd;
    }
    setEnvVar(key, value1) {
        if (Deno.build.os === "windows") {
            key = key.toUpperCase();
        }
        if (value1 == null) {
            delete this.#envVars[key];
        } else {
            this.#envVars[key] = value1;
        }
    }
    getEnvVar(key) {
        if (Deno.build.os === "windows") {
            key = key.toUpperCase();
        }
        return this.#envVars[key];
    }
    getEnvVars() {
        return {
            ...this.#envVars
        };
    }
    clone() {
        return cloneEnv(this);
    }
}
function initializeEnv(env, opts) {
    env.setCwd(opts.cwd);
    for (const [key, value1] of Object.entries(opts.env)){
        env.setEnvVar(key, value1);
    }
}
function cloneEnv(env) {
    const result = new ShellEnv();
    initializeEnv(result, {
        cwd: env.getCwd(),
        env: env.getEnvVars()
    });
    return result;
}
class Context {
    stdin;
    stdout;
    stderr;
    #env;
    #shellVars;
    #commands;
    #signal;
    constructor(opts){
        this.stdin = opts.stdin;
        this.stdout = opts.stdout;
        this.stderr = opts.stderr;
        this.#env = opts.env;
        this.#commands = opts.commands;
        this.#shellVars = opts.shellVars;
        this.#signal = opts.signal;
    }
    get signal() {
        return this.#signal;
    }
    applyChanges(changes) {
        if (changes == null) {
            return;
        }
        for (const change of changes){
            switch(change.kind){
                case "cd":
                    this.#env.setCwd(change.dir);
                    break;
                case "envvar":
                    this.setEnvVar(change.name, change.value);
                    break;
                case "shellvar":
                    this.setShellVar(change.name, change.value);
                    break;
                case "unsetvar":
                    this.setShellVar(change.name, undefined);
                    this.setEnvVar(change.name, undefined);
                    break;
                default:
                    {
                        throw new Error(`Not implemented env change: ${change}`);
                    }
            }
        }
    }
    setEnvVar(key, value1) {
        if (Deno.build.os === "windows") {
            key = key.toUpperCase();
        }
        if (key === "PWD") {
            if (value1 != null && mod8.isAbsolute(value1)) {
                this.#env.setCwd(mod8.resolve(value1));
            }
        } else {
            delete this.#shellVars[key];
            this.#env.setEnvVar(key, value1);
        }
    }
    setShellVar(key, value1) {
        if (Deno.build.os === "windows") {
            key = key.toUpperCase();
        }
        if (this.#env.getEnvVar(key) != null || key === "PWD") {
            this.setEnvVar(key, value1);
        } else if (value1 == null) {
            delete this.#shellVars[key];
        } else {
            this.#shellVars[key] = value1;
        }
    }
    getEnvVars() {
        return this.#env.getEnvVars();
    }
    getCwd() {
        return this.#env.getCwd();
    }
    getVar(key) {
        if (Deno.build.os === "windows") {
            key = key.toUpperCase();
        }
        if (key === "PWD") {
            return this.#env.getCwd();
        }
        return this.#env.getEnvVar(key) ?? this.#shellVars[key];
    }
    getCommand(command) {
        return this.#commands[command] ?? null;
    }
    asCommandContext(args) {
        const context = this;
        return {
            get args () {
                return args;
            },
            get cwd () {
                return context.getCwd();
            },
            get env () {
                return context.getEnvVars();
            },
            get stdin () {
                return context.stdin;
            },
            get stdout () {
                return context.stdout;
            },
            get stderr () {
                return context.stderr;
            },
            get signal () {
                return context.signal;
            }
        };
    }
    clone() {
        return new Context({
            stdin: this.stdin,
            stdout: this.stdout,
            stderr: this.stderr,
            env: this.#env.clone(),
            commands: {
                ...this.#commands
            },
            shellVars: {
                ...this.#shellVars
            },
            signal: this.#signal
        });
    }
}
function parseCommand(command) {
    return wasmInstance.parse(command);
}
async function spawn(list, opts) {
    const env = opts.exportEnv ? new RealEnv() : new ShellEnv();
    initializeEnv(env, opts);
    const context = new Context({
        env,
        commands: opts.commands,
        stdin: opts.stdin,
        stdout: opts.stdout,
        stderr: opts.stderr,
        shellVars: {},
        signal: opts.signal
    });
    const result = await executeSequentialList(list, context);
    return result.code;
}
async function executeSequentialList(list, context) {
    let finalExitCode = 0;
    const finalChanges = [];
    for (const item of list.items){
        if (item.isAsync) {
            throw new Error("Async commands are not supported. Run a command concurrently in the JS code instead.");
        }
        const result = await executeSequence(item.sequence, context);
        switch(result.kind){
            case "continue":
                if (result.changes) {
                    context.applyChanges(result.changes);
                    finalChanges.push(...result.changes);
                }
                finalExitCode = result.code;
                break;
            case "exit":
                return result;
            default:
        }
    }
    return {
        kind: "continue",
        code: finalExitCode,
        changes: finalChanges
    };
}
function executeSequence(sequence, context) {
    if (context.signal.aborted) {
        return Promise.resolve(getAbortedResult());
    }
    switch(sequence.kind){
        case "pipeline":
            return executePipeline(sequence, context);
        case "booleanList":
            return executeBooleanList(sequence, context);
        case "shellVar":
            return executeShellVar(sequence, context);
        default:
            {
                throw new Error(`Not implemented: ${sequence}`);
            }
    }
}
function executePipeline(pipeline, context) {
    if (pipeline.negated) {
        throw new Error("Negated pipelines are not implemented.");
    }
    return executePipelineInner(pipeline.inner, context);
}
async function executeBooleanList(list, context) {
    const changes = [];
    const firstResult = await executeSequence(list.current, context.clone());
    let exitCode = 0;
    switch(firstResult.kind){
        case "exit":
            return firstResult;
        case "continue":
            if (firstResult.changes) {
                context.applyChanges(firstResult.changes);
                changes.push(...firstResult.changes);
            }
            exitCode = firstResult.code;
            break;
        default:
            {
                throw new Error("Not handled.");
            }
    }
    const next = findNextSequence(list, exitCode);
    if (next == null) {
        return {
            kind: "continue",
            code: exitCode,
            changes
        };
    } else {
        const nextResult = await executeSequence(next, context.clone());
        switch(nextResult.kind){
            case "exit":
                return nextResult;
            case "continue":
                if (nextResult.changes) {
                    changes.push(...nextResult.changes);
                }
                return {
                    kind: "continue",
                    code: nextResult.code,
                    changes
                };
            default:
                {
                    throw new Error("Not Implemented");
                }
        }
    }
    function findNextSequence(current, exitCode) {
        if (opMovesNextForExitCode(current.op, exitCode)) {
            return current.next;
        } else {
            let next = current.next;
            while(next.kind === "booleanList"){
                if (opMovesNextForExitCode(next.op, exitCode)) {
                    return next.next;
                } else {
                    next = next.next;
                }
            }
            return undefined;
        }
    }
    function opMovesNextForExitCode(op, exitCode) {
        switch(op){
            case "or":
                return exitCode !== 0;
            case "and":
                return exitCode === 0;
        }
    }
}
async function executeShellVar(sequence, context) {
    const value1 = await evaluateWord(sequence.value, context);
    return {
        kind: "continue",
        code: 0,
        changes: [
            {
                kind: "shellvar",
                name: sequence.name,
                value: value1
            }
        ]
    };
}
function executePipelineInner(inner, context) {
    switch(inner.kind){
        case "command":
            return executeCommand(inner, context);
        case "pipeSequence":
            throw new Error(`Not implemented: ${inner.kind}`);
    }
}
function executeCommand(command, context) {
    if (command.redirect != null) {
        throw new Error("Redirects are not supported. Pipe in the JS code instead using the methods on commands.");
    }
    return executeCommandInner(command.inner, context);
}
function executeCommandInner(command, context) {
    switch(command.kind){
        case "simple":
            return executeSimpleCommand(command, context);
        case "sequentialList":
        default:
            throw new Error(`Not implemented: ${command.kind}`);
    }
}
async function executeSimpleCommand(command, parentContext) {
    const context = parentContext.clone();
    for (const envVar of command.envVars){
        context.setEnvVar(envVar.name, await evaluateWord(envVar.value, context));
    }
    const commandArgs = await evaluateArgs(command.args, context);
    return await executeCommandArgs(commandArgs, context);
}
async function executeCommandArgs(commandArgs, context) {
    const command = context.getCommand(commandArgs[0]);
    if (command != null) {
        return command(context.asCommandContext(commandArgs.slice(1)));
    }
    const resolvedCommand = await resolveCommand(commandArgs[0], context);
    if (resolvedCommand.kind === "shebang") {
        return executeCommandArgs([
            ...resolvedCommand.args,
            resolvedCommand.path,
            ...commandArgs.slice(1)
        ], context);
    }
    resolvedCommand.kind;
    const pipeStringVals = {
        stdin: getStdioStringValue(context.stdin),
        stdout: getStdioStringValue(context.stdout.kind),
        stderr: getStdioStringValue(context.stderr.kind)
    };
    const p = new Deno.Command(resolvedCommand.path, {
        args: commandArgs.slice(1),
        cwd: context.getCwd(),
        env: context.getEnvVars(),
        ...pipeStringVals
    }).spawn();
    const abortListener = ()=>p.kill("SIGKILL");
    context.signal.addEventListener("abort", abortListener);
    const completeController = new AbortController();
    const completeSignal = completeController.signal;
    let stdinError;
    const stdinPromise = writeStdin(context.stdin, p, completeSignal).catch((err)=>{
        if (completeSignal.aborted) {
            return;
        }
        context.stderr.writeLine(`stdin pipe broken. ${err}`);
        stdinError = err;
        try {
            p.kill("SIGKILL");
        } catch (err) {
            if (!(err instanceof Deno.errors.PermissionDenied || err instanceof Deno.errors.NotFound)) {
                throw err;
            }
        }
    });
    try {
        const readStdoutTask = pipeStringVals.stdout === "piped" ? readStdOutOrErr(p.stdout, context.stdout) : Promise.resolve();
        const readStderrTask = pipeStringVals.stderr === "piped" ? readStdOutOrErr(p.stderr, context.stderr) : Promise.resolve();
        const [status] = await Promise.all([
            p.status,
            readStdoutTask,
            readStderrTask
        ]);
        if (stdinError != null) {
            return {
                code: 1,
                kind: "exit"
            };
        } else if (context.signal.aborted) {
            return getAbortedResult();
        } else {
            return resultFromCode(status.code);
        }
    } finally{
        completeController.abort();
        context.signal.removeEventListener("abort", abortListener);
        await stdinPromise;
    }
    async function writeStdin(stdin, p, signal) {
        if (typeof stdin === "string") {
            return;
        }
        await pipeReaderToWriter(stdin, p.stdin, signal);
        try {
            await p.stdin.close();
        } catch  {}
    }
    async function readStdOutOrErr(readable, writer) {
        if (typeof writer === "string") {
            return;
        }
        await pipeReaderToWriterSync(readable, writer, new AbortController().signal);
    }
    async function pipeReaderToWriter(reader, writable, signal) {
        const abortedPromise = new Promise((resolve)=>{
            signal.addEventListener("abort", listener);
            function listener() {
                signal.removeEventListener("abort", listener);
                resolve();
            }
        });
        const writer = writable.getWriter();
        try {
            while(!signal.aborted){
                const buffer = new Uint8Array(1024);
                const length = await Promise.race([
                    abortedPromise,
                    reader.read(buffer)
                ]);
                if (length === 0 || length == null) {
                    break;
                }
                await writer.write(buffer.subarray(0, length));
            }
        } finally{
            await writer.close();
        }
    }
    async function pipeReaderToWriterSync(readable, writer, signal) {
        const reader = readable.getReader();
        while(!signal.aborted){
            const result = await reader.read();
            if (result.done) {
                break;
            }
            writeAllSync(result.value);
        }
        function writeAllSync(arr) {
            let nwritten = 0;
            while(nwritten < arr.length && !signal.aborted){
                nwritten += writer.writeSync(arr.subarray(nwritten));
            }
        }
    }
    function getStdioStringValue(value1) {
        if (value1 === "inheritPiped") {
            return "piped";
        } else if (value1 === "inherit" || value1 === "null" || value1 === "piped") {
            return value1;
        } else {
            return "piped";
        }
    }
}
async function resolveCommand(commandName, context) {
    if (commandName.includes("/") || commandName.includes("\\")) {
        if (!mod8.isAbsolute(commandName)) {
            commandName = mod8.resolve(context.getCwd(), commandName);
        }
        const result = await getExecutableShebangFromPath(commandName);
        if (result === false) {
            throw new Error(`Command not found: ${commandName}`);
        } else if (result != null) {
            return {
                kind: "shebang",
                path: commandName,
                args: await parseShebangArgs(result, context)
            };
        } else {
            return {
                kind: "path",
                path: commandName
            };
        }
    }
    if (commandName.toUpperCase() === "DENO") {
        return {
            kind: "path",
            path: Deno.execPath()
        };
    }
    const realEnvironment = new RealEnvironment();
    const commandPath = await which(commandName, {
        os: Deno.build.os,
        stat: realEnvironment.stat,
        env (key) {
            return context.getVar(key);
        }
    });
    if (commandPath == null) {
        throw new Error(`Command not found: ${commandName}`);
    }
    return {
        kind: "path",
        path: commandPath
    };
}
async function parseShebangArgs(info, context) {
    function throwUnsupported() {
        throw new Error("Unsupported shebang. Please report this as a bug.");
    }
    if (!info.stringSplit) {
        return [
            info.command
        ];
    }
    const command = parseCommand(info.command);
    if (command.items.length !== 1) {
        throwUnsupported();
    }
    const item = command.items[0];
    if (item.sequence.kind !== "pipeline" || item.isAsync) {
        throwUnsupported();
    }
    const sequence = item.sequence;
    if (sequence.negated) {
        throwUnsupported();
    }
    if (sequence.inner.kind !== "command" || sequence.inner.redirect != null) {
        throwUnsupported();
    }
    const innerCommand = sequence.inner.inner;
    if (innerCommand.kind !== "simple") {
        throwUnsupported();
    }
    if (innerCommand.envVars.length > 0) {
        throwUnsupported();
    }
    return await evaluateArgs(innerCommand.args, context);
}
async function evaluateArgs(args, context) {
    const result = [];
    for (const arg of args){
        result.push(...await evaluateWordParts(arg, context));
    }
    return result;
}
async function evaluateWord(word, context) {
    const result = await evaluateWordParts(word, context);
    return result.join(" ");
}
async function evaluateWordParts(wordParts, context) {
    const result = [];
    let currentText = "";
    for (const stringPart of wordParts){
        let evaluationResult = undefined;
        switch(stringPart.kind){
            case "text":
                currentText += stringPart.value;
                break;
            case "variable":
                evaluationResult = context.getVar(stringPart.value);
                break;
            case "quoted":
                {
                    const text = (await evaluateWordParts(stringPart.value, context)).join(" ");
                    currentText += text;
                    continue;
                }
            case "command":
            default:
                throw new Error(`Not implemented: ${stringPart.kind}`);
        }
        if (evaluationResult != null) {
            const parts = evaluationResult.split(" ").map((t)=>t.trim()).filter((t)=>t.length > 0);
            if (parts.length > 0) {
                currentText += parts[0];
                result.push(currentText);
                result.push(...parts.slice(1));
                currentText = result.pop();
            }
        }
    }
    if (currentText.length !== 0) {
        result.push(currentText);
    }
    return result;
}
const PERIOD_CHAR_CODE = ".".charCodeAt(0);
function createPathRef(path) {
    if (path instanceof PathRef) {
        return path;
    } else {
        return new PathRef(path);
    }
}
class PathRef {
    #path;
    #knownResolved = false;
    static instanceofSymbol = Symbol.for("dax.PathRef");
    constructor(path){
        if (path instanceof URL) {
            this.#path = mod8.fromFileUrl(path);
        } else if (path instanceof PathRef) {
            this.#path = path.toString();
        } else if (typeof path === "string") {
            if (path.startsWith("file://")) {
                this.#path = mod8.fromFileUrl(path);
            } else {
                this.#path = path;
            }
        } else {
            this.#path = mod8.fromFileUrl(path.url);
        }
    }
    static [Symbol.hasInstance](instance) {
        return instance?.constructor?.instanceofSymbol === PathRef.instanceofSymbol;
    }
    [Symbol.for("Deno.customInspect")]() {
        return `PathRef("${this.#path}")`;
    }
    toString() {
        return this.#path;
    }
    toFileUrl() {
        const resolvedPath = this.resolve();
        return mod8.toFileUrl(resolvedPath.toString());
    }
    equals(otherPath) {
        return this.resolve().toString() === otherPath.resolve().toString();
    }
    join(...pathSegments) {
        return new PathRef(mod8.join(this.#path, ...pathSegments));
    }
    resolve(...pathSegments) {
        if (this.#knownResolved && pathSegments.length === 0) {
            return this;
        }
        const resolvedPath = mod8.resolve(this.#path, ...pathSegments);
        if (pathSegments.length === 0 && resolvedPath === this.#path) {
            this.#knownResolved = true;
            return this;
        } else {
            const pathRef = new PathRef(resolvedPath);
            pathRef.#knownResolved = true;
            return pathRef;
        }
    }
    normalize() {
        return new PathRef(mod8.normalize(this.#path));
    }
    isDir() {
        return this.statSync()?.isDirectory ?? false;
    }
    isFile() {
        return this.statSync()?.isFile ?? false;
    }
    isSymlink() {
        return this.lstatSync()?.isSymlink ?? false;
    }
    isAbsolute() {
        return mod8.isAbsolute(this.#path);
    }
    isRelative() {
        return !this.isAbsolute();
    }
    async stat() {
        try {
            return await Deno.stat(this.#path);
        } catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                return undefined;
            } else {
                throw err;
            }
        }
    }
    statSync() {
        try {
            return Deno.statSync(this.#path);
        } catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                return undefined;
            } else {
                throw err;
            }
        }
    }
    async lstat() {
        try {
            return await Deno.lstat(this.#path);
        } catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                return undefined;
            } else {
                throw err;
            }
        }
    }
    lstatSync() {
        try {
            return Deno.lstatSync(this.#path);
        } catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                return undefined;
            } else {
                throw err;
            }
        }
    }
    dirname() {
        return mod8.dirname(this.#path);
    }
    basename() {
        return mod8.basename(this.#path);
    }
    *ancestors() {
        let ancestor = this.parent();
        while(ancestor != null){
            yield ancestor;
            ancestor = ancestor.parent();
        }
    }
    parent() {
        const resolvedPath = this.resolve();
        const dirname = resolvedPath.dirname();
        if (dirname === resolvedPath.#path) {
            return undefined;
        } else {
            return new PathRef(dirname);
        }
    }
    parentOrThrow() {
        const parent = this.parent();
        if (parent == null) {
            throw new Error(`Cannot get the parent directory of '${this.#path}'.`);
        }
        return parent;
    }
    extname() {
        const extName = mod8.extname(this.#path);
        return extName.length === 0 ? undefined : extName;
    }
    withExtname(ext) {
        const currentExt = this.extname();
        const hasLeadingPeriod = ext.charCodeAt(0) === PERIOD_CHAR_CODE;
        if (!hasLeadingPeriod) {
            ext = "." + ext;
        }
        return new PathRef(this.#path.substring(0, this.#path.length - (currentExt?.length ?? 0)) + ext);
    }
    withBasename(basename) {
        const currentBaseName = this.basename();
        return new PathRef(this.#path.substring(0, this.#path.length - currentBaseName.length) + basename);
    }
    relative(to) {
        const toPathRef = ensurePathRef(to);
        console.log(this.resolve().#path, toPathRef.resolve().#path);
        console.log(mod8.relative(this.resolve().#path, toPathRef.resolve().#path));
        return mod8.relative(this.resolve().#path, toPathRef.resolve().#path);
    }
    exists() {
        return this.lstat().then((info)=>info != null);
    }
    existsSync() {
        return this.lstatSync() != null;
    }
    realPath() {
        return Deno.realPath(this.#path).then((path)=>new PathRef(path));
    }
    realPathSync() {
        return new PathRef(Deno.realPathSync(this.#path));
    }
    async *expandGlob(glob, options) {
        const entries = mod9.expandGlob(glob, {
            root: this.resolve().toString(),
            ...options
        });
        for await (const entry of entries){
            yield this.#stdWalkEntryToDax(entry);
        }
    }
    *expandGlobSync(glob, options) {
        const entries = mod9.expandGlobSync(glob, {
            root: this.resolve().toString(),
            ...options
        });
        for (const entry of entries){
            yield this.#stdWalkEntryToDax(entry);
        }
    }
    async *walk(options) {
        for await (const entry of mod9.walk(this.resolve().toString(), options)){
            yield this.#stdWalkEntryToDax(entry);
        }
    }
    *walkSync(options) {
        for (const entry of mod9.walkSync(this.resolve().toString(), options)){
            yield this.#stdWalkEntryToDax(entry);
        }
    }
    #stdWalkEntryToDax(entry) {
        return {
            ...entry,
            path: new PathRef(entry.path)
        };
    }
    async mkdir(options) {
        await Deno.mkdir(this.#path, {
            recursive: true,
            ...options
        });
        return this;
    }
    mkdirSync(options) {
        Deno.mkdirSync(this.#path, {
            recursive: true,
            ...options
        });
        return this;
    }
    async createSymlinkTo(target, opts) {
        await createSymlink(this.#resolveCreateSymlinkOpts(target, opts));
    }
    createSymlinkToSync(target, opts) {
        createSymlinkSync(this.#resolveCreateSymlinkOpts(target, opts));
    }
    #resolveCreateSymlinkOpts(target, opts) {
        if (opts?.kind == null) {
            if (typeof target === "string") {
                return {
                    fromPath: this.resolve(),
                    targetPath: ensurePathRef(target),
                    text: target,
                    type: opts?.type
                };
            } else {
                throw new Error("Please specify if this symlink is absolute or relative. Otherwise provide the target text.");
            }
        }
        const targetPath = ensurePathRef(target).resolve();
        if (opts?.kind === "relative") {
            const fromPath = this.resolve();
            let relativePath;
            if (fromPath.dirname() === targetPath.dirname()) {
                relativePath = targetPath.basename();
            } else {
                relativePath = fromPath.relative(targetPath);
            }
            return {
                fromPath,
                targetPath,
                text: relativePath,
                type: opts?.type
            };
        } else {
            return {
                fromPath: this.resolve(),
                targetPath,
                text: targetPath.#path,
                type: opts?.type
            };
        }
    }
    async *readDir() {
        const dir = this.resolve();
        for await (const entry of Deno.readDir(dir.#path)){
            yield {
                ...entry,
                path: dir.join(entry.name)
            };
        }
    }
    *readDirSync() {
        const dir = this.resolve();
        for (const entry of Deno.readDirSync(dir.#path)){
            yield {
                ...entry,
                path: dir.join(entry.name)
            };
        }
    }
    async *readDirFilePaths() {
        const dir = this.resolve();
        for await (const entry of Deno.readDir(dir.#path)){
            if (entry.isFile) {
                yield dir.join(entry.name);
            }
        }
    }
    *readDirFilePathsSync() {
        const dir = this.resolve();
        for (const entry of Deno.readDirSync(dir.#path)){
            if (entry.isFile) {
                yield dir.join(entry.name);
            }
        }
    }
    readBytes(options) {
        return Deno.readFile(this.#path, options);
    }
    readBytesSync() {
        return Deno.readFileSync(this.#path);
    }
    readMaybeBytes(options) {
        return notFoundToUndefined(()=>this.readBytes(options));
    }
    readMaybeBytesSync() {
        return notFoundToUndefinedSync(()=>this.readBytesSync());
    }
    readText(options) {
        return Deno.readTextFile(this.#path, options);
    }
    readTextSync() {
        return Deno.readTextFileSync(this.#path);
    }
    readMaybeText(options) {
        return notFoundToUndefined(()=>this.readText(options));
    }
    readMaybeTextSync() {
        return notFoundToUndefinedSync(()=>this.readTextSync());
    }
    async readJson(options) {
        return this.#parseJson(await this.readText(options));
    }
    readJsonSync() {
        return this.#parseJson(this.readTextSync());
    }
    #parseJson(text) {
        try {
            return JSON.parse(text);
        } catch (err) {
            throw new Error(`Failed parsing JSON in '${this.toString()}'.`, {
                cause: err
            });
        }
    }
    readMaybeJson(options) {
        return notFoundToUndefined(()=>this.readJson(options));
    }
    readMaybeJsonSync() {
        return notFoundToUndefinedSync(()=>this.readJsonSync());
    }
    async write(data, options) {
        await this.#withFileForWriting(options, (file)=>file.write(data));
        return this;
    }
    writeSync(data, options) {
        this.#withFileForWritingSync(options, (file)=>{
            file.writeSync(data);
        });
        return this;
    }
    async writeText(text, options) {
        await this.#withFileForWriting(options, (file)=>file.writeText(text));
        return this;
    }
    writeTextSync(text, options) {
        this.#withFileForWritingSync(options, (file)=>{
            file.writeTextSync(text);
        });
        return this;
    }
    async writeJson(obj, options) {
        const text = JSON.stringify(obj);
        await this.#writeTextWithEndNewLine(text, options);
        return this;
    }
    writeJsonSync(obj, options) {
        const text = JSON.stringify(obj);
        this.#writeTextWithEndNewLineSync(text, options);
        return this;
    }
    async writeJsonPretty(obj, options) {
        const text = JSON.stringify(obj, undefined, 2);
        await this.#writeTextWithEndNewLine(text, options);
        return this;
    }
    writeJsonPrettySync(obj, options) {
        const text = JSON.stringify(obj, undefined, 2);
        this.#writeTextWithEndNewLineSync(text, options);
        return this;
    }
    #writeTextWithEndNewLine(text, options) {
        return this.#withFileForWriting(options, async (file)=>{
            await file.writeText(text);
            await file.writeText("\n");
        });
    }
    async #withFileForWriting(options, action) {
        const file = await this.#openFileForWriting(options);
        try {
            return await action(file);
        } finally{
            try {
                file.close();
            } catch  {}
        }
    }
    async #openFileForWriting(options) {
        const resolvedPath = this.resolve();
        try {
            return await resolvedPath.open({
                write: true,
                create: true,
                truncate: true,
                ...options
            });
        } catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                const parent = resolvedPath.parent();
                if (parent != null) {
                    try {
                        await parent.mkdir();
                    } catch  {
                        throw err;
                    }
                }
                return await resolvedPath.open({
                    write: true,
                    create: true,
                    truncate: true,
                    ...options
                });
            } else {
                throw err;
            }
        }
    }
    #writeTextWithEndNewLineSync(text, options) {
        this.#withFileForWritingSync(options, (file)=>{
            file.writeTextSync(text);
            file.writeTextSync("\n");
        });
    }
    #withFileForWritingSync(options, action) {
        const file = this.#openFileForWritingSync(options);
        try {
            return action(file);
        } finally{
            try {
                file.close();
            } catch  {}
        }
    }
    #openFileForWritingSync(options) {
        try {
            return this.openSync({
                write: true,
                create: true,
                truncate: true,
                ...options
            });
        } catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                const parent = this.resolve().parent();
                if (parent != null) {
                    try {
                        parent.mkdirSync();
                    } catch  {
                        throw err;
                    }
                }
                return this.openSync({
                    write: true,
                    create: true,
                    truncate: true,
                    ...options
                });
            } else {
                throw err;
            }
        }
    }
    async chmod(mode) {
        await Deno.chmod(this.#path, mode);
        return this;
    }
    chmodSync(mode) {
        Deno.chmodSync(this.#path, mode);
        return this;
    }
    async chown(uid, gid) {
        await Deno.chown(this.#path, uid, gid);
        return this;
    }
    chownSync(uid, gid) {
        Deno.chownSync(this.#path, uid, gid);
        return this;
    }
    create() {
        return Deno.create(this.#path).then((file)=>new FsFileWrapper(file));
    }
    createSync() {
        return new FsFileWrapper(Deno.createSync(this.#path));
    }
    createNew() {
        return this.open({
            createNew: true,
            read: true,
            write: true
        });
    }
    createNewSync() {
        return this.openSync({
            createNew: true,
            read: true,
            write: true
        });
    }
    open(options) {
        return Deno.open(this.#path, options).then((file)=>new FsFileWrapper(file));
    }
    openSync(options) {
        return new FsFileWrapper(Deno.openSync(this.#path, options));
    }
    async remove(options) {
        await Deno.remove(this.#path, options);
        return this;
    }
    removeSync(options) {
        Deno.removeSync(this.#path, options);
        return this;
    }
    async emptyDir() {
        await mod9.emptyDir(this.toString());
        return this;
    }
    emptyDirSync() {
        mod9.emptyDirSync(this.toString());
        return this;
    }
    copyFile(destinationPath) {
        const pathRef = ensurePathRef(destinationPath);
        return Deno.copyFile(this.#path, pathRef.#path).then(()=>pathRef);
    }
    copyFileSync(destinationPath) {
        const pathRef = ensurePathRef(destinationPath);
        Deno.copyFileSync(this.#path, pathRef.#path);
        return pathRef;
    }
    copyFileToDir(destinationDirPath) {
        const destinationPath = ensurePathRef(destinationDirPath).join(this.basename());
        return this.copyFile(destinationPath);
    }
    copyFileToDirSync(destinationDirPath) {
        const destinationPath = ensurePathRef(destinationDirPath).join(this.basename());
        return this.copyFileSync(destinationPath);
    }
    rename(newPath) {
        const pathRef = ensurePathRef(newPath);
        return Deno.rename(this.#path, pathRef.#path).then(()=>pathRef);
    }
    renameSync(newPath) {
        const pathRef = ensurePathRef(newPath);
        Deno.renameSync(this.#path, pathRef.#path);
        return pathRef;
    }
    async pipeTo(dest, options) {
        const file = await Deno.open(this.#path, {
            read: true
        });
        try {
            await file.readable.pipeTo(dest, options);
        } finally{
            try {
                file.close();
            } catch  {}
        }
        return this;
    }
}
function ensurePathRef(path) {
    return path instanceof PathRef ? path : new PathRef(path);
}
async function createSymlink(opts) {
    let kind = opts.type;
    if (kind == null && Deno.build.os === "windows") {
        const info = await opts.targetPath.lstat();
        if (info?.isDirectory) {
            kind = "dir";
        } else if (info?.isFile) {
            kind = "file";
        } else {
            throw new Deno.errors.NotFound(`The target path '${opts.targetPath}' did not exist or path kind could not be determined. ` + `When the path doesn't exist, you need to specify a symlink type on Windows.`);
        }
    }
    await Deno.symlink(opts.text, opts.fromPath.toString(), kind == null ? undefined : {
        type: kind
    });
}
function createSymlinkSync(opts) {
    let kind = opts.type;
    if (kind == null && Deno.build.os === "windows") {
        const info = opts.targetPath.lstatSync();
        if (info?.isDirectory) {
            kind = "dir";
        } else if (info?.isFile) {
            kind = "file";
        } else {
            throw new Deno.errors.NotFound(`The target path '${opts.targetPath}' did not exist or path kind could not be determined. ` + `When the path doesn't exist, you need to specify a symlink type on Windows.`);
        }
    }
    Deno.symlinkSync(opts.text, opts.fromPath.toString(), kind == null ? undefined : {
        type: kind
    });
}
class FsFileWrapper {
    #file;
    constructor(file){
        this.#file = file;
    }
    get inner() {
        return this.#file;
    }
    writeText(text) {
        return this.writeBytes(new TextEncoder().encode(text));
    }
    writeTextSync(text) {
        return this.writeBytesSync(new TextEncoder().encode(text));
    }
    async writeBytes(bytes) {
        await writeAll(this.#file, bytes);
        return this;
    }
    writeBytesSync(bytes) {
        writeAllSync(this.#file, bytes);
        return this;
    }
    get rid() {
        return this.#file.rid;
    }
    get readable() {
        return this.#file.readable;
    }
    get writable() {
        return this.#file.writable;
    }
    write(p) {
        return this.#file.write(p);
    }
    writeSync(p) {
        return this.#file.writeSync(p);
    }
    truncate(len) {
        return this.#file.truncate(len);
    }
    truncateSync(len) {
        return this.#file.truncateSync(len);
    }
    read(p) {
        return this.#file.read(p);
    }
    readSync(p) {
        return this.#file.readSync(p);
    }
    seek(offset, whence) {
        return this.#file.seek(offset, whence);
    }
    seekSync(offset, whence) {
        return this.#file.seekSync(offset, whence);
    }
    stat() {
        return this.#file.stat();
    }
    statSync() {
        return this.#file.statSync();
    }
    close() {
        return this.#file.close();
    }
}
async function notFoundToUndefined(action) {
    try {
        return await action();
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return undefined;
        } else {
            throw err;
        }
    }
}
function notFoundToUndefinedSync(action) {
    try {
        return action();
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return undefined;
        } else {
            throw err;
        }
    }
}
const textDecoder = new TextDecoder();
const builtInCommands = {
    cd: cdCommand,
    printenv: printEnvCommand,
    echo: echoCommand,
    cat: catCommand,
    exit: exitCommand,
    export: exportCommand,
    sleep: sleepCommand,
    test: testCommand,
    rm: rmCommand,
    mkdir: mkdirCommand,
    cp: cpCommand,
    mv: mvCommand,
    pwd: pwdCommand,
    touch: touchCommand,
    unset: unsetCommand
};
const getRegisteredCommandNamesSymbol = Symbol();
class CommandBuilder {
    #state = {
        command: undefined,
        combinedStdoutStderr: false,
        stdin: "inherit",
        stdoutKind: "inherit",
        stderrKind: "inherit",
        noThrow: false,
        env: {},
        cwd: undefined,
        commands: {
            ...builtInCommands
        },
        exportEnv: false,
        printCommand: false,
        printCommandLogger: new LoggerTreeBox(console.error),
        timeout: undefined
    };
    #getClonedState() {
        const state = this.#state;
        return {
            command: state.command,
            combinedStdoutStderr: state.combinedStdoutStderr,
            stdin: state.stdin,
            stdoutKind: state.stdoutKind,
            stderrKind: state.stderrKind,
            noThrow: state.noThrow,
            env: {
                ...state.env
            },
            cwd: state.cwd,
            commands: {
                ...state.commands
            },
            exportEnv: state.exportEnv,
            printCommand: state.printCommand,
            printCommandLogger: state.printCommandLogger.createChild(),
            timeout: state.timeout
        };
    }
    #newWithState(action) {
        const builder = new CommandBuilder();
        const state = this.#getClonedState();
        action(state);
        builder.#state = state;
        return builder;
    }
    then(onfulfilled, onrejected) {
        return this.spawn().then(onfulfilled).catch(onrejected);
    }
    spawn() {
        return parseAndSpawnCommand(this.#getClonedState());
    }
    registerCommand(command, handleFn) {
        validateCommandName(command);
        return this.#newWithState((state)=>{
            state.commands[command] = handleFn;
        });
    }
    registerCommands(commands) {
        let command = this;
        for (const [key, value1] of Object.entries(commands)){
            command = command.registerCommand(key, value1);
        }
        return command;
    }
    unregisterCommand(command) {
        return this.#newWithState((state)=>{
            delete state.commands[command];
        });
    }
    command(command) {
        return this.#newWithState((state)=>{
            if (typeof command === "string") {
                state.command = command;
            } else {
                state.command = command.map(escapeArg).join(" ");
            }
        });
    }
    noThrow(value1 = true) {
        return this.#newWithState((state)=>{
            state.noThrow = value1;
        });
    }
    captureCombined(value1 = true) {
        return this.#newWithState((state)=>{
            state.combinedStdoutStderr = value1;
            if (value1) {
                if (state.stdoutKind !== "piped" && state.stdoutKind !== "inheritPiped") {
                    state.stdoutKind = "piped";
                }
                if (state.stderrKind !== "piped" && state.stderrKind !== "inheritPiped") {
                    state.stderrKind = "piped";
                }
            }
        });
    }
    stdin(reader) {
        return this.#newWithState((state)=>{
            if (reader === "inherit" || reader === "null") {
                state.stdin = reader;
            } else if (reader instanceof Uint8Array) {
                state.stdin = new Box(new Buffer1(reader));
            } else {
                state.stdin = new Box(reader);
            }
        });
    }
    stdinText(text) {
        return this.stdin(new TextEncoder().encode(text));
    }
    stdout(kind) {
        return this.#newWithState((state)=>{
            if (state.combinedStdoutStderr && kind !== "piped" && kind !== "inheritPiped") {
                throw new Error("Cannot set stdout's kind to anything but 'piped' or 'inheritPiped' when combined is true.");
            }
            state.stdoutKind = kind;
        });
    }
    stderr(kind) {
        return this.#newWithState((state)=>{
            if (state.combinedStdoutStderr && kind !== "piped" && kind !== "inheritPiped") {
                throw new Error("Cannot set stderr's kind to anything but 'piped' or 'inheritPiped' when combined is true.");
            }
            state.stderrKind = kind;
        });
    }
    env(nameOrItems, value1) {
        return this.#newWithState((state)=>{
            if (typeof nameOrItems === "string") {
                setEnv(state, nameOrItems, value1);
            } else {
                for (const [key, value1] of Object.entries(nameOrItems)){
                    setEnv(state, key, value1);
                }
            }
        });
        function setEnv(state, key, value1) {
            if (Deno.build.os === "windows") {
                key = key.toUpperCase();
            }
            state.env[key] = value1;
        }
    }
    cwd(dirPath) {
        return this.#newWithState((state)=>{
            state.cwd = dirPath instanceof URL ? mod8.fromFileUrl(dirPath) : dirPath instanceof PathRef ? dirPath.resolve().toString() : mod8.resolve(dirPath);
        });
    }
    exportEnv(value1 = true) {
        return this.#newWithState((state)=>{
            state.exportEnv = value1;
        });
    }
    printCommand(value1 = true) {
        return this.#newWithState((state)=>{
            state.printCommand = value1;
        });
    }
    setPrintCommandLogger(logger) {
        this.#state.printCommandLogger.setValue(logger);
    }
    quiet(kind = "both") {
        return this.#newWithState((state)=>{
            if (kind === "both" || kind === "stdout") {
                state.stdoutKind = getQuietKind(state.stdoutKind);
            }
            if (kind === "both" || kind === "stderr") {
                state.stderrKind = getQuietKind(state.stderrKind);
            }
        });
        function getQuietKind(kind) {
            switch(kind){
                case "inheritPiped":
                case "inherit":
                    return "piped";
                case "null":
                case "piped":
                    return kind;
                default:
                    {
                        throw new Error(`Unhandled kind ${kind}.`);
                    }
            }
        }
    }
    timeout(delay) {
        return this.#newWithState((state)=>{
            state.timeout = delay == null ? undefined : delayToMs(delay);
        });
    }
    async bytes() {
        return (await this.quiet("stdout")).stdoutBytes;
    }
    async text() {
        return (await this.quiet("stdout")).stdout.replace(/\r?\n$/, "");
    }
    async lines() {
        const text = await this.text();
        return text.split(/\r?\n/g);
    }
    async json() {
        return (await this.quiet("stdout")).stdoutJson;
    }
    [getRegisteredCommandNamesSymbol]() {
        return Object.keys(this.#state.commands);
    }
}
class CommandChild extends Promise {
    #pipedStdoutBuffer;
    #pipedStderrBuffer;
    #abortController;
    constructor(executor, options = {
        pipedStderrBuffer: undefined,
        pipedStdoutBuffer: undefined,
        abortController: undefined
    }){
        super(executor);
        this.#pipedStdoutBuffer = options.pipedStdoutBuffer;
        this.#pipedStderrBuffer = options.pipedStderrBuffer;
        this.#abortController = options.abortController;
    }
    abort() {
        this.#abortController?.abort();
    }
    stdout() {
        const buffer = this.#pipedStdoutBuffer;
        this.#assertBufferStreamable("stdout", buffer);
        this.#pipedStdoutBuffer = "consumed";
        this.catch(()=>{});
        return this.#bufferToStream(buffer);
    }
    stderr() {
        const buffer = this.#pipedStderrBuffer;
        this.#assertBufferStreamable("stderr", buffer);
        this.#pipedStderrBuffer = "consumed";
        this.catch(()=>{});
        return this.#bufferToStream(buffer);
    }
    #assertBufferStreamable(name, buffer) {
        if (buffer == null) {
            throw new Error(`No pipe available. Ensure ${name} is "piped" (not "inheritPiped") and combinedOutput is not enabled.`);
        }
        if (buffer === "consumed") {
            throw new Error(`Streamable ${name} was already consumed. Use the previously acquired stream instead.`);
        }
    }
    #bufferToStream(buffer) {
        return new ReadableStream({
            start (controller) {
                buffer.setListener({
                    writeSync (data) {
                        controller.enqueue(data);
                        return data.length;
                    },
                    setError (err) {
                        controller.error(err);
                    },
                    close () {
                        controller.close();
                    }
                });
            }
        });
    }
}
function parseAndSpawnCommand(state) {
    if (state.command == null) {
        throw new Error("A command must be set before it can be spawned.");
    }
    if (state.printCommand) {
        state.printCommandLogger.getValue()(mod5.white(">"), mod5.blue(state.command));
    }
    const [stdoutBuffer, stderrBuffer, combinedBuffer] = getBuffers();
    const stdout = new ShellPipeWriter(state.stdoutKind, stdoutBuffer === "null" ? new NullPipeWriter() : stdoutBuffer === "inherit" ? Deno.stdout : stdoutBuffer);
    const stderr = new ShellPipeWriter(state.stderrKind, stderrBuffer === "null" ? new NullPipeWriter() : stderrBuffer === "inherit" ? Deno.stderr : stderrBuffer);
    const abortController = new AbortController();
    const abortSignal = abortController.signal;
    let timeoutId;
    let timedOut = false;
    if (state.timeout != null) {
        timeoutId = setTimeout(()=>{
            timedOut = true;
            abortController.abort();
        }, state.timeout);
    }
    const command = state.command;
    return new CommandChild(async (resolve, reject)=>{
        try {
            const list = parseCommand(command);
            const stdin = takeStdin();
            const code = await spawn(list, {
                stdin: stdin instanceof ReadableStream ? readerFromStreamReader(stdin.getReader()) : stdin,
                stdout,
                stderr,
                env: buildEnv(state.env),
                commands: state.commands,
                cwd: state.cwd ?? Deno.cwd(),
                exportEnv: state.exportEnv,
                signal: abortSignal
            });
            if (code !== 0 && !state.noThrow) {
                if (stdin instanceof ReadableStream) {
                    if (!stdin.locked) {
                        stdin.cancel();
                    }
                }
                if (abortSignal.aborted) {
                    throw new Error(`${timedOut ? "Timed out" : "Aborted"} with exit code: ${code}`);
                } else {
                    throw new Error(`Exited with code: ${code}`);
                }
            }
            resolve(new CommandResult(code, finalizeCommandResultBuffer(stdoutBuffer), finalizeCommandResultBuffer(stderrBuffer), combinedBuffer instanceof Buffer1 ? combinedBuffer : undefined));
        } catch (err) {
            finalizeCommandResultBufferForError(stdoutBuffer, err);
            finalizeCommandResultBufferForError(stderrBuffer, err);
            reject(err);
        } finally{
            if (timeoutId != null) {
                clearTimeout(timeoutId);
            }
        }
    }, {
        pipedStdoutBuffer: stdoutBuffer instanceof PipedBuffer ? stdoutBuffer : undefined,
        pipedStderrBuffer: stderrBuffer instanceof PipedBuffer ? stderrBuffer : undefined,
        abortController
    });
    function takeStdin() {
        if (state.stdin instanceof Box) {
            const stdin = state.stdin.value;
            if (stdin === "consumed") {
                throw new Error("Cannot spawn command. Stdin was already consumed when a previous command using " + "the same stdin was spawned. You need to call `.stdin(...)` again with a new " + "value before spawning.");
            }
            state.stdin.value = "consumed";
            return stdin;
        } else {
            return state.stdin;
        }
    }
    function getBuffers() {
        const hasProgressBars = isShowingProgressBars();
        const stdoutBuffer = getOutputBuffer(Deno.stdout, state.stdoutKind);
        const stderrBuffer = getOutputBuffer(Deno.stderr, state.stderrKind);
        if (state.combinedStdoutStderr) {
            if (typeof stdoutBuffer === "string" || typeof stderrBuffer === "string") {
                throw new Error("Internal programming error. Expected writers for stdout and stderr.");
            }
            const combinedBuffer = new Buffer1();
            return [
                new CapturingBufferWriter(stdoutBuffer, combinedBuffer),
                new CapturingBufferWriter(stderrBuffer, combinedBuffer),
                combinedBuffer
            ];
        }
        return [
            stdoutBuffer,
            stderrBuffer,
            undefined
        ];
        function getOutputBuffer(innerWriter, kind) {
            switch(kind){
                case "inherit":
                    if (hasProgressBars) {
                        return new InheritStaticTextBypassWriter(innerWriter);
                    } else {
                        return "inherit";
                    }
                case "piped":
                    return new PipedBuffer();
                case "inheritPiped":
                    return new CapturingBufferWriter(innerWriter, new Buffer1());
                case "null":
                    return "null";
                default:
                    {
                        throw new Error("Unhandled.");
                    }
            }
        }
    }
    function finalizeCommandResultBuffer(buffer) {
        if (buffer instanceof CapturingBufferWriter) {
            return buffer.getBuffer();
        } else if (buffer instanceof InheritStaticTextBypassWriter) {
            buffer.flush();
            return "inherit";
        } else if (buffer instanceof PipedBuffer) {
            buffer.close();
            return buffer.getBuffer() ?? "streamed";
        } else {
            return buffer;
        }
    }
    function finalizeCommandResultBufferForError(buffer, error) {
        if (buffer instanceof InheritStaticTextBypassWriter) {
            buffer.flush();
        } else if (buffer instanceof PipedBuffer) {
            buffer.setError(error);
        }
    }
}
class CommandResult {
    #stdout;
    #stderr;
    #combined;
    code;
    constructor(code, stdout, stderr, combined){
        this.code = code;
        this.#stdout = stdout;
        this.#stderr = stderr;
        this.#combined = combined;
    }
    #memoizedStdout;
    get stdout() {
        if (!this.#memoizedStdout) {
            this.#memoizedStdout = textDecoder.decode(this.stdoutBytes);
        }
        return this.#memoizedStdout;
    }
    #memoizedStdoutJson;
    get stdoutJson() {
        if (this.#memoizedStdoutJson == null) {
            this.#memoizedStdoutJson = JSON.parse(this.stdout);
        }
        return this.#memoizedStdoutJson;
    }
    get stdoutBytes() {
        if (this.#stdout === "streamed") {
            throw new Error(`Stdout was streamed to another source and is no longer available.`);
        }
        if (typeof this.#stdout === "string") {
            throw new Error(`Stdout was not piped (was ${this.#stdout}). Call .stdout("piped") or .stdout("capture") when building the command.`);
        }
        return this.#stdout.bytes({
            copy: false
        });
    }
    #memoizedStderr;
    get stderr() {
        if (!this.#memoizedStderr) {
            this.#memoizedStderr = textDecoder.decode(this.stderrBytes);
        }
        return this.#memoizedStderr;
    }
    #memoizedStderrJson;
    get stderrJson() {
        if (this.#memoizedStderrJson == null) {
            this.#memoizedStderrJson = JSON.parse(this.stderr);
        }
        return this.#memoizedStderrJson;
    }
    get stderrBytes() {
        if (this.#stdout === "streamed") {
            throw new Error(`Stderr was streamed to another source and is no longer available.`);
        }
        if (typeof this.#stderr === "string") {
            throw new Error(`Stderr was not piped (was ${this.#stderr}). Call .stderr("piped") or .stderr("capture") when building the command.`);
        }
        return this.#stderr.bytes({
            copy: false
        });
    }
    #memoizedCombined;
    get combined() {
        if (!this.#memoizedCombined) {
            this.#memoizedCombined = textDecoder.decode(this.combinedBytes);
        }
        return this.#memoizedCombined;
    }
    get combinedBytes() {
        if (this.#combined == null) {
            throw new Error("Stdout and stderr were not combined. Call .captureCombined() when building the command.");
        }
        return this.#combined.bytes({
            copy: false
        });
    }
}
function buildEnv(env) {
    const result = Deno.env.toObject();
    for (const [key, value1] of Object.entries(env)){
        if (value1 == null) {
            delete result[key];
        } else {
            result[key] = value1;
        }
    }
    return result;
}
function escapeArg(arg) {
    if (/^[A-Za-z0-9]*$/.test(arg)) {
        return arg;
    } else {
        return `'${arg.replace("'", `'"'"'`)}'`;
    }
}
function validateCommandName(command) {
    if (command.match(/^[a-zA-Z0-9-_]+$/) == null) {
        throw new Error("Invalid command name");
    }
}
const withProgressBarFactorySymbol = Symbol();
class RequestBuilder {
    #state = undefined;
    #getClonedState() {
        const state = this.#state;
        if (state == null) {
            return this.#getDefaultState();
        }
        return {
            noThrow: typeof state.noThrow === "boolean" ? state.noThrow : [
                ...state.noThrow
            ],
            url: state.url,
            body: state.body,
            cache: state.cache,
            headers: state.headers,
            integrity: state.integrity,
            keepalive: state.keepalive,
            method: state.method,
            mode: state.mode,
            redirect: state.redirect,
            referrer: state.referrer,
            referrerPolicy: state.referrerPolicy,
            progressBarFactory: state.progressBarFactory,
            progressOptions: state.progressOptions == null ? undefined : {
                ...state.progressOptions
            },
            timeout: state.timeout
        };
    }
    #getDefaultState() {
        return {
            noThrow: false,
            url: undefined,
            body: undefined,
            cache: undefined,
            headers: {},
            integrity: undefined,
            keepalive: undefined,
            method: undefined,
            mode: undefined,
            redirect: undefined,
            referrer: undefined,
            referrerPolicy: undefined,
            progressBarFactory: undefined,
            progressOptions: undefined,
            timeout: undefined
        };
    }
    #newWithState(action) {
        const builder = new RequestBuilder();
        const state = this.#getClonedState();
        action(state);
        builder.#state = state;
        return builder;
    }
    then(onfulfilled, onrejected) {
        return this.fetch().then(onfulfilled).catch(onrejected);
    }
    fetch() {
        return makeRequest(this.#getClonedState());
    }
    url(value1) {
        return this.#newWithState((state)=>{
            state.url = value1;
        });
    }
    header(nameOrItems, value1) {
        return this.#newWithState((state)=>{
            if (typeof nameOrItems === "string") {
                setHeader(state, nameOrItems, value1);
            } else {
                for (const [name, value1] of Object.entries(nameOrItems)){
                    setHeader(state, name, value1);
                }
            }
        });
        function setHeader(state, name, value1) {
            name = name.toUpperCase();
            state.headers[name] = value1;
        }
    }
    noThrow(value1, ...additional) {
        return this.#newWithState((state)=>{
            if (typeof value1 === "boolean" || value1 == null) {
                state.noThrow = value1 ?? true;
            } else {
                state.noThrow = [
                    value1,
                    ...additional
                ];
            }
        });
    }
    body(value1) {
        return this.#newWithState((state)=>{
            state.body = value1;
        });
    }
    cache(value1) {
        return this.#newWithState((state)=>{
            state.cache = value1;
        });
    }
    integrity(value1) {
        return this.#newWithState((state)=>{
            state.integrity = value1;
        });
    }
    keepalive(value1) {
        return this.#newWithState((state)=>{
            state.keepalive = value1;
        });
    }
    method(value1) {
        return this.#newWithState((state)=>{
            state.method = value1;
        });
    }
    mode(value1) {
        return this.#newWithState((state)=>{
            state.mode = value1;
        });
    }
    [withProgressBarFactorySymbol](factory) {
        return this.#newWithState((state)=>{
            state.progressBarFactory = factory;
        });
    }
    redirect(value1) {
        return this.#newWithState((state)=>{
            state.redirect = value1;
        });
    }
    referrer(value1) {
        return this.#newWithState((state)=>{
            state.referrer = value1;
        });
    }
    referrerPolicy(value1) {
        return this.#newWithState((state)=>{
            state.referrerPolicy = value1;
        });
    }
    showProgress(value1) {
        return this.#newWithState((state)=>{
            if (value1 === true || value1 == null) {
                state.progressOptions = {
                    noClear: false
                };
            } else if (value1 === false) {
                state.progressOptions = undefined;
            } else {
                state.progressOptions = {
                    noClear: value1.noClear ?? false
                };
            }
        });
    }
    timeout(delay) {
        return this.#newWithState((state)=>{
            state.timeout = delay == null ? undefined : delayToMs(delay);
        });
    }
    async arrayBuffer() {
        const response = await this.fetch();
        return response.arrayBuffer();
    }
    async blob() {
        const response = await this.fetch();
        return response.blob();
    }
    async formData() {
        const response = await this.fetch();
        return response.formData();
    }
    async json() {
        let builder = this;
        const acceptHeaderName = "ACCEPT";
        if (builder.#state == null || !Object.hasOwn(builder.#state.headers, acceptHeaderName)) {
            builder = builder.header(acceptHeaderName, "application/json");
        }
        const response = await builder.fetch();
        return response.json();
    }
    async text() {
        const response = await this.fetch();
        return response.text();
    }
    async pipeTo(dest, options) {
        const response = await this.fetch();
        return await response.pipeTo(dest, options);
    }
    async pipeToPath(filePathOrOptions, maybeOptions) {
        const { filePath, options } = resolvePipeToPathParams(filePathOrOptions, maybeOptions, this.#state?.url);
        const response = await this.fetch();
        return await response.pipeToPath(filePath, options);
    }
    async pipeThrough(transform) {
        const response = await this.fetch();
        return response.pipeThrough(transform);
    }
}
class RequestResult {
    #response;
    #downloadResponse;
    #originalUrl;
    constructor(opts){
        this.#originalUrl = opts.originalUrl;
        this.#response = opts.response;
        if (opts.progressBar != null) {
            const pb = opts.progressBar;
            this.#downloadResponse = new Response(new ReadableStream({
                async start (controller) {
                    const reader = opts.response.body?.getReader();
                    if (reader == null) {
                        return;
                    }
                    try {
                        while(true){
                            const { done, value: value1 } = await reader.read();
                            if (done || value1 == null) break;
                            pb.increment(value1.byteLength);
                            controller.enqueue(value1);
                        }
                        controller.close();
                    } finally{
                        reader.releaseLock();
                        pb.finish();
                    }
                }
            }));
        } else {
            this.#downloadResponse = opts.response;
        }
    }
    get response() {
        return this.#response;
    }
    get headers() {
        return this.#response.headers;
    }
    get ok() {
        return this.#response.ok;
    }
    get redirected() {
        return this.#response.redirected;
    }
    get status() {
        return this.#response.status;
    }
    get statusText() {
        return this.#response.statusText;
    }
    get url() {
        return this.#response.url;
    }
    throwIfNotOk() {
        if (!this.ok) {
            this.#response.body?.cancel().catch(()=>{});
            throw new Error(`Error making request to ${this.#originalUrl}: ${this.statusText}`);
        }
    }
    async arrayBuffer() {
        if (this.#response.status === 404) {
            await this.#response.body?.cancel();
            return undefined;
        }
        return this.#downloadResponse.arrayBuffer();
    }
    async blob() {
        if (this.#response.status === 404) {
            await this.#response.body?.cancel();
            return undefined;
        }
        return this.#downloadResponse.blob();
    }
    async formData() {
        if (this.#response.status === 404) {
            await this.#response.body?.cancel();
            return undefined;
        }
        return this.#downloadResponse.formData();
    }
    async json() {
        if (this.#response.status === 404) {
            await this.#response.body?.cancel();
            return undefined;
        }
        return this.#downloadResponse.json();
    }
    async text() {
        if (this.#response.status === 404) {
            await this.#response.body?.cancel();
            return undefined;
        }
        return this.#downloadResponse.text();
    }
    pipeTo(dest, options) {
        return this.#getDownloadBody().pipeTo(dest, options);
    }
    async pipeToPath(filePathOrOptions, maybeOptions) {
        const { filePath, options } = resolvePipeToPathParams(filePathOrOptions, maybeOptions, this.#originalUrl);
        const body = this.#getDownloadBody();
        try {
            const file = await filePath.open({
                write: true,
                create: true,
                ...options ?? {}
            });
            try {
                await body.pipeTo(file.writable, {
                    preventClose: true
                });
            } finally{
                try {
                    file.close();
                } catch  {}
            }
        } catch (err) {
            await this.#response.body?.cancel();
            throw err;
        }
        return filePath;
    }
    pipeThrough(transform) {
        return this.#getDownloadBody().pipeThrough(transform);
    }
    #getDownloadBody() {
        const body = this.#downloadResponse.body;
        if (body == null) {
            throw new Error("Response had no body.");
        }
        return body;
    }
}
async function makeRequest(state) {
    if (state.url == null) {
        throw new Error("You must specify a URL before fetching.");
    }
    const timeout = getTimeout();
    const response = await fetch(state.url, {
        body: state.body,
        cache: state.cache,
        headers: filterEmptyRecordValues(state.headers),
        integrity: state.integrity,
        keepalive: state.keepalive,
        method: state.method,
        mode: state.mode,
        redirect: state.redirect,
        referrer: state.referrer,
        referrerPolicy: state.referrerPolicy,
        signal: timeout?.signal
    });
    timeout?.clear();
    const result = new RequestResult({
        response,
        originalUrl: state.url.toString(),
        progressBar: getProgressBar()
    });
    if (!state.noThrow) {
        result.throwIfNotOk();
    } else if (state.noThrow instanceof Array) {
        if (!state.noThrow.includes(response.status)) {
            result.throwIfNotOk();
        }
    }
    return result;
    function getProgressBar() {
        if (state.progressOptions == null || state.progressBarFactory == null) {
            return undefined;
        }
        return state.progressBarFactory(`Download ${state.url}`).noClear(state.progressOptions.noClear).kind("bytes").length(getContentLength());
        function getContentLength() {
            const contentLength = response.headers.get("content-length");
            if (contentLength == null) {
                return undefined;
            }
            const length = parseInt(contentLength, 10);
            return isNaN(length) ? undefined : length;
        }
    }
    function getTimeout() {
        if (state.timeout == null) {
            return undefined;
        }
        const controller = new AbortController();
        const timeoutId = setTimeout(()=>controller.abort(), state.timeout);
        return {
            signal: controller.signal,
            clear () {
                clearTimeout(timeoutId);
            }
        };
    }
}
function resolvePipeToPathParams(pathOrOptions, maybeOptions, originalUrl) {
    let filePath;
    let options;
    if (typeof pathOrOptions === "string" || pathOrOptions instanceof URL) {
        filePath = new PathRef(pathOrOptions).resolve();
        options = maybeOptions;
    } else if (pathOrOptions instanceof PathRef) {
        filePath = pathOrOptions.resolve();
        options = maybeOptions;
    } else if (typeof pathOrOptions === "object") {
        options = pathOrOptions;
    } else if (pathOrOptions === undefined) {
        options = maybeOptions;
    }
    if (filePath === undefined) {
        filePath = new PathRef(getFileNameFromUrlOrThrow(originalUrl));
    } else if (filePath.isDir()) {
        filePath = filePath.join(getFileNameFromUrlOrThrow(originalUrl));
    }
    filePath = filePath.resolve();
    return {
        filePath,
        options
    };
    function getFileNameFromUrlOrThrow(url) {
        const fileName = url == null ? undefined : getFileNameFromUrl(url);
        if (fileName == null) {
            throw new Error("Could not derive the path from the request URL. " + "Please explicitly provide a path.");
        }
        return fileName;
    }
}
function sleep(delay) {
    const ms = delayToMs(delay);
    return new Promise((resolve)=>setTimeout(resolve, ms));
}
async function withRetries($local, errorLogger, opts) {
    const delayIterator = delayToIterator(opts.delay);
    for(let i = 0; i < opts.count; i++){
        if (i > 0) {
            const nextDelay = delayIterator.next();
            if (!opts.quiet) {
                $local.logWarn(`Failed. Trying again in ${formatMillis(nextDelay)}...`);
            }
            await sleep(nextDelay);
            if (!opts.quiet) {
                $local.logStep(`Retrying attempt ${i + 1}/${opts.count}...`);
            }
        }
        try {
            return await opts.action();
        } catch (err) {
            errorLogger(err);
        }
    }
    throw new Error(`Failed after ${opts.count} attempts.`);
}
function cd(path) {
    if (typeof path === "string" || path instanceof URL) {
        path = new PathRef(path);
    } else if (!(path instanceof PathRef)) {
        path = new PathRef(path).parentOrThrow();
    }
    Deno.chdir(path.toString());
}
function buildInitial$State(opts) {
    return {
        commandBuilder: new TreeBox(opts.commandBuilder ?? new CommandBuilder()),
        requestBuilder: opts.requestBuilder ?? new RequestBuilder(),
        infoLogger: new LoggerTreeBox(console.error),
        warnLogger: new LoggerTreeBox(console.error),
        errorLogger: new LoggerTreeBox(console.error),
        indentLevel: new Box(0),
        extras: opts.extras
    };
}
const helperObject = {
    fs: mod9,
    path: Object.assign(createPathRef, mod8),
    cd,
    escapeArg,
    stripAnsi (text) {
        return wasmInstance.strip_ansi_codes(text);
    },
    dedent: defaultOutdent,
    sleep,
    which (commandName) {
        if (commandName.toUpperCase() === "DENO") {
            return Promise.resolve(Deno.execPath());
        } else {
            return which(commandName);
        }
    },
    whichSync (commandName) {
        if (commandName.toUpperCase() === "DENO") {
            return Deno.execPath();
        } else {
            return whichSync(commandName);
        }
    }
};
function build$FromState(state) {
    const logDepthObj = {
        get logDepth () {
            return state.indentLevel.value;
        },
        set logDepth (value){
            if (value < 0 || value % 1 !== 0) {
                throw new Error("Expected a positive integer.");
            }
            state.indentLevel.value = value;
        }
    };
    const result = Object.assign((strings, ...exprs)=>{
        let result = "";
        for(let i = 0; i < Math.max(strings.length, exprs.length); i++){
            if (strings.length > i) {
                result += strings[i];
            }
            if (exprs.length > i) {
                result += templateLiteralExprToString(exprs[i], escapeArg);
            }
        }
        return state.commandBuilder.getValue().command(result);
    }, helperObject, logDepthObj, {
        build$ (opts = {}) {
            return build$FromState({
                commandBuilder: opts.commandBuilder != null ? new TreeBox(opts.commandBuilder) : state.commandBuilder.createChild(),
                requestBuilder: opts.requestBuilder ?? state.requestBuilder,
                errorLogger: state.errorLogger.createChild(),
                infoLogger: state.infoLogger.createChild(),
                warnLogger: state.warnLogger.createChild(),
                indentLevel: state.indentLevel,
                extras: {
                    ...state.extras,
                    ...opts.extras
                }
            });
        },
        log (...data) {
            state.infoLogger.getValue()(getLogText(data));
        },
        logLight (...data) {
            state.infoLogger.getValue()(mod5.gray(getLogText(data)));
        },
        logStep (firstArg, ...data) {
            logStep(firstArg, data, (t)=>mod5.bold(mod5.green(t)), state.infoLogger.getValue());
        },
        logError (firstArg, ...data) {
            logStep(firstArg, data, (t)=>mod5.bold(mod5.red(t)), state.errorLogger.getValue());
        },
        logWarn (firstArg, ...data) {
            logStep(firstArg, data, (t)=>mod5.bold(mod5.yellow(t)), state.warnLogger.getValue());
        },
        logGroup (labelOrAction, maybeAction) {
            const label = typeof labelOrAction === "string" ? labelOrAction : undefined;
            if (label) {
                state.infoLogger.getValue()(getLogText([
                    label
                ]));
            }
            state.indentLevel.value++;
            const action = label != null ? maybeAction : labelOrAction;
            if (action != null) {
                let wasPromise = false;
                try {
                    const result = action();
                    if (result instanceof Promise) {
                        wasPromise = true;
                        return result.finally(()=>{
                            if (state.indentLevel.value > 0) {
                                state.indentLevel.value--;
                            }
                        });
                    } else {
                        return result;
                    }
                } finally{
                    if (!wasPromise) {
                        if (state.indentLevel.value > 0) {
                            state.indentLevel.value--;
                        }
                    }
                }
            }
        },
        logGroupEnd () {
            if (state.indentLevel.value > 0) {
                state.indentLevel.value--;
            }
        },
        commandExists (commandName) {
            if (state.commandBuilder.getValue()[getRegisteredCommandNamesSymbol]().includes(commandName)) {
                return Promise.resolve(true);
            }
            return helperObject.which(commandName).then((c)=>c != null);
        },
        commandExistsSync (commandName) {
            if (state.commandBuilder.getValue()[getRegisteredCommandNamesSymbol]().includes(commandName)) {
                return true;
            }
            return helperObject.whichSync(commandName) != null;
        },
        maybeConfirm,
        confirm,
        maybeSelect,
        select,
        maybeMultiSelect,
        multiSelect,
        maybePrompt,
        prompt,
        progress (messageOrText, options) {
            const opts = typeof messageOrText === "string" ? (()=>{
                const words = messageOrText.split(" ");
                return {
                    prefix: words[0],
                    message: words.length > 1 ? words.slice(1).join(" ") : undefined,
                    ...options
                };
            })() : messageOrText;
            return new ProgressBar((...data)=>{
                state.infoLogger.getValue()(...data);
            }, opts);
        },
        setInfoLogger (logger) {
            state.infoLogger.setValue(logger);
        },
        setWarnLogger (logger) {
            state.warnLogger.setValue(logger);
        },
        setErrorLogger (logger) {
            state.errorLogger.setValue(logger);
            const commandBuilder = state.commandBuilder.getValue();
            commandBuilder.setPrintCommandLogger(logger);
            state.commandBuilder.setValue(commandBuilder);
        },
        setPrintCommand (value1) {
            const commandBuilder = state.commandBuilder.getValue().printCommand(value1);
            state.commandBuilder.setValue(commandBuilder);
        },
        request (url) {
            return state.requestBuilder.url(url);
        },
        raw (strings, ...exprs) {
            let result = "";
            for(let i = 0; i < Math.max(strings.length, exprs.length); i++){
                if (strings.length > i) {
                    result += strings[i];
                }
                if (exprs.length > i) {
                    result += templateLiteralExprToString(exprs[i]);
                }
            }
            return state.commandBuilder.getValue().command(result);
        },
        withRetries (opts) {
            return withRetries(result, state.errorLogger.getValue(), opts);
        }
    }, state.extras);
    const keyName = "logDepth";
    Object.defineProperty(result, keyName, Object.getOwnPropertyDescriptor(logDepthObj, keyName));
    state.requestBuilder = state.requestBuilder[withProgressBarFactorySymbol]((message)=>result.progress(message));
    return result;
    function getLogText(data) {
        const combinedText = data.join(" ");
        if (state.indentLevel.value === 0) {
            return combinedText;
        } else {
            const indentText = "  ".repeat(state.indentLevel.value);
            return combinedText.split(/\n/).map((l)=>`${indentText}${l}`).join("\n");
        }
    }
    function logStep(firstArg, data, colourize, logger) {
        if (data.length === 0) {
            let i = 0;
            while(i < firstArg.length && firstArg[i] === " "){
                i++;
            }
            while(i < firstArg.length && firstArg[i] !== " "){
                i++;
            }
            firstArg = colourize(firstArg.substring(0, i)) + firstArg.substring(i);
        } else {
            firstArg = colourize(firstArg);
        }
        logger(getLogText([
            firstArg,
            ...data
        ]));
    }
}
function templateLiteralExprToString(expr, escape) {
    let result;
    if (expr instanceof Array) {
        return expr.map((e)=>templateLiteralExprToString(e, escape)).join(" ");
    } else if (expr instanceof CommandResult) {
        result = expr.stdout.replace(/\r?\n$/, "");
    } else {
        result = `${expr}`;
    }
    return escape ? escape(result) : result;
}
build$FromState(buildInitial$State({
    isGlobal: true
}));
async function fileExists(filePath) {
    try {
        const statResult = await Deno.stat(filePath);
        if (statResult.isFile) {
            return true;
        } else {
            return false;
        }
    } catch (e) {
        if (e instanceof Deno.errors.NotFound) {
            return false;
        } else {
            throw e;
        }
    }
}
async function dirExists(dirPath) {
    try {
        const statResult = await Deno.stat(dirPath);
        if (statResult.isDirectory) {
            return true;
        } else {
            return false;
        }
    } catch (e) {
        if (e instanceof Deno.errors.NotFound) {
            return false;
        } else {
            throw e;
        }
    }
}
class FileIPC {
    MAX_DATA_LENGTH = 1024;
    filePath;
    dirPath;
    fileName;
    staleMessageLimitMs;
    debounceTimeMs;
    messageQueue = [];
    aborted = false;
    watcher;
    constructor(filePath, staleMessageLimitMs, debounceTimeMs){
        this.filePath = resolve2(filePath);
        this.dirPath = resolve2(dirname2(filePath));
        this.fileName = basename2(filePath);
        this.staleMessageLimitMs = staleMessageLimitMs ?? 30000;
        this.debounceTimeMs = debounceTimeMs ?? 100;
    }
    getFilePath() {
        return this.filePath;
    }
    async startWatching() {
        await Deno.mkdir(this.dirPath, {
            recursive: true
        });
        const messages = await this.extractMessages();
        if (messages.length > 0) {
            this.messageQueue.push(messages);
        }
        this.watcher = Deno.watchFs(this.dirPath);
        for await (const event of this.watcher){
            if (event.kind === "modify" && event.paths.includes(join3(this.dirPath, this.fileName))) {
                debounce(async ()=>{
                    try {
                        const messages = await this.extractMessages();
                        if (messages.length > 0) {
                            this.messageQueue.push(messages);
                        }
                    } catch (_e) {}
                }, this.debounceTimeMs)();
            }
        }
    }
    async extractMessages() {
        if (await fileExists(this.filePath)) {
            let fileContent;
            try {
                fileContent = await Deno.readTextFile(this.filePath);
            } catch (_e) {
                throw new Error(`Could not read '${this.filePath}'`);
            }
            try {
                await Deno.remove(this.filePath);
            } catch (_e) {
                throw new Error(`Failed to remove '${this.filePath}', aborting ipc read.`);
            }
            const receivedMessages = [];
            try {
                const messages = JSON.parse(fileContent || "[]");
                for (const messageObj of messages){
                    let validatedPid = null;
                    let validatedSent = null;
                    let validatedData = null;
                    const errors = [];
                    try {
                        validatedPid = parseInt(messageObj.pid);
                    } catch (_e) {
                        errors.push("Invalid data received: pid");
                    }
                    try {
                        validatedSent = new Date(Date.parse(messageObj.sent));
                    } catch (_e) {
                        errors.push("Invalid data received: sent");
                    }
                    if (validatedSent !== null && validatedSent.getTime() >= Date.now() - this.staleMessageLimitMs) {
                        if (!messageObj.data) {
                            errors.push("Invalid data received: missing");
                        } else if (typeof messageObj.data !== "string") {
                            errors.push("Invalid data received: not string");
                        } else if (messageObj.data.length >= this.MAX_DATA_LENGTH) {
                            errors.push("Invalid data received: too long");
                        } else {
                            validatedData = messageObj.data;
                        }
                    } else {
                        errors.push("Invalid data received: stale");
                    }
                    receivedMessages.push({
                        pid: validatedPid,
                        sent: validatedSent,
                        data: validatedData,
                        errors
                    });
                }
                return receivedMessages;
            } catch (_e) {
                throw new Error(`Invalid content in ${this.filePath}.ipc`);
            }
        } else {
            return [];
        }
    }
    async sendData(data) {
        await Deno.mkdir(this.dirPath, {
            recursive: true
        });
        try {
            const fileContent = await Deno.readTextFile(this.filePath).catch(()=>"");
            const messages = JSON.parse(fileContent || "[]");
            messages.push({
                pid: Deno.pid,
                data,
                sent: new Date().toISOString()
            });
            await Deno.writeTextFile(this.filePath, JSON.stringify(messages), {
                create: true
            });
        } catch (_e) {
            console.error("Error sending data, read or write failed.");
        }
    }
    async *receiveData() {
        if (!this.watcher) this.startWatching();
        while(!this.aborted){
            if (this.messageQueue.length > 0) {
                const messages = this.messageQueue.shift();
                if (messages) {
                    yield messages;
                }
            } else {
                await new Promise((resolve)=>setTimeout(resolve, this.debounceTimeMs));
            }
        }
    }
    async close(leaveFile) {
        this.aborted = true;
        if (this.watcher) {
            this.watcher.close();
        }
        if (!leaveFile) {
            try {
                await Deno.remove(this.filePath);
            } catch (_e) {}
        }
    }
}
class PupTelemetry {
    static instance;
    events = new EventEmitter();
    intervalSeconds = 15;
    timer;
    aborted = false;
    ipc;
    constructor(intervalSeconds = 5){
        if (!(this instanceof PupTelemetry)) {
            return new PupTelemetry(intervalSeconds);
        }
        if (PupTelemetry.instance) {
            return PupTelemetry.instance;
        }
        PupTelemetry.instance = this;
        if (!intervalSeconds || intervalSeconds < 1) intervalSeconds = 1;
        if (intervalSeconds > 180) intervalSeconds = 180;
        this.intervalSeconds = intervalSeconds;
        this.telemetryWatchdog();
        this.checkIpc();
    }
    async sendMainTelemetry() {
        const pupTempPath = Deno.env.get("PUP_TEMP_STORAGE");
        const pupProcessId = Deno.env.get("PUP_PROCESS_ID");
        if (pupTempPath && await dirExists(pupTempPath) && pupProcessId) {
            const data = {
                sender: pupProcessId,
                memory: Deno.memoryUsage(),
                sent: new Date().toISOString(),
                cwd: Deno.cwd()
            };
            this.emit("main", "telemetry", data);
        } else {}
    }
    async checkIpc() {
        const pupTempPath = Deno.env.get("PUP_TEMP_STORAGE");
        const pupProcessId = Deno.env.get("PUP_PROCESS_ID");
        if (pupTempPath && await dirExists(pupTempPath) && pupProcessId) {
            const ipcPath = `${pupTempPath}/.${pupProcessId}.ipc`;
            this.ipc = new FileIPC(ipcPath);
            for await (const messages of this.ipc.receiveData()){
                if (messages.length > 0) {
                    for (const message of messages){
                        try {
                            if (message.data) {
                                const parsedMessage = JSON.parse(message.data);
                                this.events.emit(parsedMessage.event, parsedMessage.eventData);
                            }
                        } catch (_e) {}
                    }
                }
            }
        }
    }
    async telemetryWatchdog() {
        try {
            await this.sendMainTelemetry();
        } catch (_e) {} finally{
            clearTimeout(this.timer);
            if (!this.aborted) {
                this.timer = setTimeout(()=>this.telemetryWatchdog(), this.intervalSeconds * 1000);
                Deno.unrefTimer(this.timer);
            }
        }
    }
    on(event, fn) {
        this.events.on(event, fn);
    }
    off(event, fn) {
        this.events.off(event, fn);
    }
    async emit(targetProcessId, event, eventData) {
        const pupTempPath = Deno.env.get("PUP_TEMP_STORAGE");
        if (pupTempPath && await dirExists(pupTempPath) && targetProcessId) {
            const ipcPath = `${pupTempPath}/.${targetProcessId}.ipc`;
            const ipc = new FileIPC(ipcPath);
            const message = {
                event,
                eventData
            };
            await ipc.sendData(JSON.stringify(message));
            ipc.close(true);
        } else {}
    }
    close() {
        this.aborted = true;
        if (this.timer) {
            clearTimeout(this.timer);
        }
        if (this.ipc) {
            this.ipc.close();
        }
    }
}
const countries = [
    {
        name: "Sverige",
        id: "sv",
        cty: "Sweden (SE)",
        cta: "CTA|SE",
        interval: "PT60M",
        areas: [
            {
                name: "SE1",
                "id": "BZN|SE1",
                "long": "Norra Sverige",
                color: 1
            },
            {
                name: "SE2",
                "id": "BZN|SE2",
                "long": "Norra Mellansverige",
                color: 2
            },
            {
                name: "SE3",
                "id": "BZN|SE3",
                "long": "Södra Mellansverige",
                color: 3
            },
            {
                name: "SE4",
                "id": "BZN|SE4",
                "long": "Södra sverige",
                color: 4
            }
        ]
    },
    {
        name: "Norge",
        cty: "Norway (NO)",
        cta: "CTA|NO",
        interval: "PT60M",
        id: "no",
        areas: [
            {
                name: "NO1",
                "id": "IBA|NO1",
                "long": "Oslo",
                color: 1
            },
            {
                name: "NO2",
                "id": "IBA|NO2",
                "long": "Kristiansand",
                color: 2
            },
            {
                name: "NO3",
                "id": "IBA|NO3",
                "long": "Molde",
                color: 3
            },
            {
                name: "NO4",
                "id": "IBA|NO4",
                "long": "Tromsø",
                color: 4
            },
            {
                name: "NO5",
                "id": "IBA|NO5",
                "long": "Bergen",
                color: 5
            }
        ]
    },
    {
        name: "Finland",
        cty: "Finland (FI)",
        cta: "CTA|FI",
        interval: "PT60M",
        id: "fi",
        areas: [
            {
                name: "FI",
                "id": "FI",
                "long": "Suomi",
                color: 1
            }
        ]
    },
    {
        name: "Danmark",
        cty: "Denmark (DK)",
        cta: "CTA|DK",
        interval: "PT60M",
        id: "dk",
        areas: [
            {
                name: "DK1",
                "id": "IBA|DK1",
                "long": "Jylland",
                color: 1
            },
            {
                name: "DK2",
                "id": "IBA|DK2",
                "long": "Sjaelland",
                color: 2
            }
        ]
    },
    {
        name: "Deutschland",
        cty: "Germany (DE)",
        cta: "CTA|DE",
        interval: "PT15M",
        id: "de",
        areas: [
            {
                name: "DE-LU",
                "id": "BZN|DE-LU",
                "long": "Deutschland",
                color: 1
            }
        ]
    },
    {
        name: "Österreich",
        cty: "Austria (AT)",
        cta: "CTA|AT",
        interval: "PT15M",
        id: "at",
        areas: [
            {
                name: "AT",
                "id": "BZN|AT",
                "long": "Österreich",
                color: 1
            }
        ]
    },
    {
        name: "Belgium",
        id: "be",
        cty: "Belgium (BE)",
        cta: "CTA|BE",
        interval: "PT60M",
        areas: [
            {
                name: "BE",
                "id": "BZN|BE",
                "long": "Belgium",
                color: 1
            }
        ]
    },
    {
        name: "Switzerland",
        cty: "Switzerland (CH)",
        cta: "CTA|CH",
        interval: "PT60M",
        id: "ch",
        areas: [
            {
                name: "CH",
                "id": "BZN|CH",
                "long": "Switzerland",
                color: 1
            }
        ]
    },
    {
        name: "Spain",
        cty: "Spain (ES)",
        cta: "CTA|ES",
        interval: "PT60M",
        id: "es",
        areas: [
            {
                name: "ES",
                "id": "BZN|ES",
                "long": "Spain",
                color: 1
            }
        ]
    },
    {
        name: "France",
        cty: "France (FR)",
        cta: "CTA|FR",
        interval: "PT60M",
        id: "fr",
        areas: [
            {
                name: "FR",
                "id": "BZN|FR",
                "long": "France",
                color: 1
            }
        ]
    },
    {
        name: "Poland",
        cty: "Poland (PL)",
        cta: "CTA|PL",
        interval: "PT60M",
        id: "pl",
        areas: [
            {
                name: "PL",
                "id": "BZN|PL",
                "long": "Poland",
                color: 1
            }
        ]
    }
];
const Areas = {
    "10Y1001A1001A016": "CTA|NIE, MBA|SEM(SONI), SCA|NIE",
    "10Y1001A1001A39I": "SCA|EE, MBA|EE, CTA|EE, BZN|EE, Estonia (EE)",
    "10Y1001A1001A44P": "IPA|SE1, BZN|SE1, MBA|SE1, SCA|SE1",
    "10Y1001A1001A45N": "SCA|SE2, MBA|SE2, BZN|SE2, IPA|SE2",
    "10Y1001A1001A46L": "IPA|SE3, BZN|SE3, MBA|SE3, SCA|SE3",
    "10Y1001A1001A47J": "SCA|SE4, MBA|SE4, BZN|SE4, IPA|SE4",
    "10Y1001A1001A48H": "IPA|NO5, IBA|NO5, BZN|NO5, MBA|NO5, SCA|NO5",
    "10Y1001A1001A49F": "SCA|RU, MBA|RU, BZN|RU, CTA|RU",
    "10Y1001A1001A50U": "CTA|RU-KGD, BZN|RU-KGD, MBA|RU-KGD, SCA|RU-KGD",
    "10Y1001A1001A51S": "SCA|BY, MBA|BY, BZN|BY, CTA|BY",
    "10Y1001A1001A59C": "BZN|IE(SEM), MBA|IE(SEM), SCA|IE(SEM), LFB|IE-NIE, SNA|Ireland",
    "10Y1001A1001A63L": "BZN|DE-AT-LU",
    "10Y1001A1001A64J": "BZN|NO1A",
    "10Y1001A1001A65H": "Denmark (DK)",
    "10Y1001A1001A66F": "BZN|IT-GR",
    "10Y1001A1001A67D": "BZN|IT-North-SI",
    "10Y1001A1001A68B": "BZN|IT-North-CH",
    "10Y1001A1001A699": "BZN|IT-Brindisi, SCA|IT-Brindisi, MBA|IT-Z-Brindisi",
    "10Y1001A1001A70O": "MBA|IT-Z-Centre-North, SCA|IT-Centre-North, BZN|IT-Centre-North",
    "10Y1001A1001A71M": "BZN|IT-Centre-South, SCA|IT-Centre-South, MBA|IT-Z-Centre-South",
    "10Y1001A1001A72K": "MBA|IT-Z-Foggia, SCA|IT-Foggia, BZN|IT-Foggia",
    "10Y1001A1001A73I": "BZN|IT-North, SCA|IT-North, MBA|IT-Z-North",
    "10Y1001A1001A74G": "MBA|IT-Z-Sardinia, SCA|IT-Sardinia, BZN|IT-Sardinia",
    "10Y1001A1001A75E": "BZN|IT-Sicily, SCA|IT-Sicily, MBA|IT-Z-Sicily",
    "10Y1001A1001A76C": "MBA|IT-Z-Priolo, SCA|IT-Priolo, BZN|IT-Priolo",
    "10Y1001A1001A77A": "BZN|IT-Rossano, SCA|IT-Rossano, MBA|IT-Z-Rossano",
    "10Y1001A1001A788": "MBA|IT-Z-South, SCA|IT-South, BZN|IT-South",
    "10Y1001A1001A796": "CTA|DK",
    "10Y1001A1001A80L": "BZN|IT-North-AT",
    "10Y1001A1001A81J": "BZN|IT-North-FR",
    "10Y1001A1001A82H": "BZN|DE-LU, IPA|DE-LU, SCA|DE-LU, MBA|DE-LU",
    "10Y1001A1001A83F": "Germany (DE)",
    "10Y1001A1001A84D": "MBA|IT-MACRZONENORTH, SCA|IT-MACRZONENORTH",
    "10Y1001A1001A85B": "SCA|IT-MACRZONESOUTH, MBA|IT-MACRZONESOUTH",
    "10Y1001A1001A869": "SCA|UA-DobTPP, BZN|UA-DobTPP, CTA|UA-DobTPP",
    "10Y1001A1001A877": "BZN|IT-Malta",
    "10Y1001A1001A885": "BZN|IT-SACOAC",
    "10Y1001A1001A893": "BZN|IT-SACODC, SCA|IT-SACODC",
    "10Y1001A1001A91G": "SNA|Nordic, REG|Nordic, LFB|Nordic",
    "10Y1001A1001A92E": "United Kingdom (UK)",
    "10Y1001A1001A93C": "Malta (MT), BZN|MT, CTA|MT, SCA|MT, MBA|MT",
    "10Y1001A1001A990": "MBA|MD, SCA|MD, CTA|MD, BZN|MD, Moldova (MD)",
    "10Y1001A1001B004": "Armenia (AM), BZN|AM, CTA|AM",
    "10Y1001A1001B012": "CTA|GE, BZN|GE, Georgia (GE), SCA|GE, MBA|GE",
    "10Y1001A1001B05V": "Azerbaijan (AZ), BZN|AZ, CTA|AZ",
    "10Y1001C--00003F": "BZN|UA, Ukraine (UA), MBA|UA, SCA|UA",
    "10Y1001C--000182": "SCA|UA-IPS, MBA|UA-IPS, BZN|UA-IPS, CTA|UA-IPS",
    "10Y1001C--00038X": "BZA|CZ-DE-SK-LT-SE4",
    "10Y1001C--00059P": "REG|CORE",
    "10Y1001C--00090V": "REG|AFRR, SCA|AFRR",
    "10Y1001C--00095L": "REG|SWE",
    "10Y1001C--00096J": "SCA|IT-Calabria, MBA|IT-Z-Calabria, BZN|IT-Calabria",
    "10Y1001C--00098F": "BZN|GB(IFA)",
    "10Y1001C--00100H": "BZN|XK, CTA|XK, Kosovo (XK), MBA|XK, LFB|XK, LFA|XK",
    "10Y1001C--00119X": "SCA|IN",
    "10Y1001C--001219": "BZN|NO2A",
    "10Y1001C--00137V": "REG|ITALYNORTH",
    "10Y1001C--00138T": "REG|GRIT",
    "10YAL-KESH-----5": "LFB|AL, LFA|AL, BZN|AL, CTA|AL, Albania (AL), SCA|AL, MBA|AL",
    "10YAT-APG------L": "MBA|AT, SCA|AT, Austria (AT), IPA|AT, CTA|AT, BZN|AT, LFA|AT, LFB|AT",
    "10YBA-JPCC-----D": "LFA|BA, BZN|BA, CTA|BA, Bosnia and Herz. (BA), SCA|BA, MBA|BA",
    "10YBE----------2": "MBA|BE, SCA|BE, Belgium (BE), CTA|BE, BZN|BE, LFA|BE, LFB|BE",
    "10YCA-BULGARIA-R": "LFB|BG, LFA|BG, BZN|BG, CTA|BG, Bulgaria (BG), SCA|BG, MBA|BG",
    "10YCB-GERMANY--8": "SCA|DE_DK1_LU, LFB|DE_DK1_LU",
    "10YCB-JIEL-----9": "LFB|RS_MK_ME",
    "10YCB-POLAND---Z": "LFB|PL",
    "10YCB-SI-HR-BA-3": "LFB|SI_HR_BA",
    "10YCH-SWISSGRIDZ": "LFB|CH, LFA|CH, SCA|CH, MBA|CH, Switzerland (CH), CTA|CH, BZN|CH",
    "10YCS-CG-TSO---S": "BZN|ME, CTA|ME, Montenegro (ME), MBA|ME, SCA|ME, LFA|ME",
    "10YCS-SERBIATSOV": "LFA|RS, SCA|RS, MBA|RS, Serbia (RS), CTA|RS, BZN|RS",
    "10YCY-1001A0003J": "BZN|CY, CTA|CY, Cyprus (CY), MBA|CY, SCA|CY",
    "10YCZ-CEPS-----N": "SCA|CZ, MBA|CZ, Czech Republic (CZ), CTA|CZ, BZN|CZ, LFA|CZ, LFB|CZ",
    "10YDE-ENBW-----N": "LFA|DE(TransnetBW), CTA|DE(TransnetBW), SCA|DE(TransnetBW)",
    "10YDE-EON------1": "SCA|DE(TenneT GER), CTA|DE(TenneT GER), LFA|DE(TenneT GER)",
    "10YDE-RWENET---I": "LFA|DE(Amprion), CTA|DE(Amprion), SCA|DE(Amprion)",
    "10YDE-VE-------2": "SCA|DE(50Hertz), CTA|DE(50Hertz), LFA|DE(50Hertz), BZA|DE(50HzT)",
    "10YDK-1-------AA": "BZN|DK1A",
    "10YDK-1--------W": "IPA|DK1, IBA|DK1, BZN|DK1, SCA|DK1, MBA|DK1, LFA|DK1",
    "10YDK-2--------M": "LFA|DK2, MBA|DK2, SCA|DK2, IBA|DK2, IPA|DK2, BZN|DK2",
    "10YDOM-1001A082L": "CTA|PL-CZ, BZA|PL-CZ",
    "10YDOM-CZ-DE-SKK": "BZA|CZ-DE-SK, BZN|CZ+DE+SK",
    "10YDOM-PL-SE-LT2": "BZA|LT-SE4",
    "10YDOM-REGION-1V": "REG|CWE",
    "10YES-REE------0": "LFB|ES, LFA|ES, BZN|ES, Spain (ES), CTA|ES, SCA|ES, MBA|ES",
    "10YEU-CONT-SYNC0": "SNA|Continental Europe",
    "10YFI-1--------U": "MBA|FI, SCA|FI, CTA|FI, Finland (FI), BZN|FI, IPA|FI, IBA|FI",
    "10YFR-RTE------C": "BZN|FR, France (FR), CTA|FR, SCA|FR, MBA|FR, LFB|FR, LFA|FR",
    "10YGB----------A": "LFA|GB, LFB|GB, SNA|GB, MBA|GB, SCA|GB, CTA|National Grid, BZN|GB",
    "10YGR-HTSO-----Y": "BZN|GR, Greece (GR), CTA|GR, SCA|GR, MBA|GR, LFB|GR, LFA|GR",
    "10YHR-HEP------M": "LFA|HR, MBA|HR, SCA|HR, CTA|HR, Croatia (HR), BZN|HR",
    "10YHU-MAVIR----U": "BZN|HU, Hungary (HU), CTA|HU, SCA|HU, MBA|HU, LFA|HU, LFB|HU",
    "10YIE-1001A00010": "MBA|SEM(EirGrid), SCA|IE, CTA|IE, Ireland (IE)",
    "10YIT-GRTN-----B": "Italy (IT), CTA|IT, SCA|IT, MBA|IT, LFB|IT, LFA|IT",
    "10YLT-1001A0008Q": "MBA|LT, SCA|LT, CTA|LT, Lithuania (LT), BZN|LT",
    "10YLU-CEGEDEL-NQ": "Luxembourg (LU), CTA|LU",
    "10YLV-1001A00074": "CTA|LV, Latvia (LV), BZN|LV, SCA|LV, MBA|LV",
    "10YMK-MEPSO----8": "MBA|MK, SCA|MK, BZN|MK, North Macedonia (MK), CTA|MK, LFA|MK",
    "10YNL----------L": "LFA|NL, LFB|NL, CTA|NL, Netherlands (NL), BZN|NL, SCA|NL, MBA|NL",
    "10YNO-0--------C": "MBA|NO, SCA|NO, Norway (NO), CTA|NO",
    "10YNO-1--------2": "BZN|NO1, IBA|NO1, IPA|NO1, SCA|NO1, MBA|NO1",
    "10YNO-2--------T": "MBA|NO2, SCA|NO2, IPA|NO2, IBA|NO2, BZN|NO2",
    "10YNO-3--------J": "BZN|NO3, IBA|NO3, IPA|NO3, SCA|NO3, MBA|NO3",
    "10YNO-4--------9": "MBA|NO4, SCA|NO4, IPA|NO4, IBA|NO4, BZN|NO4",
    "10YPL-AREA-----S": "BZN|PL, Poland (PL), CTA|PL, SCA|PL, MBA|PL, BZA|PL, LFA|PL",
    "10YPT-REN------W": "LFA|PT, LFB|PT, MBA|PT, SCA|PT, CTA|PT, Portugal (PT), BZN|PT",
    "10YRO-TEL------P": "BZN|RO, Romania (RO), CTA|RO, SCA|RO, MBA|RO, LFB|RO, LFA|RO",
    "10YSE-1--------K": "MBA|SE, SCA|SE, CTA|SE, Sweden (SE)",
    "10YSI-ELES-----O": "Slovenia (SI), BZN|SI, CTA|SI, SCA|SI, MBA|SI, LFA|SI",
    "10YSK-SEPS-----K": "LFA|SK, LFB|SK, MBA|SK, SCA|SK, CTA|SK, BZN|SK, Slovakia (SK)",
    "10YTR-TEIAS----W": "Turkey (TR), BZN|TR, CTA|TR, SCA|TR, MBA|TR, LFB|TR, LFA|TR",
    "10YUA-WEPS-----0": "LFA|UA-BEI, LFB|UA-BEI, MBA|UA-BEI, SCA|UA-BEI, CTA|UA-BEI, BZN|UA-BEI",
    "11Y0-0000-0265-K": "BZN|GB(ElecLink)",
    "17Y0000009369493": "BZN|GB(IFA2)",
    "46Y000000000007M": "BZN|DK1-NO1",
    "50Y0JVU59B4JWQCU": "BZN|NO2NSL",
    "BY": "Belarus (BY)",
    "RU": "Russia (RU)",
    "IS": "Iceland (IS)"
};
const AllAreas = (identifier)=>{
    return Object.entries(Areas).filter(([_key, value1])=>value1.includes(identifier)).map((e)=>e[0]);
};
const Area = (identifier)=>{
    return AllAreas(identifier)?.[0];
};
const DocumentTypes = {
    A09: "Finalised schedule",
    A11: "Aggregated energy data report",
    A15: "Acquiring system operator reserve schedule",
    A24: "Bid document",
    A25: "Allocation result document",
    A26: "Capacity document",
    A31: "Agreed capacity",
    A37: "Reserve bid document",
    A38: "Reserve allocation result document",
    A44: "Price Document",
    A61: "Estimated Net Transfer Capacity",
    A63: "Redispatch notice",
    A65: "System total load",
    A68: "Installed generation per type",
    A69: "Wind and solar forecast",
    A70: "Load forecast margin",
    A71: "Generation forecast",
    A72: "Reservoir filling information",
    A73: "Actual generation",
    A74: "Wind and solar generation",
    A75: "Actual generation per type",
    A76: "Load unavailability",
    A77: "Production unavailability",
    A78: "Transmission unavailability",
    A79: "Offshore grid infrastructure unavailability",
    A80: "Generation unavailability",
    A81: "Contracted reserves",
    A82: "Accepted offers",
    A83: "Activated balancing quantities",
    A84: "Activated balancing prices",
    A85: "Imbalance prices",
    A86: "Imbalance volume",
    A87: "Financial situation",
    A88: "Cross border balancing",
    A89: "Contracted reserve prices",
    A90: "Interconnection network expansion",
    A91: "Counter trade notice",
    A92: "Congestion costs",
    A93: "DC link capacity",
    A94: "Non EU allocations",
    A95: "Configuration document",
    B11: "Flow-based allocations",
    B17: "Aggregated netted external TSO schedule document",
    B45: "Bid Availability Document"
};
var p = Object.create;
var c = Object.defineProperty;
var m = Object.getOwnPropertyDescriptor;
var w = Object.getOwnPropertyNames;
var Z = Object.getPrototypeOf, _ = Object.prototype.hasOwnProperty;
var F = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports), I = (e, r)=>{
    for(var i in r)c(e, i, {
        get: r[i],
        enumerable: !0
    });
}, d = (e, r, i, f)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let n of w(r))!_.call(e, n) && n !== i && c(e, n, {
        get: ()=>r[n],
        enumerable: !(f = m(r, n)) || f.enumerable
    });
    return e;
}, a = (e, r, i)=>(d(e, r, "default"), i && d(i, r, "default")), x = (e, r, i)=>(i = e != null ? p(Z(e)) : {}, d(r || !e || !e.__esModule ? c(i, "default", {
        value: e,
        enumerable: !0
    }) : i, e));
var g = F((B, N)=>{
    var k = /^[-+]?0x[a-fA-F0-9]+$/, E = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    !Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt);
    !Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
    var O = {
        hex: !0,
        leadingZeros: !0,
        decimalPoint: ".",
        eNotation: !0
    };
    function $(e, r = {}) {
        if (r = Object.assign({}, O, r), !e || typeof e != "string") return e;
        let i = e.trim();
        if (r.skipLike !== void 0 && r.skipLike.test(i)) return e;
        if (r.hex && k.test(i)) return Number.parseInt(i, 16);
        {
            let f = E.exec(i);
            if (f) {
                let n = f[1], o = f[2], u = y(f[3]), h = f[4] || f[6];
                if (!r.leadingZeros && o.length > 0 && n && i[2] !== ".") return e;
                if (!r.leadingZeros && o.length > 0 && !n && i[1] !== ".") return e;
                {
                    let t = Number(i), l = "" + t;
                    return l.search(/[eE]/) !== -1 || h ? r.eNotation ? t : e : i.indexOf(".") !== -1 ? l === "0" && u === "" || l === u || n && l === "-" + u ? t : e : o ? u === l || n + u === l ? t : e : i === l || i === n + l ? t : e;
                }
            } else return e;
        }
    }
    function y(e) {
        return e && e.indexOf(".") !== -1 && (e = e.replace(/0+$/, ""), e === "." ? e = "0" : e[0] === "." ? e = "0" + e : e[e.length - 1] === "." && (e = e.substr(0, e.length - 1))), e;
    }
    N.exports = $;
});
var s = {};
I(s, {
    default: ()=>j
});
var L = x(g());
a(s, x(g()));
var { default: b, ...R1 } = L, j = b !== void 0 ? b : R1;
const mod10 = {
    default: j
};
var require = (n)=>{
    const e = (m)=>typeof m.default < "u" ? m.default : m;
    switch(n){
        case "strnum":
            return e(mod10);
        default:
            throw new Error("module \"" + n + "\" not found");
    }
};
var be = Object.create;
var x1 = Object.defineProperty;
var Ee = Object.getOwnPropertyDescriptor;
var Te = Object.getOwnPropertyNames;
var ye = Object.getPrototypeOf, Ae = Object.prototype.hasOwnProperty;
var me = ((e)=>typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, {
        get: (t, s)=>(typeof require < "u" ? require : t)[s]
    }) : e)(function(e) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + e + '" is not supported');
});
var b1 = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports), Pe = (e, t)=>{
    for(var s in t)x1(e, s, {
        get: t[s],
        enumerable: !0
    });
}, S = (e, t, s, i)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let r of Te(t))!Ae.call(e, r) && r !== s && x1(e, r, {
        get: ()=>t[r],
        enumerable: !(i = Ee(t, r)) || i.enumerable
    });
    return e;
}, A = (e, t, s)=>(S(e, t, "default"), s && S(s, t, "default")), X = (e, t, s)=>(s = e != null ? be(ye(e)) : {}, S(t || !e || !e.__esModule ? x1(s, "default", {
        value: e,
        enumerable: !0
    }) : s, e));
var C = b1((E)=>{
    "use strict";
    var k = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Ie = k + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", G = "[" + k + "][" + Ie + "]*", we = new RegExp("^" + G + "$"), Oe = function(e, t) {
        let s = [], i = t.exec(e);
        for(; i;){
            let r = [];
            r.startIndex = t.lastIndex - i[0].length;
            let n = i.length;
            for(let f = 0; f < n; f++)r.push(i[f]);
            s.push(r), i = t.exec(e);
        }
        return s;
    }, Ce = function(e) {
        let t = we.exec(e);
        return !(t === null || typeof t > "u");
    };
    E.isExist = function(e) {
        return typeof e < "u";
    };
    E.isEmptyObject = function(e) {
        return Object.keys(e).length === 0;
    };
    E.merge = function(e, t, s) {
        if (t) {
            let i = Object.keys(t), r = i.length;
            for(let n = 0; n < r; n++)s === "strict" ? e[i[n]] = [
                t[i[n]]
            ] : e[i[n]] = t[i[n]];
        }
    };
    E.getValue = function(e) {
        return E.isExist(e) ? e : "";
    };
    E.isName = Ce;
    E.getAllMatches = Oe;
    E.nameRegexp = G;
});
var v = b1((K)=>{
    "use strict";
    var V = C(), Se = {
        allowBooleanAttributes: !1,
        unpairedTags: []
    };
    K.validate = function(e, t) {
        t = Object.assign({}, Se, t);
        let s = [], i = !1, r = !1;
        e[0] === "\uFEFF" && (e = e.substr(1));
        for(let n = 0; n < e.length; n++)if (e[n] === "<" && e[n + 1] === "?") {
            if (n += 2, n = Y(e, n), n.err) return n;
        } else if (e[n] === "<") {
            let f = n;
            if (n++, e[n] === "!") {
                n = J(e, n);
                continue;
            } else {
                let u = !1;
                e[n] === "/" && (u = !0, n++);
                let o = "";
                for(; n < e.length && e[n] !== ">" && e[n] !== " " && e[n] !== "	" && e[n] !== `
` && e[n] !== "\r"; n++)o += e[n];
                if (o = o.trim(), o[o.length - 1] === "/" && (o = o.substring(0, o.length - 1), n--), !Be(o)) {
                    let d;
                    return o.trim().length === 0 ? d = "Invalid space after '<'." : d = "Tag '" + o + "' is an invalid name.", h("InvalidTag", d, p(e, n));
                }
                let l = ve(e, n);
                if (l === !1) return h("InvalidAttr", "Attributes for '" + o + "' have open quote.", p(e, n));
                let a = l.value;
                if (n = l.index, a[a.length - 1] === "/") {
                    let d = n - a.length;
                    a = a.substring(0, a.length - 1);
                    let g = W(a, t);
                    if (g === !0) i = !0;
                    else return h(g.err.code, g.err.msg, p(e, d + g.err.line));
                } else if (u) if (l.tagClosed) {
                    if (a.trim().length > 0) return h("InvalidTag", "Closing tag '" + o + "' can't have attributes or invalid starting.", p(e, f));
                    {
                        let d = s.pop();
                        if (o !== d.tagName) {
                            let g = p(e, d.tagStartPos);
                            return h("InvalidTag", "Expected closing tag '" + d.tagName + "' (opened in line " + g.line + ", col " + g.col + ") instead of closing tag '" + o + "'.", p(e, f));
                        }
                        s.length == 0 && (r = !0);
                    }
                } else return h("InvalidTag", "Closing tag '" + o + "' doesn't have proper closing.", p(e, n));
                else {
                    let d = W(a, t);
                    if (d !== !0) return h(d.err.code, d.err.msg, p(e, n - a.length + d.err.line));
                    if (r === !0) return h("InvalidXml", "Multiple possible root nodes found.", p(e, n));
                    t.unpairedTags.indexOf(o) !== -1 || s.push({
                        tagName: o,
                        tagStartPos: f
                    }), i = !0;
                }
                for(n++; n < e.length; n++)if (e[n] === "<") if (e[n + 1] === "!") {
                    n++, n = J(e, n);
                    continue;
                } else if (e[n + 1] === "?") {
                    if (n = Y(e, ++n), n.err) return n;
                } else break;
                else if (e[n] === "&") {
                    let d = Fe(e, n);
                    if (d == -1) return h("InvalidChar", "char '&' is not expected.", p(e, n));
                    n = d;
                } else if (r === !0 && !U(e[n])) return h("InvalidXml", "Extra text at the end", p(e, n));
                e[n] === "<" && n--;
            }
        } else {
            if (U(e[n])) continue;
            return h("InvalidChar", "char '" + e[n] + "' is not expected.", p(e, n));
        }
        if (i) {
            if (s.length == 1) return h("InvalidTag", "Unclosed tag '" + s[0].tagName + "'.", p(e, s[0].tagStartPos));
            if (s.length > 0) return h("InvalidXml", "Invalid '" + JSON.stringify(s.map((n)=>n.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", {
                line: 1,
                col: 1
            });
        } else return h("InvalidXml", "Start tag expected.", 1);
        return !0;
    };
    function U(e) {
        return e === " " || e === "	" || e === `
` || e === "\r";
    }
    function Y(e, t) {
        let s = t;
        for(; t < e.length; t++)if (e[t] == "?" || e[t] == " ") {
            let i = e.substr(s, t - s);
            if (t > 5 && i === "xml") return h("InvalidXml", "XML declaration allowed only at the start of the document.", p(e, t));
            if (e[t] == "?" && e[t + 1] == ">") {
                t++;
                break;
            } else continue;
        }
        return t;
    }
    function J(e, t) {
        if (e.length > t + 5 && e[t + 1] === "-" && e[t + 2] === "-") {
            for(t += 3; t < e.length; t++)if (e[t] === "-" && e[t + 1] === "-" && e[t + 2] === ">") {
                t += 2;
                break;
            }
        } else if (e.length > t + 8 && e[t + 1] === "D" && e[t + 2] === "O" && e[t + 3] === "C" && e[t + 4] === "T" && e[t + 5] === "Y" && e[t + 6] === "P" && e[t + 7] === "E") {
            let s = 1;
            for(t += 8; t < e.length; t++)if (e[t] === "<") s++;
            else if (e[t] === ">" && (s--, s === 0)) break;
        } else if (e.length > t + 9 && e[t + 1] === "[" && e[t + 2] === "C" && e[t + 3] === "D" && e[t + 4] === "A" && e[t + 5] === "T" && e[t + 6] === "A" && e[t + 7] === "[") {
            for(t += 8; t < e.length; t++)if (e[t] === "]" && e[t + 1] === "]" && e[t + 2] === ">") {
                t += 2;
                break;
            }
        }
        return t;
    }
    var xe = '"', Ve = "'";
    function ve(e, t) {
        let s = "", i = "", r = !1;
        for(; t < e.length; t++){
            if (e[t] === xe || e[t] === Ve) i === "" ? i = e[t] : i !== e[t] || (i = "");
            else if (e[t] === ">" && i === "") {
                r = !0;
                break;
            }
            s += e[t];
        }
        return i !== "" ? !1 : {
            value: s,
            index: t,
            tagClosed: r
        };
    }
    var _e = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function W(e, t) {
        let s = V.getAllMatches(e, _e), i = {};
        for(let r = 0; r < s.length; r++){
            if (s[r][1].length === 0) return h("InvalidAttr", "Attribute '" + s[r][2] + "' has no space in starting.", I(s[r]));
            if (s[r][3] !== void 0 && s[r][4] === void 0) return h("InvalidAttr", "Attribute '" + s[r][2] + "' is without value.", I(s[r]));
            if (s[r][3] === void 0 && !t.allowBooleanAttributes) return h("InvalidAttr", "boolean attribute '" + s[r][2] + "' is not allowed.", I(s[r]));
            let n = s[r][2];
            if (!Le(n)) return h("InvalidAttr", "Attribute '" + n + "' is an invalid name.", I(s[r]));
            if (!i.hasOwnProperty(n)) i[n] = 1;
            else return h("InvalidAttr", "Attribute '" + n + "' is repeated.", I(s[r]));
        }
        return !0;
    }
    function $e(e, t) {
        let s = /\d/;
        for(e[t] === "x" && (t++, s = /[\da-fA-F]/); t < e.length; t++){
            if (e[t] === ";") return t;
            if (!e[t].match(s)) break;
        }
        return -1;
    }
    function Fe(e, t) {
        if (t++, e[t] === ";") return -1;
        if (e[t] === "#") return t++, $e(e, t);
        let s = 0;
        for(; t < e.length; t++, s++)if (!(e[t].match(/\w/) && s < 20)) {
            if (e[t] === ";") break;
            return -1;
        }
        return t;
    }
    function h(e, t, s) {
        return {
            err: {
                code: e,
                msg: t,
                line: s.line || s,
                col: s.col
            }
        };
    }
    function Le(e) {
        return V.isName(e);
    }
    function Be(e) {
        return V.isName(e);
    }
    function p(e, t) {
        let s = e.substring(0, t).split(/\r?\n/);
        return {
            line: s.length,
            col: s[s.length - 1].length + 1
        };
    }
    function I(e) {
        return e.startIndex + e[1].length;
    }
});
var Z1 = b1((_)=>{
    var Q = {
        preserveOrder: !1,
        attributeNamePrefix: "@_",
        attributesGroupName: !1,
        textNodeName: "#text",
        ignoreAttributes: !0,
        removeNSPrefix: !1,
        allowBooleanAttributes: !1,
        parseTagValue: !0,
        parseAttributeValue: !1,
        trimValues: !0,
        cdataPropName: !1,
        numberParseOptions: {
            hex: !0,
            leadingZeros: !0,
            eNotation: !0
        },
        tagValueProcessor: function(e, t) {
            return t;
        },
        attributeValueProcessor: function(e, t) {
            return t;
        },
        stopNodes: [],
        alwaysCreateTextNode: !1,
        isArray: ()=>!1,
        commentPropName: !1,
        unpairedTags: [],
        processEntities: !0,
        htmlEntities: !1,
        ignoreDeclaration: !1,
        ignorePiTags: !1,
        transformTagName: !1,
        transformAttributeName: !1,
        updateTag: function(e, t, s) {
            return e;
        }
    }, Me = function(e) {
        return Object.assign({}, Q, e);
    };
    _.buildOptions = Me;
    _.defaultOptions = Q;
});
var H = b1((Bt, z)=>{
    "use strict";
    var $ = class {
        constructor(t){
            this.tagname = t, this.child = [], this[":@"] = {};
        }
        add(t, s) {
            t === "__proto__" && (t = "#__proto__"), this.child.push({
                [t]: s
            });
        }
        addChild(t) {
            t.tagname === "__proto__" && (t.tagname = "#__proto__"), t[":@"] && Object.keys(t[":@"]).length > 0 ? this.child.push({
                [t.tagname]: t.child,
                ":@": t[":@"]
            }) : this.child.push({
                [t.tagname]: t.child
            });
        }
    };
    z.exports = $;
});
var D = b1((Mt, j)=>{
    var qe = C();
    function Re(e, t) {
        let s = {};
        if (e[t + 3] === "O" && e[t + 4] === "C" && e[t + 5] === "T" && e[t + 6] === "Y" && e[t + 7] === "P" && e[t + 8] === "E") {
            t = t + 9;
            let i = 1, r = !1, n = !1, f = "";
            for(; t < e.length; t++)if (e[t] === "<" && !n) {
                if (r && Ge(e, t)) t += 7, [entityName, val, t] = Xe(e, t + 1), val.indexOf("&") === -1 && (s[We(entityName)] = {
                    regx: RegExp(`&${entityName};`, "g"),
                    val
                });
                else if (r && Ue(e, t)) t += 8;
                else if (r && Ye(e, t)) t += 8;
                else if (r && Je(e, t)) t += 9;
                else if (ke) n = !0;
                else throw new Error("Invalid DOCTYPE");
                i++, f = "";
            } else if (e[t] === ">") {
                if (n ? e[t - 1] === "-" && e[t - 2] === "-" && (n = !1, i--) : i--, i === 0) break;
            } else e[t] === "[" ? r = !0 : f += e[t];
            if (i !== 0) throw new Error("Unclosed DOCTYPE");
        } else throw new Error("Invalid Tag instead of DOCTYPE");
        return {
            entities: s,
            i: t
        };
    }
    function Xe(e, t) {
        let s = "";
        for(; t < e.length && e[t] !== "'" && e[t] !== '"'; t++)s += e[t];
        if (s = s.trim(), s.indexOf(" ") !== -1) throw new Error("External entites are not supported");
        let i = e[t++], r = "";
        for(; t < e.length && e[t] !== i; t++)r += e[t];
        return [
            s,
            r,
            t
        ];
    }
    function ke(e, t) {
        return e[t + 1] === "!" && e[t + 2] === "-" && e[t + 3] === "-";
    }
    function Ge(e, t) {
        return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "N" && e[t + 4] === "T" && e[t + 5] === "I" && e[t + 6] === "T" && e[t + 7] === "Y";
    }
    function Ue(e, t) {
        return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "L" && e[t + 4] === "E" && e[t + 5] === "M" && e[t + 6] === "E" && e[t + 7] === "N" && e[t + 8] === "T";
    }
    function Ye(e, t) {
        return e[t + 1] === "!" && e[t + 2] === "A" && e[t + 3] === "T" && e[t + 4] === "T" && e[t + 5] === "L" && e[t + 6] === "I" && e[t + 7] === "S" && e[t + 8] === "T";
    }
    function Je(e, t) {
        return e[t + 1] === "!" && e[t + 2] === "N" && e[t + 3] === "O" && e[t + 4] === "T" && e[t + 5] === "A" && e[t + 6] === "T" && e[t + 7] === "I" && e[t + 8] === "O" && e[t + 9] === "N";
    }
    function We(e) {
        if (qe.isName(e)) return e;
        throw new Error(`Invalid entity name ${e}`);
    }
    j.exports = Re;
});
var te = b1((Rt, ee)=>{
    "use strict";
    var M = C(), w = H(), Ke = D(), Qe = me("strnum"), qt = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, M.nameRegexp), F = class {
        constructor(t){
            this.options = t, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
                apos: {
                    regex: /&(apos|#39|#x27);/g,
                    val: "'"
                },
                gt: {
                    regex: /&(gt|#62|#x3E);/g,
                    val: ">"
                },
                lt: {
                    regex: /&(lt|#60|#x3C);/g,
                    val: "<"
                },
                quot: {
                    regex: /&(quot|#34|#x22);/g,
                    val: '"'
                }
            }, this.ampEntity = {
                regex: /&(amp|#38|#x26);/g,
                val: "&"
            }, this.htmlEntities = {
                space: {
                    regex: /&(nbsp|#160);/g,
                    val: " "
                },
                cent: {
                    regex: /&(cent|#162);/g,
                    val: "\xA2"
                },
                pound: {
                    regex: /&(pound|#163);/g,
                    val: "\xA3"
                },
                yen: {
                    regex: /&(yen|#165);/g,
                    val: "\xA5"
                },
                euro: {
                    regex: /&(euro|#8364);/g,
                    val: "\u20AC"
                },
                copyright: {
                    regex: /&(copy|#169);/g,
                    val: "\xA9"
                },
                reg: {
                    regex: /&(reg|#174);/g,
                    val: "\xAE"
                },
                inr: {
                    regex: /&(inr|#8377);/g,
                    val: "\u20B9"
                }
            }, this.addExternalEntities = Ze, this.parseXml = et, this.parseTextData = ze, this.resolveNameSpace = He, this.buildAttributesMap = De, this.isItStopNode = rt, this.replaceEntitiesValue = st, this.readStopNodeData = ot, this.saveTextToParentTag = nt, this.addChild = tt;
        }
    };
    function Ze(e) {
        let t = Object.keys(e);
        for(let s = 0; s < t.length; s++){
            let i = t[s];
            this.lastEntities[i] = {
                regex: new RegExp("&" + i + ";", "g"),
                val: e[i]
            };
        }
    }
    function ze(e, t, s, i, r, n, f) {
        if (e !== void 0 && (this.options.trimValues && !i && (e = e.trim()), e.length > 0)) {
            f || (e = this.replaceEntitiesValue(e));
            let u = this.options.tagValueProcessor(t, e, s, r, n);
            return u == null ? e : typeof u != typeof e || u !== e ? u : this.options.trimValues ? B(e, this.options.parseTagValue, this.options.numberParseOptions) : e.trim() === e ? B(e, this.options.parseTagValue, this.options.numberParseOptions) : e;
        }
    }
    function He(e) {
        if (this.options.removeNSPrefix) {
            let t = e.split(":"), s = e.charAt(0) === "/" ? "/" : "";
            if (t[0] === "xmlns") return "";
            t.length === 2 && (e = s + t[1]);
        }
        return e;
    }
    var je = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function De(e, t, s) {
        if (!this.options.ignoreAttributes && typeof e == "string") {
            let i = M.getAllMatches(e, je), r = i.length, n = {};
            for(let f = 0; f < r; f++){
                let u = this.resolveNameSpace(i[f][1]), o = i[f][4], l = this.options.attributeNamePrefix + u;
                if (u.length) if (this.options.transformAttributeName && (l = this.options.transformAttributeName(l)), l === "__proto__" && (l = "#__proto__"), o !== void 0) {
                    this.options.trimValues && (o = o.trim()), o = this.replaceEntitiesValue(o);
                    let a = this.options.attributeValueProcessor(u, o, t);
                    a == null ? n[l] = o : typeof a != typeof o || a !== o ? n[l] = a : n[l] = B(o, this.options.parseAttributeValue, this.options.numberParseOptions);
                } else this.options.allowBooleanAttributes && (n[l] = !0);
            }
            if (!Object.keys(n).length) return;
            if (this.options.attributesGroupName) {
                let f = {};
                return f[this.options.attributesGroupName] = n, f;
            }
            return n;
        }
    }
    var et = function(e) {
        e = e.replace(/\r\n?/g, `
`);
        let t = new w("!xml"), s = t, i = "", r = "";
        for(let n = 0; n < e.length; n++)if (e[n] === "<") if (e[n + 1] === "/") {
            let u = m(e, ">", n, "Closing Tag is not closed."), o = e.substring(n + 2, u).trim();
            if (this.options.removeNSPrefix) {
                let d = o.indexOf(":");
                d !== -1 && (o = o.substr(d + 1));
            }
            this.options.transformTagName && (o = this.options.transformTagName(o)), s && (i = this.saveTextToParentTag(i, s, r));
            let l = r.substring(r.lastIndexOf(".") + 1);
            if (o && this.options.unpairedTags.indexOf(o) !== -1) throw new Error(`Unpaired tag can not be used as closing tag: </${o}>`);
            let a = 0;
            l && this.options.unpairedTags.indexOf(l) !== -1 ? (a = r.lastIndexOf(".", r.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : a = r.lastIndexOf("."), r = r.substring(0, a), s = this.tagsNodeStack.pop(), i = "", n = u;
        } else if (e[n + 1] === "?") {
            let u = L(e, n, !1, "?>");
            if (!u) throw new Error("Pi Tag is not closed.");
            if (i = this.saveTextToParentTag(i, s, r), !(this.options.ignoreDeclaration && u.tagName === "?xml" || this.options.ignorePiTags)) {
                let o = new w(u.tagName);
                o.add(this.options.textNodeName, ""), u.tagName !== u.tagExp && u.attrExpPresent && (o[":@"] = this.buildAttributesMap(u.tagExp, r, u.tagName)), this.addChild(s, o, r);
            }
            n = u.closeIndex + 1;
        } else if (e.substr(n + 1, 3) === "!--") {
            let u = m(e, "-->", n + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
                let o = e.substring(n + 4, u - 2);
                i = this.saveTextToParentTag(i, s, r), s.add(this.options.commentPropName, [
                    {
                        [this.options.textNodeName]: o
                    }
                ]);
            }
            n = u;
        } else if (e.substr(n + 1, 2) === "!D") {
            let u = Ke(e, n);
            this.docTypeEntities = u.entities, n = u.i;
        } else if (e.substr(n + 1, 2) === "![") {
            let u = m(e, "]]>", n, "CDATA is not closed.") - 2, o = e.substring(n + 9, u);
            if (i = this.saveTextToParentTag(i, s, r), this.options.cdataPropName) s.add(this.options.cdataPropName, [
                {
                    [this.options.textNodeName]: o
                }
            ]);
            else {
                let l = this.parseTextData(o, s.tagname, r, !0, !1, !0);
                l == null && (l = ""), s.add(this.options.textNodeName, l);
            }
            n = u + 2;
        } else {
            let u = L(e, n, this.options.removeNSPrefix), o = u.tagName, l = u.tagExp, a = u.attrExpPresent, d = u.closeIndex;
            this.options.transformTagName && (o = this.options.transformTagName(o)), s && i && s.tagname !== "!xml" && (i = this.saveTextToParentTag(i, s, r, !1));
            let g = s;
            if (g && this.options.unpairedTags.indexOf(g.tagname) !== -1 && (s = this.tagsNodeStack.pop(), r = r.substring(0, r.lastIndexOf("."))), o !== t.tagname && (r += r ? "." + o : o), this.isItStopNode(this.options.stopNodes, r, o)) {
                let c = "";
                if (l.length > 0 && l.lastIndexOf("/") === l.length - 1) n = u.closeIndex;
                else if (this.options.unpairedTags.indexOf(o) !== -1) n = u.closeIndex;
                else {
                    let P = this.readStopNodeData(e, o, d + 1);
                    if (!P) throw new Error(`Unexpected end of ${o}`);
                    n = P.i, c = P.tagContent;
                }
                let N = new w(o);
                o !== l && a && (N[":@"] = this.buildAttributesMap(l, r, o)), c && (c = this.parseTextData(c, o, r, !0, a, !0, !0)), r = r.substr(0, r.lastIndexOf(".")), N.add(this.options.textNodeName, c), this.addChild(s, N, r);
            } else {
                if (l.length > 0 && l.lastIndexOf("/") === l.length - 1) {
                    o[o.length - 1] === "/" ? (o = o.substr(0, o.length - 1), l = o) : l = l.substr(0, l.length - 1), this.options.transformTagName && (o = this.options.transformTagName(o));
                    let c = new w(o);
                    o !== l && a && (c[":@"] = this.buildAttributesMap(l, r, o)), this.addChild(s, c, r), r = r.substr(0, r.lastIndexOf("."));
                } else {
                    let c = new w(o);
                    this.tagsNodeStack.push(s), o !== l && a && (c[":@"] = this.buildAttributesMap(l, r, o)), this.addChild(s, c, r), s = c;
                }
                i = "", n = d;
            }
        }
        else i += e[n];
        return t.child;
    };
    function tt(e, t, s) {
        let i = this.options.updateTag(t.tagname, s, t[":@"]);
        i === !1 || (typeof i == "string" && (t.tagname = i), e.addChild(t));
    }
    var st = function(e) {
        if (this.options.processEntities) {
            for(let t in this.docTypeEntities){
                let s = this.docTypeEntities[t];
                e = e.replace(s.regx, s.val);
            }
            for(let t in this.lastEntities){
                let s = this.lastEntities[t];
                e = e.replace(s.regex, s.val);
            }
            if (this.options.htmlEntities) for(let t in this.htmlEntities){
                let s = this.htmlEntities[t];
                e = e.replace(s.regex, s.val);
            }
            e = e.replace(this.ampEntity.regex, this.ampEntity.val);
        }
        return e;
    };
    function nt(e, t, s, i) {
        return e && (i === void 0 && (i = Object.keys(t.child).length === 0), e = this.parseTextData(e, t.tagname, s, !1, t[":@"] ? Object.keys(t[":@"]).length !== 0 : !1, i), e !== void 0 && e !== "" && t.add(this.options.textNodeName, e), e = ""), e;
    }
    function rt(e, t, s) {
        let i = "*." + s;
        for(let r in e){
            let n = e[r];
            if (i === n || t === n) return !0;
        }
        return !1;
    }
    function it(e, t, s = ">") {
        let i, r = "";
        for(let n = t; n < e.length; n++){
            let f = e[n];
            if (i) f === i && (i = "");
            else if (f === '"' || f === "'") i = f;
            else if (f === s[0]) if (s[1]) {
                if (e[n + 1] === s[1]) return {
                    data: r,
                    index: n
                };
            } else return {
                data: r,
                index: n
            };
            else f === "	" && (f = " ");
            r += f;
        }
    }
    function m(e, t, s, i) {
        let r = e.indexOf(t, s);
        if (r === -1) throw new Error(i);
        return r + t.length - 1;
    }
    function L(e, t, s, i = ">") {
        let r = it(e, t + 1, i);
        if (!r) return;
        let n = r.data, f = r.index, u = n.search(/\s/), o = n, l = !0;
        if (u !== -1 && (o = n.substr(0, u).replace(/\s\s*$/, ""), n = n.substr(u + 1)), s) {
            let a = o.indexOf(":");
            a !== -1 && (o = o.substr(a + 1), l = o !== r.data.substr(a + 1));
        }
        return {
            tagName: o,
            tagExp: n,
            closeIndex: f,
            attrExpPresent: l
        };
    }
    function ot(e, t, s) {
        let i = s, r = 1;
        for(; s < e.length; s++)if (e[s] === "<") if (e[s + 1] === "/") {
            let n = m(e, ">", s, `${t} is not closed`);
            if (e.substring(s + 2, n).trim() === t && (r--, r === 0)) return {
                tagContent: e.substring(i, s),
                i: n
            };
            s = n;
        } else if (e[s + 1] === "?") s = m(e, "?>", s + 1, "StopNode is not closed.");
        else if (e.substr(s + 1, 3) === "!--") s = m(e, "-->", s + 3, "StopNode is not closed.");
        else if (e.substr(s + 1, 2) === "![") s = m(e, "]]>", s, "StopNode is not closed.") - 2;
        else {
            let n = L(e, s, ">");
            n && ((n && n.tagName) === t && n.tagExp[n.tagExp.length - 1] !== "/" && r++, s = n.closeIndex);
        }
    }
    function B(e, t, s) {
        if (t && typeof e == "string") {
            let i = e.trim();
            return i === "true" ? !0 : i === "false" ? !1 : Qe(e, s);
        } else return M.isExist(e) ? e : "";
    }
    ee.exports = F;
});
var re1 = b1((ne)=>{
    "use strict";
    function ut(e, t) {
        return se(e, t);
    }
    function se(e, t, s) {
        let i, r = {};
        for(let n = 0; n < e.length; n++){
            let f = e[n], u = ft(f), o = "";
            if (s === void 0 ? o = u : o = s + "." + u, u === t.textNodeName) i === void 0 ? i = f[u] : i += "" + f[u];
            else {
                if (u === void 0) continue;
                if (f[u]) {
                    let l = se(f[u], t, o), a = at(l, t);
                    f[":@"] ? lt(l, f[":@"], o, t) : Object.keys(l).length === 1 && l[t.textNodeName] !== void 0 && !t.alwaysCreateTextNode ? l = l[t.textNodeName] : Object.keys(l).length === 0 && (t.alwaysCreateTextNode ? l[t.textNodeName] = "" : l = ""), r[u] !== void 0 && r.hasOwnProperty(u) ? (Array.isArray(r[u]) || (r[u] = [
                        r[u]
                    ]), r[u].push(l)) : t.isArray(u, o, a) ? r[u] = [
                        l
                    ] : r[u] = l;
                }
            }
        }
        return typeof i == "string" ? i.length > 0 && (r[t.textNodeName] = i) : i !== void 0 && (r[t.textNodeName] = i), r;
    }
    function ft(e) {
        let t = Object.keys(e);
        for(let s = 0; s < t.length; s++){
            let i = t[s];
            if (i !== ":@") return i;
        }
    }
    function lt(e, t, s, i) {
        if (t) {
            let r = Object.keys(t), n = r.length;
            for(let f = 0; f < n; f++){
                let u = r[f];
                i.isArray(u, s + "." + u, !0, !0) ? e[u] = [
                    t[u]
                ] : e[u] = t[u];
            }
        }
    }
    function at(e, t) {
        let { textNodeName: s } = t, i = Object.keys(e).length;
        return !!(i === 0 || i === 1 && (e[s] || typeof e[s] == "boolean" || e[s] === 0));
    }
    ne.prettify = ut;
});
var oe = b1((kt, ie)=>{
    var { buildOptions: dt } = Z1(), ct = te(), { prettify: ht } = re1(), gt = v(), q = class {
        constructor(t){
            this.externalEntities = {}, this.options = dt(t);
        }
        parse(t, s) {
            if (typeof t != "string") if (t.toString) t = t.toString();
            else throw new Error("XML data is accepted in String or Bytes[] form.");
            if (s) {
                s === !0 && (s = {});
                let n = gt.validate(t, s);
                if (n !== !0) throw Error(`${n.err.msg}:${n.err.line}:${n.err.col}`);
            }
            let i = new ct(this.options);
            i.addExternalEntities(this.externalEntities);
            let r = i.parseXml(t);
            return this.options.preserveOrder || r === void 0 ? r : ht(r, this.options);
        }
        addEntity(t, s) {
            if (s.indexOf("&") !== -1) throw new Error("Entity value can't have '&'");
            if (t.indexOf("&") !== -1 || t.indexOf(";") !== -1) throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
            if (s === "&") throw new Error("An entity with value '&' is not permitted");
            this.externalEntities[t] = s;
        }
    };
    ie.exports = q;
});
var de = b1((Gt, ae)=>{
    var pt = `
`;
    function Nt(e, t) {
        let s = "";
        return t.format && t.indentBy.length > 0 && (s = pt), fe(e, t, "", s);
    }
    function fe(e, t, s, i) {
        let r = "", n = !1;
        for(let f = 0; f < e.length; f++){
            let u = e[f], o = bt(u), l = "";
            if (s.length === 0 ? l = o : l = `${s}.${o}`, o === t.textNodeName) {
                let N = u[o];
                Et(l, t) || (N = t.tagValueProcessor(o, N), N = le(N, t)), n && (r += i), r += N, n = !1;
                continue;
            } else if (o === t.cdataPropName) {
                n && (r += i), r += `<![CDATA[${u[o][0][t.textNodeName]}]]>`, n = !1;
                continue;
            } else if (o === t.commentPropName) {
                r += i + `<!--${u[o][0][t.textNodeName]}-->`, n = !0;
                continue;
            } else if (o[0] === "?") {
                let N = ue(u[":@"], t), P = o === "?xml" ? "" : i, O = u[o][0][t.textNodeName];
                O = O.length !== 0 ? " " + O : "", r += P + `<${o}${O}${N}?>`, n = !0;
                continue;
            }
            let a = i;
            a !== "" && (a += t.indentBy);
            let d = ue(u[":@"], t), g = i + `<${o}${d}`, c = fe(u[o], t, l, a);
            t.unpairedTags.indexOf(o) !== -1 ? t.suppressUnpairedNode ? r += g + ">" : r += g + "/>" : (!c || c.length === 0) && t.suppressEmptyNode ? r += g + "/>" : c && c.endsWith(">") ? r += g + `>${c}${i}</${o}>` : (r += g + ">", c && i !== "" && (c.includes("/>") || c.includes("</")) ? r += i + t.indentBy + c + i : r += c, r += `</${o}>`), n = !0;
        }
        return r;
    }
    function bt(e) {
        let t = Object.keys(e);
        for(let s = 0; s < t.length; s++){
            let i = t[s];
            if (i !== ":@") return i;
        }
    }
    function ue(e, t) {
        let s = "";
        if (e && !t.ignoreAttributes) for(let i in e){
            let r = t.attributeValueProcessor(i, e[i]);
            r = le(r, t), r === !0 && t.suppressBooleanAttributes ? s += ` ${i.substr(t.attributeNamePrefix.length)}` : s += ` ${i.substr(t.attributeNamePrefix.length)}="${r}"`;
        }
        return s;
    }
    function Et(e, t) {
        e = e.substr(0, e.length - t.textNodeName.length - 1);
        let s = e.substr(e.lastIndexOf(".") + 1);
        for(let i in t.stopNodes)if (t.stopNodes[i] === e || t.stopNodes[i] === "*." + s) return !0;
        return !1;
    }
    function le(e, t) {
        if (e && e.length > 0 && t.processEntities) for(let s = 0; s < t.entities.length; s++){
            let i = t.entities[s];
            e = e.replace(i.regex, i.val);
        }
        return e;
    }
    ae.exports = Nt;
});
var he = b1((Ut, ce)=>{
    "use strict";
    var Tt = de(), yt = {
        attributeNamePrefix: "@_",
        attributesGroupName: !1,
        textNodeName: "#text",
        ignoreAttributes: !0,
        cdataPropName: !1,
        format: !1,
        indentBy: "  ",
        suppressEmptyNode: !1,
        suppressUnpairedNode: !0,
        suppressBooleanAttributes: !0,
        tagValueProcessor: function(e, t) {
            return t;
        },
        attributeValueProcessor: function(e, t) {
            return t;
        },
        preserveOrder: !1,
        commentPropName: !1,
        unpairedTags: [],
        entities: [
            {
                regex: new RegExp("&", "g"),
                val: "&amp;"
            },
            {
                regex: new RegExp(">", "g"),
                val: "&gt;"
            },
            {
                regex: new RegExp("<", "g"),
                val: "&lt;"
            },
            {
                regex: new RegExp("'", "g"),
                val: "&apos;"
            },
            {
                regex: new RegExp('"', "g"),
                val: "&quot;"
            }
        ],
        processEntities: !0,
        stopNodes: [],
        oneListGroup: !1
    };
    function T(e) {
        this.options = Object.assign({}, yt, e), this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
            return !1;
        } : (this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = Pt), this.processTextOrObjNode = At, this.options.format ? (this.indentate = mt, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
            return "";
        }, this.tagEndChar = ">", this.newLine = "");
    }
    T.prototype.build = function(e) {
        return this.options.preserveOrder ? Tt(e, this.options) : (Array.isArray(e) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (e = {
            [this.options.arrayNodeName]: e
        }), this.j2x(e, 0).val);
    };
    T.prototype.j2x = function(e, t) {
        let s = "", i = "";
        for(let r in e)if (!(typeof e[r] > "u")) if (e[r] === null) r[0] === "?" ? i += this.indentate(t) + "<" + r + "?" + this.tagEndChar : i += this.indentate(t) + "<" + r + "/" + this.tagEndChar;
        else if (e[r] instanceof Date) i += this.buildTextValNode(e[r], r, "", t);
        else if (typeof e[r] != "object") {
            let n = this.isAttribute(r);
            if (n) s += this.buildAttrPairStr(n, "" + e[r]);
            else if (r === this.options.textNodeName) {
                let f = this.options.tagValueProcessor(r, "" + e[r]);
                i += this.replaceEntitiesValue(f);
            } else i += this.buildTextValNode(e[r], r, "", t);
        } else if (Array.isArray(e[r])) {
            let n = e[r].length, f = "";
            for(let u = 0; u < n; u++){
                let o = e[r][u];
                typeof o > "u" || (o === null ? r[0] === "?" ? i += this.indentate(t) + "<" + r + "?" + this.tagEndChar : i += this.indentate(t) + "<" + r + "/" + this.tagEndChar : typeof o == "object" ? this.options.oneListGroup ? f += this.j2x(o, t + 1).val : f += this.processTextOrObjNode(o, r, t) : f += this.buildTextValNode(o, r, "", t));
            }
            this.options.oneListGroup && (f = this.buildObjectNode(f, r, "", t)), i += f;
        } else if (this.options.attributesGroupName && r === this.options.attributesGroupName) {
            let n = Object.keys(e[r]), f = n.length;
            for(let u = 0; u < f; u++)s += this.buildAttrPairStr(n[u], "" + e[r][n[u]]);
        } else i += this.processTextOrObjNode(e[r], r, t);
        return {
            attrStr: s,
            val: i
        };
    };
    T.prototype.buildAttrPairStr = function(e, t) {
        return t = this.options.attributeValueProcessor(e, "" + t), t = this.replaceEntitiesValue(t), this.options.suppressBooleanAttributes && t === "true" ? " " + e : " " + e + '="' + t + '"';
    };
    function At(e, t, s) {
        let i = this.j2x(e, s + 1);
        return e[this.options.textNodeName] !== void 0 && Object.keys(e).length === 1 ? this.buildTextValNode(e[this.options.textNodeName], t, i.attrStr, s) : this.buildObjectNode(i.val, t, i.attrStr, s);
    }
    T.prototype.buildObjectNode = function(e, t, s, i) {
        if (e === "") return t[0] === "?" ? this.indentate(i) + "<" + t + s + "?" + this.tagEndChar : this.indentate(i) + "<" + t + s + this.closeTag(t) + this.tagEndChar;
        {
            let r = "</" + t + this.tagEndChar, n = "";
            return t[0] === "?" && (n = "?", r = ""), s && e.indexOf("<") === -1 ? this.indentate(i) + "<" + t + s + n + ">" + e + r : this.options.commentPropName !== !1 && t === this.options.commentPropName && n.length === 0 ? this.indentate(i) + `<!--${e}-->` + this.newLine : this.indentate(i) + "<" + t + s + n + this.tagEndChar + e + this.indentate(i) + r;
        }
    };
    T.prototype.closeTag = function(e) {
        let t = "";
        return this.options.unpairedTags.indexOf(e) !== -1 ? this.options.suppressUnpairedNode || (t = "/") : this.options.suppressEmptyNode ? t = "/" : t = `></${e}`, t;
    };
    T.prototype.buildTextValNode = function(e, t, s, i) {
        if (this.options.cdataPropName !== !1 && t === this.options.cdataPropName) return this.indentate(i) + `<![CDATA[${e}]]>` + this.newLine;
        if (this.options.commentPropName !== !1 && t === this.options.commentPropName) return this.indentate(i) + `<!--${e}-->` + this.newLine;
        if (t[0] === "?") return this.indentate(i) + "<" + t + s + "?" + this.tagEndChar;
        {
            let r = this.options.tagValueProcessor(t, e);
            return r = this.replaceEntitiesValue(r), r === "" ? this.indentate(i) + "<" + t + s + this.closeTag(t) + this.tagEndChar : this.indentate(i) + "<" + t + s + ">" + r + "</" + t + this.tagEndChar;
        }
    };
    T.prototype.replaceEntitiesValue = function(e) {
        if (e && e.length > 0 && this.options.processEntities) for(let t = 0; t < this.options.entities.length; t++){
            let s = this.options.entities[t];
            e = e.replace(s.regex, s.val);
        }
        return e;
    };
    function mt(e) {
        return this.options.indentBy.repeat(e);
    }
    function Pt(e) {
        return e.startsWith(this.options.attributeNamePrefix) ? e.substr(this.attrPrefixLen) : !1;
    }
    ce.exports = T;
});
var R2 = b1((Yt, ge)=>{
    "use strict";
    var It = v(), wt = oe(), Ot = he();
    ge.exports = {
        XMLParser: wt,
        XMLValidator: It,
        XMLBuilder: Ot
    };
});
var y = {};
Pe(y, {
    XMLBuilder: ()=>xt,
    XMLParser: ()=>Ct,
    XMLValidator: ()=>St,
    default: ()=>vt
});
var Ne = X(R2());
A(y, X(R2()));
var { XMLParser: Ct, XMLValidator: St, XMLBuilder: xt } = Ne, { default: pe, ...Vt } = Ne, vt = pe !== void 0 ? pe : Vt;
const MAX_BITS = 15;
const D_CODES = 30;
const BL_CODES = 19;
const LITERALS = 256;
const L_CODES = 256 + 1 + 29;
const HEAP_SIZE = 2 * L_CODES + 1;
const END_BLOCK = 256;
const MAX_BL_BITS = 7;
const Buf_size = 8 * 2;
const Z_DEFAULT_COMPRESSION = -1;
const Z_HUFFMAN_ONLY = 2;
const Z_DEFAULT_STRATEGY = 0;
const Z_NO_FLUSH = 0;
const Z_PARTIAL_FLUSH = 1;
const Z_FULL_FLUSH = 3;
const Z_FINISH = 4;
const Z_OK = 0;
const Z_STREAM_END = 1;
const Z_NEED_DICT = 2;
const Z_STREAM_ERROR = -2;
const Z_DATA_ERROR = -3;
const Z_BUF_ERROR = -5;
function extractArray(array) {
    return flatArray(array.map(([length, value1])=>new Array(length).fill(value1, 0, length)));
}
function flatArray(array) {
    return array.reduce((a, b)=>a.concat(Array.isArray(b) ? flatArray(b) : b), []);
}
const _dist_code = [
    0,
    1,
    2,
    3
].concat(...extractArray([
    [
        2,
        4
    ],
    [
        2,
        5
    ],
    [
        4,
        6
    ],
    [
        4,
        7
    ],
    [
        8,
        8
    ],
    [
        8,
        9
    ],
    [
        16,
        10
    ],
    [
        16,
        11
    ],
    [
        32,
        12
    ],
    [
        32,
        13
    ],
    [
        64,
        14
    ],
    [
        64,
        15
    ],
    [
        2,
        0
    ],
    [
        1,
        16
    ],
    [
        1,
        17
    ],
    [
        2,
        18
    ],
    [
        2,
        19
    ],
    [
        4,
        20
    ],
    [
        4,
        21
    ],
    [
        8,
        22
    ],
    [
        8,
        23
    ],
    [
        16,
        24
    ],
    [
        16,
        25
    ],
    [
        32,
        26
    ],
    [
        32,
        27
    ],
    [
        64,
        28
    ],
    [
        64,
        29
    ]
]));
function Tree() {
    const that = this;
    function gen_bitlen(s) {
        const tree = that.dyn_tree;
        const stree = that.stat_desc.static_tree;
        const extra = that.stat_desc.extra_bits;
        const base = that.stat_desc.extra_base;
        const max_length = that.stat_desc.max_length;
        let h;
        let n, m;
        let bits;
        let xbits;
        let f;
        let overflow = 0;
        for(bits = 0; bits <= 15; bits++)s.bl_count[bits] = 0;
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for(h = s.heap_max + 1; h < HEAP_SIZE; h++){
            n = s.heap[h];
            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
                bits = max_length;
                overflow++;
            }
            tree[n * 2 + 1] = bits;
            if (n > that.max_code) continue;
            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) xbits = extra[n - base];
            f = tree[n * 2];
            s.opt_len += f * (bits + xbits);
            if (stree) s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
        if (overflow === 0) return;
        do {
            bits = max_length - 1;
            while(s.bl_count[bits] === 0)bits--;
            s.bl_count[bits]--;
            s.bl_count[bits + 1] += 2;
            s.bl_count[max_length]--;
            overflow -= 2;
        }while (overflow > 0)
        for(bits = max_length; bits !== 0; bits--){
            n = s.bl_count[bits];
            while(n !== 0){
                m = s.heap[--h];
                if (m > that.max_code) continue;
                if (tree[m * 2 + 1] != bits) {
                    s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                    tree[m * 2 + 1] = bits;
                }
                n--;
            }
        }
    }
    function bi_reverse(code, len) {
        let res = 0;
        do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
        }while (--len > 0)
        return res >>> 1;
    }
    function gen_codes(tree, max_code, bl_count) {
        const next_code = [];
        let code = 0;
        let bits;
        let n;
        let len;
        for(bits = 1; bits <= 15; bits++){
            next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        for(n = 0; n <= max_code; n++){
            len = tree[n * 2 + 1];
            if (len === 0) continue;
            tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
    }
    that.build_tree = function(s) {
        const tree = that.dyn_tree;
        const stree = that.stat_desc.static_tree;
        const elems = that.stat_desc.elems;
        let n, m;
        let max_code = -1;
        let node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for(n = 0; n < elems; n++){
            if (tree[n * 2] !== 0) {
                s.heap[++s.heap_len] = max_code = n;
                s.depth[n] = 0;
            } else {
                tree[n * 2 + 1] = 0;
            }
        }
        while(s.heap_len < 2){
            node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s.depth[node] = 0;
            s.opt_len--;
            if (stree) s.static_len -= stree[node * 2 + 1];
        }
        that.max_code = max_code;
        for(n = Math.floor(s.heap_len / 2); n >= 1; n--)s.pqdownheap(tree, n);
        node = elems;
        do {
            n = s.heap[1];
            s.heap[1] = s.heap[s.heap_len--];
            s.pqdownheap(tree, 1);
            m = s.heap[1];
            s.heap[--s.heap_max] = n;
            s.heap[--s.heap_max] = m;
            tree[node * 2] = tree[n * 2] + tree[m * 2];
            s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;
            tree[n * 2 + 1] = tree[m * 2 + 1] = node;
            s.heap[1] = node++;
            s.pqdownheap(tree, 1);
        }while (s.heap_len >= 2)
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s);
        gen_codes(tree, that.max_code, s.bl_count);
    };
}
Tree._length_code = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7
].concat(...extractArray([
    [
        2,
        8
    ],
    [
        2,
        9
    ],
    [
        2,
        10
    ],
    [
        2,
        11
    ],
    [
        4,
        12
    ],
    [
        4,
        13
    ],
    [
        4,
        14
    ],
    [
        4,
        15
    ],
    [
        8,
        16
    ],
    [
        8,
        17
    ],
    [
        8,
        18
    ],
    [
        8,
        19
    ],
    [
        16,
        20
    ],
    [
        16,
        21
    ],
    [
        16,
        22
    ],
    [
        16,
        23
    ],
    [
        32,
        24
    ],
    [
        32,
        25
    ],
    [
        32,
        26
    ],
    [
        31,
        27
    ],
    [
        1,
        28
    ]
]));
Tree.base_length = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    10,
    12,
    14,
    16,
    20,
    24,
    28,
    32,
    40,
    48,
    56,
    64,
    80,
    96,
    112,
    128,
    160,
    192,
    224,
    0
];
Tree.base_dist = [
    0,
    1,
    2,
    3,
    4,
    6,
    8,
    12,
    16,
    24,
    32,
    48,
    64,
    96,
    128,
    192,
    256,
    384,
    512,
    768,
    1024,
    1536,
    2048,
    3072,
    4096,
    6144,
    8192,
    12288,
    16384,
    24576
];
Tree.d_code = function(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
Tree.extra_lbits = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0
];
Tree.extra_dbits = [
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
];
Tree.extra_blbits = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    3,
    7
];
Tree.bl_order = [
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
];
function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {
    const that = this;
    that.static_tree = static_tree;
    that.extra_bits = extra_bits;
    that.extra_base = extra_base;
    that.elems = elems;
    that.max_length = max_length;
}
const static_ltree2_first_part = [
    12,
    140,
    76,
    204,
    44,
    172,
    108,
    236,
    28,
    156,
    92,
    220,
    60,
    188,
    124,
    252,
    2,
    130,
    66,
    194,
    34,
    162,
    98,
    226,
    18,
    146,
    82,
    210,
    50,
    178,
    114,
    242,
    10,
    138,
    74,
    202,
    42,
    170,
    106,
    234,
    26,
    154,
    90,
    218,
    58,
    186,
    122,
    250,
    6,
    134,
    70,
    198,
    38,
    166,
    102,
    230,
    22,
    150,
    86,
    214,
    54,
    182,
    118,
    246,
    14,
    142,
    78,
    206,
    46,
    174,
    110,
    238,
    30,
    158,
    94,
    222,
    62,
    190,
    126,
    254,
    1,
    129,
    65,
    193,
    33,
    161,
    97,
    225,
    17,
    145,
    81,
    209,
    49,
    177,
    113,
    241,
    9,
    137,
    73,
    201,
    41,
    169,
    105,
    233,
    25,
    153,
    89,
    217,
    57,
    185,
    121,
    249,
    5,
    133,
    69,
    197,
    37,
    165,
    101,
    229,
    21,
    149,
    85,
    213,
    53,
    181,
    117,
    245,
    13,
    141,
    77,
    205,
    45,
    173,
    109,
    237,
    29,
    157,
    93,
    221,
    61,
    189,
    125,
    253,
    19,
    275,
    147,
    403,
    83,
    339,
    211,
    467,
    51,
    307,
    179,
    435,
    115,
    371,
    243,
    499,
    11,
    267,
    139,
    395,
    75,
    331,
    203,
    459,
    43,
    299,
    171,
    427,
    107,
    363,
    235,
    491,
    27,
    283,
    155,
    411,
    91,
    347,
    219,
    475,
    59,
    315,
    187,
    443,
    123,
    379,
    251,
    507,
    7,
    263,
    135,
    391,
    71,
    327,
    199,
    455,
    39,
    295,
    167,
    423,
    103,
    359,
    231,
    487,
    23,
    279,
    151,
    407,
    87,
    343,
    215,
    471,
    55,
    311,
    183,
    439,
    119,
    375,
    247,
    503,
    15,
    271,
    143,
    399,
    79,
    335,
    207,
    463,
    47,
    303,
    175,
    431,
    111,
    367,
    239,
    495,
    31,
    287,
    159,
    415,
    95,
    351,
    223,
    479,
    63,
    319,
    191,
    447,
    127,
    383,
    255,
    511,
    0,
    64,
    32,
    96,
    16,
    80,
    48,
    112,
    8,
    72,
    40,
    104,
    24,
    88,
    56,
    120,
    4,
    68,
    36,
    100,
    20,
    84,
    52,
    116,
    3,
    131,
    67,
    195,
    35,
    163,
    99,
    227
];
const static_ltree2_second_part = extractArray([
    [
        144,
        8
    ],
    [
        112,
        9
    ],
    [
        24,
        7
    ],
    [
        8,
        8
    ]
]);
StaticTree.static_ltree = flatArray(static_ltree2_first_part.map((value1, index)=>[
        value1,
        static_ltree2_second_part[index]
    ]));
const static_dtree_first_part = [
    0,
    16,
    8,
    24,
    4,
    20,
    12,
    28,
    2,
    18,
    10,
    26,
    6,
    22,
    14,
    30,
    1,
    17,
    9,
    25,
    5,
    21,
    13,
    29,
    3,
    19,
    11,
    27,
    7,
    23
];
const static_dtree_second_part = extractArray([
    [
        30,
        5
    ]
]);
StaticTree.static_dtree = flatArray(static_dtree_first_part.map((value1, index)=>[
        value1,
        static_dtree_second_part[index]
    ]));
StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);
StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);
const MAX_MEM_LEVEL = 9;
const DEF_MEM_LEVEL = 8;
function Config(good_length, max_lazy, nice_length, max_chain, func) {
    const that = this;
    that.good_length = good_length;
    that.max_lazy = max_lazy;
    that.nice_length = nice_length;
    that.max_chain = max_chain;
    that.func = func;
}
const STORED = 0;
const FAST = 1;
const SLOW = 2;
const config_table = [
    new Config(0, 0, 0, 0, 0),
    new Config(4, 4, 8, 4, 1),
    new Config(4, 5, 16, 8, 1),
    new Config(4, 6, 32, 32, 1),
    new Config(4, 4, 16, 16, 2),
    new Config(8, 16, 32, 32, 2),
    new Config(8, 16, 128, 128, 2),
    new Config(8, 32, 128, 256, 2),
    new Config(32, 128, 258, 1024, 2),
    new Config(32, 258, 258, 4096, 2)
];
const z_errmsg = [
    "need dictionary",
    "stream end",
    "",
    "",
    "stream error",
    "data error",
    "",
    "buffer error",
    "",
    ""
];
const NeedMore = 0;
const BlockDone = 1;
const FinishStarted = 2;
const FinishDone = 3;
const PRESET_DICT = 0x20;
const INIT_STATE = 42;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const Z_DEFLATED = 8;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = 258 + 3 + 1;
function smaller(tree, n, m, depth) {
    const tn2 = tree[n * 2];
    const tm2 = tree[m * 2];
    return tn2 < tm2 || tn2 == tm2 && depth[n] <= depth[m];
}
function Deflate() {
    const that = this;
    let strm;
    let status;
    let pending_buf_size;
    let last_flush;
    let w_size;
    let w_bits;
    let w_mask;
    let win;
    let window_size;
    let prev;
    let head;
    let ins_h;
    let hash_size;
    let hash_bits;
    let hash_mask;
    let hash_shift;
    let block_start;
    let match_length;
    let prev_match;
    let match_available;
    let strstart;
    let match_start;
    let lookahead;
    let prev_length;
    let max_chain_length;
    let max_lazy_match;
    let level;
    let strategy;
    let good_match;
    let nice_match;
    let dyn_ltree;
    let dyn_dtree;
    let bl_tree;
    const l_desc = new Tree();
    const d_desc = new Tree();
    const bl_desc = new Tree();
    that.depth = [];
    let lit_bufsize;
    let last_lit;
    let matches;
    let last_eob_len;
    let bi_buf;
    let bi_valid;
    that.bl_count = [];
    that.heap = [];
    dyn_ltree = [];
    dyn_dtree = [];
    bl_tree = [];
    function lm_init() {
        window_size = 2 * w_size;
        head[hash_size - 1] = 0;
        for(let i = 0; i < hash_size - 1; i++){
            head[i] = 0;
        }
        max_lazy_match = config_table[level].max_lazy;
        good_match = config_table[level].good_length;
        nice_match = config_table[level].nice_length;
        max_chain_length = config_table[level].max_chain;
        strstart = 0;
        block_start = 0;
        lookahead = 0;
        match_length = prev_length = MIN_MATCH - 1;
        match_available = 0;
        ins_h = 0;
    }
    function init_block() {
        let i;
        for(i = 0; i < L_CODES; i++)dyn_ltree[i * 2] = 0;
        for(i = 0; i < 30; i++)dyn_dtree[i * 2] = 0;
        for(i = 0; i < 19; i++)bl_tree[i * 2] = 0;
        dyn_ltree[END_BLOCK * 2] = 1;
        that.opt_len = that.static_len = 0;
        last_lit = matches = 0;
    }
    function tr_init() {
        l_desc.dyn_tree = dyn_ltree;
        l_desc.stat_desc = StaticTree.static_l_desc;
        d_desc.dyn_tree = dyn_dtree;
        d_desc.stat_desc = StaticTree.static_d_desc;
        bl_desc.dyn_tree = bl_tree;
        bl_desc.stat_desc = StaticTree.static_bl_desc;
        bi_buf = 0;
        bi_valid = 0;
        last_eob_len = 8;
        init_block();
    }
    that.pqdownheap = function(tree, k) {
        const heap = that.heap;
        const v = heap[k];
        let j = k << 1;
        while(j <= that.heap_len){
            if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {
                j++;
            }
            if (smaller(tree, v, heap[j], that.depth)) break;
            heap[k] = heap[j];
            k = j;
            j <<= 1;
        }
        heap[k] = v;
    };
    function scan_tree(tree, max_code) {
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 0xffff;
        for(let n = 0; n <= max_code; n++){
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen == nextlen) {
                continue;
            } else if (count < min_count) {
                bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
                if (curlen != prevlen) bl_tree[curlen * 2]++;
                bl_tree[16 * 2]++;
            } else if (count <= 10) {
                bl_tree[17 * 2]++;
            } else {
                bl_tree[18 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen == nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    }
    function build_bl_tree() {
        let max_blindex;
        scan_tree(dyn_ltree, l_desc.max_code);
        scan_tree(dyn_dtree, d_desc.max_code);
        bl_desc.build_tree(that);
        for(max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--){
            if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0) break;
        }
        that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
    }
    function put_byte(p) {
        that.pending_buf[that.pending++] = p;
    }
    function put_short(w) {
        put_byte(w & 0xff);
        put_byte(w >>> 8 & 0xff);
    }
    function putShortMSB(b) {
        put_byte(b >> 8 & 0xff);
        put_byte(b & 0xff & 0xff);
    }
    function send_bits(value1, length) {
        let val1;
        const len = length;
        if (bi_valid > Buf_size - len) {
            val1 = value1;
            bi_buf |= val1 << bi_valid & 0xffff;
            put_short(bi_buf);
            bi_buf = val1 >>> Buf_size - bi_valid;
            bi_valid += len - Buf_size;
        } else {
            bi_buf |= value1 << bi_valid & 0xffff;
            bi_valid += len;
        }
    }
    function send_code(c, tree) {
        const c2 = c * 2;
        send_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);
    }
    function send_tree(tree, max_code) {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        for(n = 0; n <= max_code; n++){
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen == nextlen) {
                continue;
            } else if (count < min_count) {
                do {
                    send_code(curlen, bl_tree);
                }while (--count !== 0)
            } else if (curlen !== 0) {
                if (curlen != prevlen) {
                    send_code(curlen, bl_tree);
                    count--;
                }
                send_code(16, bl_tree);
                send_bits(count - 3, 2);
            } else if (count <= 10) {
                send_code(17, bl_tree);
                send_bits(count - 3, 3);
            } else {
                send_code(18, bl_tree);
                send_bits(count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen == nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    }
    function send_all_trees(lcodes, dcodes, blcodes) {
        let rank;
        send_bits(lcodes - 257, 5);
        send_bits(dcodes - 1, 5);
        send_bits(blcodes - 4, 4);
        for(rank = 0; rank < blcodes; rank++){
            send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);
        }
        send_tree(dyn_ltree, lcodes - 1);
        send_tree(dyn_dtree, dcodes - 1);
    }
    function bi_flush() {
        if (bi_valid == 16) {
            put_short(bi_buf);
            bi_buf = 0;
            bi_valid = 0;
        } else if (bi_valid >= 8) {
            put_byte(bi_buf & 0xff);
            bi_buf >>>= 8;
            bi_valid -= 8;
        }
    }
    function _tr_align() {
        send_bits(1 << 1, 3);
        send_code(256, StaticTree.static_ltree);
        bi_flush();
        if (1 + last_eob_len + 10 - bi_valid < 9) {
            send_bits(1 << 1, 3);
            send_code(256, StaticTree.static_ltree);
            bi_flush();
        }
        last_eob_len = 7;
    }
    function _tr_tally(dist, lc) {
        let out_length, in_length, dcode;
        that.dist_buf[last_lit] = dist;
        that.lc_buf[last_lit] = lc & 0xff;
        last_lit++;
        if (dist === 0) {
            dyn_ltree[lc * 2]++;
        } else {
            matches++;
            dist--;
            dyn_ltree[(Tree._length_code[lc] + 256 + 1) * 2]++;
            dyn_dtree[Tree.d_code(dist) * 2]++;
        }
        if ((last_lit & 0x1fff) === 0 && level > 2) {
            out_length = last_lit * 8;
            in_length = strstart - block_start;
            for(dcode = 0; dcode < 30; dcode++){
                out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
            }
            out_length >>>= 3;
            if (matches < Math.floor(last_lit / 2) && out_length < Math.floor(in_length / 2)) return true;
        }
        return last_lit == lit_bufsize - 1;
    }
    function compress_block(ltree, dtree) {
        let dist;
        let lc;
        let lx = 0;
        let code;
        let extra;
        if (last_lit !== 0) {
            do {
                dist = that.dist_buf[lx];
                lc = that.lc_buf[lx];
                lx++;
                if (dist === 0) {
                    send_code(lc, ltree);
                } else {
                    code = Tree._length_code[lc];
                    send_code(code + 256 + 1, ltree);
                    extra = Tree.extra_lbits[code];
                    if (extra !== 0) {
                        lc -= Tree.base_length[code];
                        send_bits(lc, extra);
                    }
                    dist--;
                    code = Tree.d_code(dist);
                    send_code(code, dtree);
                    extra = Tree.extra_dbits[code];
                    if (extra !== 0) {
                        dist -= Tree.base_dist[code];
                        send_bits(dist, extra);
                    }
                }
            }while (lx < last_lit)
        }
        send_code(256, ltree);
        last_eob_len = ltree[END_BLOCK * 2 + 1];
    }
    function bi_windup() {
        if (bi_valid > 8) {
            put_short(bi_buf);
        } else if (bi_valid > 0) {
            put_byte(bi_buf & 0xff);
        }
        bi_buf = 0;
        bi_valid = 0;
    }
    function copy_block(buf, len, header) {
        bi_windup();
        last_eob_len = 8;
        if (header) {
            put_short(len);
            put_short(~len);
        }
        that.pending_buf.set(win.subarray(buf, buf + len), that.pending);
        that.pending += len;
    }
    function _tr_stored_block(buf, stored_len, eof) {
        send_bits((0 << 1) + (eof ? 1 : 0), 3);
        copy_block(buf, stored_len, true);
    }
    function _tr_flush_block(buf, stored_len, eof) {
        let opt_lenb, static_lenb;
        let max_blindex = 0;
        if (level > 0) {
            l_desc.build_tree(that);
            d_desc.build_tree(that);
            max_blindex = build_bl_tree();
            opt_lenb = that.opt_len + 3 + 7 >>> 3;
            static_lenb = that.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
        } else {
            opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf != -1) {
            _tr_stored_block(buf, stored_len, eof);
        } else if (static_lenb == opt_lenb) {
            send_bits((1 << 1) + (eof ? 1 : 0), 3);
            compress_block(StaticTree.static_ltree, StaticTree.static_dtree);
        } else {
            send_bits((2 << 1) + (eof ? 1 : 0), 3);
            send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
            compress_block(dyn_ltree, dyn_dtree);
        }
        init_block();
        if (eof) {
            bi_windup();
        }
    }
    function flush_block_only(eof) {
        _tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);
        block_start = strstart;
        strm.flush_pending();
    }
    function fill_window() {
        let n, m;
        let p;
        let more;
        do {
            more = window_size - lookahead - strstart;
            if (more === 0 && strstart === 0 && lookahead === 0) {
                more = w_size;
            } else if (more == -1) {
                more--;
            } else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {
                win.set(win.subarray(w_size, w_size + w_size), 0);
                match_start -= w_size;
                strstart -= w_size;
                block_start -= w_size;
                n = hash_size;
                p = n;
                do {
                    m = head[--p] & 0xffff;
                    head[p] = m >= w_size ? m - w_size : 0;
                }while (--n !== 0)
                n = w_size;
                p = n;
                do {
                    m = prev[--p] & 0xffff;
                    prev[p] = m >= w_size ? m - w_size : 0;
                }while (--n !== 0)
                more += w_size;
            }
            if (strm.avail_in === 0) return;
            n = strm.read_buf(win, strstart + lookahead, more);
            lookahead += n;
            if (lookahead >= 3) {
                ins_h = win[strstart] & 0xff;
                ins_h = (ins_h << hash_shift ^ win[strstart + 1] & 0xff) & hash_mask;
            }
        }while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0)
    }
    function deflate_stored(flush) {
        let max_block_size = 0xffff;
        let max_start;
        if (max_block_size > pending_buf_size - 5) {
            max_block_size = pending_buf_size - 5;
        }
        while(true){
            if (lookahead <= 1) {
                fill_window();
                if (lookahead === 0 && flush == 0) return 0;
                if (lookahead === 0) break;
            }
            strstart += lookahead;
            lookahead = 0;
            max_start = block_start + max_block_size;
            if (strstart === 0 || strstart >= max_start) {
                lookahead = strstart - max_start;
                strstart = max_start;
                flush_block_only(false);
                if (strm.avail_out === 0) return 0;
            }
            if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {
                flush_block_only(false);
                if (strm.avail_out === 0) return 0;
            }
        }
        flush_block_only(flush == 4);
        if (strm.avail_out === 0) return flush == 4 ? 2 : 0;
        return flush == 4 ? 3 : 1;
    }
    function longest_match(cur_match) {
        let chain_length = max_chain_length;
        let scan = strstart;
        let match;
        let len;
        let best_len = prev_length;
        const limit = strstart > w_size - MIN_LOOKAHEAD ? strstart - (w_size - MIN_LOOKAHEAD) : 0;
        let _nice_match = nice_match;
        const wmask = w_mask;
        const strend = strstart + 258;
        let scan_end1 = win[scan + best_len - 1];
        let scan_end = win[scan + best_len];
        if (prev_length >= good_match) {
            chain_length >>= 2;
        }
        if (_nice_match > lookahead) _nice_match = lookahead;
        do {
            match = cur_match;
            if (win[match + best_len] != scan_end || win[match + best_len - 1] != scan_end1 || win[match] != win[scan] || win[++match] != win[scan + 1]) continue;
            scan += 2;
            match++;
            do {}while (win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && scan < strend)
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
                match_start = cur_match;
                best_len = len;
                if (len >= _nice_match) break;
                scan_end1 = win[scan + best_len - 1];
                scan_end = win[scan + best_len];
            }
        }while ((cur_match = prev[cur_match & wmask] & 0xffff) > limit && --chain_length !== 0)
        if (best_len <= lookahead) return best_len;
        return lookahead;
    }
    function deflate_fast(flush) {
        let hash_head = 0;
        let bflush;
        while(true){
            if (lookahead < MIN_LOOKAHEAD) {
                fill_window();
                if (lookahead < MIN_LOOKAHEAD && flush == 0) {
                    return 0;
                }
                if (lookahead === 0) break;
            }
            if (lookahead >= 3) {
                ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 0xff) & hash_mask;
                hash_head = head[ins_h] & 0xffff;
                prev[strstart & w_mask] = head[ins_h];
                head[ins_h] = strstart;
            }
            if (hash_head !== 0 && (strstart - hash_head & 0xffff) <= w_size - MIN_LOOKAHEAD) {
                if (strategy != 2) {
                    match_length = longest_match(hash_head);
                }
            }
            if (match_length >= 3) {
                bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);
                lookahead -= match_length;
                if (match_length <= max_lazy_match && lookahead >= 3) {
                    match_length--;
                    do {
                        strstart++;
                        ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 0xff) & hash_mask;
                        hash_head = head[ins_h] & 0xffff;
                        prev[strstart & w_mask] = head[ins_h];
                        head[ins_h] = strstart;
                    }while (--match_length !== 0)
                    strstart++;
                } else {
                    strstart += match_length;
                    match_length = 0;
                    ins_h = win[strstart] & 0xff;
                    ins_h = (ins_h << hash_shift ^ win[strstart + 1] & 0xff) & hash_mask;
                }
            } else {
                bflush = _tr_tally(0, win[strstart] & 0xff);
                lookahead--;
                strstart++;
            }
            if (bflush) {
                flush_block_only(false);
                if (strm.avail_out === 0) return 0;
            }
        }
        flush_block_only(flush == 4);
        if (strm.avail_out === 0) {
            if (flush == 4) return 2;
            else return 0;
        }
        return flush == 4 ? 3 : 1;
    }
    function deflate_slow(flush) {
        let hash_head = 0;
        let bflush;
        let max_insert;
        while(true){
            if (lookahead < MIN_LOOKAHEAD) {
                fill_window();
                if (lookahead < MIN_LOOKAHEAD && flush == 0) {
                    return 0;
                }
                if (lookahead === 0) break;
            }
            if (lookahead >= 3) {
                ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 0xff) & hash_mask;
                hash_head = head[ins_h] & 0xffff;
                prev[strstart & w_mask] = head[ins_h];
                head[ins_h] = strstart;
            }
            prev_length = match_length;
            prev_match = match_start;
            match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && prev_length < max_lazy_match && (strstart - hash_head & 0xffff) <= w_size - MIN_LOOKAHEAD) {
                if (strategy != 2) {
                    match_length = longest_match(hash_head);
                }
                if (match_length <= 5 && (strategy == 1 || match_length == 3 && strstart - match_start > 4096)) {
                    match_length = MIN_MATCH - 1;
                }
            }
            if (prev_length >= 3 && match_length <= prev_length) {
                max_insert = strstart + lookahead - MIN_MATCH;
                bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);
                lookahead -= prev_length - 1;
                prev_length -= 2;
                do {
                    if (++strstart <= max_insert) {
                        ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 0xff) & hash_mask;
                        hash_head = head[ins_h] & 0xffff;
                        prev[strstart & w_mask] = head[ins_h];
                        head[ins_h] = strstart;
                    }
                }while (--prev_length !== 0)
                match_available = 0;
                match_length = MIN_MATCH - 1;
                strstart++;
                if (bflush) {
                    flush_block_only(false);
                    if (strm.avail_out === 0) return 0;
                }
            } else if (match_available !== 0) {
                bflush = _tr_tally(0, win[strstart - 1] & 0xff);
                if (bflush) {
                    flush_block_only(false);
                }
                strstart++;
                lookahead--;
                if (strm.avail_out === 0) return 0;
            } else {
                match_available = 1;
                strstart++;
                lookahead--;
            }
        }
        if (match_available !== 0) {
            bflush = _tr_tally(0, win[strstart - 1] & 0xff);
            match_available = 0;
        }
        flush_block_only(flush == 4);
        if (strm.avail_out === 0) {
            if (flush == 4) return 2;
            else return 0;
        }
        return flush == 4 ? 3 : 1;
    }
    function deflateReset(strm) {
        strm.total_in = strm.total_out = 0;
        strm.msg = null;
        that.pending = 0;
        that.pending_out = 0;
        status = BUSY_STATE;
        last_flush = Z_NO_FLUSH;
        tr_init();
        lm_init();
        return 0;
    }
    that.deflateInit = function(strm, _level, bits, _method, memLevel, _strategy) {
        if (!_method) _method = Z_DEFLATED;
        if (!memLevel) memLevel = DEF_MEM_LEVEL;
        if (!_strategy) _strategy = Z_DEFAULT_STRATEGY;
        strm.msg = null;
        if (_level == Z_DEFAULT_COMPRESSION) _level = 6;
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
            return Z_STREAM_ERROR;
        }
        strm.dstate = that;
        w_bits = bits;
        w_size = 1 << w_bits;
        w_mask = w_size - 1;
        hash_bits = memLevel + 7;
        hash_size = 1 << hash_bits;
        hash_mask = hash_size - 1;
        hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        win = new Uint8Array(w_size * 2);
        prev = [];
        head = [];
        lit_bufsize = 1 << memLevel + 6;
        that.pending_buf = new Uint8Array(lit_bufsize * 4);
        pending_buf_size = lit_bufsize * 4;
        that.dist_buf = new Uint16Array(lit_bufsize);
        that.lc_buf = new Uint8Array(lit_bufsize);
        level = _level;
        strategy = _strategy;
        return deflateReset(strm);
    };
    that.deflateEnd = function() {
        if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {
            return Z_STREAM_ERROR;
        }
        that.lc_buf = null;
        that.dist_buf = null;
        that.pending_buf = null;
        head = null;
        prev = null;
        win = null;
        that.dstate = null;
        return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
    };
    that.deflateParams = function(strm, _level, _strategy) {
        let err = Z_OK;
        if (_level == Z_DEFAULT_COMPRESSION) {
            _level = 6;
        }
        if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
            return Z_STREAM_ERROR;
        }
        if (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {
            err = strm.deflate(Z_PARTIAL_FLUSH);
        }
        if (level != _level) {
            level = _level;
            max_lazy_match = config_table[level].max_lazy;
            good_match = config_table[level].good_length;
            nice_match = config_table[level].nice_length;
            max_chain_length = config_table[level].max_chain;
        }
        strategy = _strategy;
        return err;
    };
    that.deflateSetDictionary = function(_strm, dictionary, dictLength) {
        let length = dictLength;
        let n, index = 0;
        if (!dictionary || status != INIT_STATE) return Z_STREAM_ERROR;
        if (length < MIN_MATCH) return Z_OK;
        if (length > w_size - MIN_LOOKAHEAD) {
            length = w_size - MIN_LOOKAHEAD;
            index = dictLength - length;
        }
        win.set(dictionary.subarray(index, index + length), 0);
        strstart = length;
        block_start = length;
        ins_h = win[0] & 0xff;
        ins_h = (ins_h << hash_shift ^ win[1] & 0xff) & hash_mask;
        for(n = 0; n <= length - MIN_MATCH; n++){
            ins_h = (ins_h << hash_shift ^ win[n + (MIN_MATCH - 1)] & 0xff) & hash_mask;
            prev[n & w_mask] = head[ins_h];
            head[ins_h] = n;
        }
        return Z_OK;
    };
    that.deflate = function(_strm, flush) {
        let i, header, level_flags, old_flush, bstate;
        if (flush > Z_FINISH || flush < 0) {
            return Z_STREAM_ERROR;
        }
        if (!_strm.next_out || !_strm.next_in && _strm.avail_in !== 0 || status == FINISH_STATE && flush != Z_FINISH) {
            _strm.msg = z_errmsg[Z_NEED_DICT - Z_STREAM_ERROR];
            return Z_STREAM_ERROR;
        }
        if (_strm.avail_out === 0) {
            _strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
            return Z_BUF_ERROR;
        }
        strm = _strm;
        old_flush = last_flush;
        last_flush = flush;
        if (status == INIT_STATE) {
            header = Z_DEFLATED + (w_bits - 8 << 4) << 8;
            level_flags = (level - 1 & 0xff) >> 1;
            if (level_flags > 3) level_flags = 3;
            header |= level_flags << 6;
            if (strstart !== 0) header |= PRESET_DICT;
            header += 31 - header % 31;
            status = BUSY_STATE;
            putShortMSB(header);
        }
        if (that.pending !== 0) {
            strm.flush_pending();
            if (strm.avail_out === 0) {
                last_flush = -1;
                return Z_OK;
            }
        } else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {
            strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
            return Z_BUF_ERROR;
        }
        if (status == FINISH_STATE && strm.avail_in !== 0) {
            _strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
            return Z_BUF_ERROR;
        }
        if (strm.avail_in !== 0 || lookahead !== 0 || flush != Z_NO_FLUSH && status != FINISH_STATE) {
            bstate = -1;
            switch(config_table[level].func){
                case STORED:
                    bstate = deflate_stored(flush);
                    break;
                case FAST:
                    bstate = deflate_fast(flush);
                    break;
                case SLOW:
                    bstate = deflate_slow(flush);
                    break;
                default:
            }
            if (bstate == FinishStarted || bstate == FinishDone) {
                status = FINISH_STATE;
            }
            if (bstate == NeedMore || bstate == FinishStarted) {
                if (strm.avail_out === 0) {
                    last_flush = -1;
                }
                return Z_OK;
            }
            if (bstate == BlockDone) {
                if (flush == Z_PARTIAL_FLUSH) {
                    _tr_align();
                } else {
                    _tr_stored_block(0, 0, false);
                    if (flush == Z_FULL_FLUSH) {
                        for(i = 0; i < hash_size; i++)head[i] = 0;
                    }
                }
                strm.flush_pending();
                if (strm.avail_out === 0) {
                    last_flush = -1;
                    return Z_OK;
                }
            }
        }
        if (flush != Z_FINISH) return Z_OK;
        return Z_STREAM_END;
    };
}
function ZStream() {
    const that = this;
    that.next_in_index = 0;
    that.next_out_index = 0;
    that.avail_in = 0;
    that.total_in = 0;
    that.avail_out = 0;
    that.total_out = 0;
}
ZStream.prototype = {
    deflateInit (level, bits) {
        const that = this;
        that.dstate = new Deflate();
        if (!bits) bits = MAX_BITS;
        return that.dstate.deflateInit(that, level, bits);
    },
    deflate (flush) {
        const that = this;
        if (!that.dstate) {
            return Z_STREAM_ERROR;
        }
        return that.dstate.deflate(that, flush);
    },
    deflateEnd () {
        const that = this;
        if (!that.dstate) return Z_STREAM_ERROR;
        const ret = that.dstate.deflateEnd();
        that.dstate = null;
        return ret;
    },
    deflateParams (level, strategy) {
        const that = this;
        if (!that.dstate) return Z_STREAM_ERROR;
        return that.dstate.deflateParams(that, level, strategy);
    },
    deflateSetDictionary (dictionary, dictLength) {
        const that = this;
        if (!that.dstate) return Z_STREAM_ERROR;
        return that.dstate.deflateSetDictionary(that, dictionary, dictLength);
    },
    read_buf (buf, start, size) {
        const that = this;
        let len = that.avail_in;
        if (len > size) len = size;
        if (len === 0) return 0;
        that.avail_in -= len;
        buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);
        that.next_in_index += len;
        that.total_in += len;
        return len;
    },
    flush_pending () {
        const that = this;
        let len = that.dstate.pending;
        if (len > that.avail_out) len = that.avail_out;
        if (len === 0) return;
        that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);
        that.next_out_index += len;
        that.dstate.pending_out += len;
        that.total_out += len;
        that.avail_out -= len;
        that.dstate.pending -= len;
        if (that.dstate.pending === 0) {
            that.dstate.pending_out = 0;
        }
    }
};
function ZipDeflate(options) {
    const that = this;
    const z = new ZStream();
    const bufsize = getMaximumCompressedSize(options && options.chunkSize ? options.chunkSize : 64 * 1024);
    const flush = 0;
    const buf = new Uint8Array(bufsize);
    let level = options ? options.level : Z_DEFAULT_COMPRESSION;
    if (typeof level == "undefined") level = Z_DEFAULT_COMPRESSION;
    z.deflateInit(level);
    z.next_out = buf;
    that.append = function(data, onprogress) {
        let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
        const buffers = [];
        if (!data.length) return;
        z.next_in_index = 0;
        z.next_in = data;
        z.avail_in = data.length;
        do {
            z.next_out_index = 0;
            z.avail_out = bufsize;
            err = z.deflate(flush);
            if (err != Z_OK) throw new Error("deflating: " + z.msg);
            if (z.next_out_index) if (z.next_out_index == bufsize) buffers.push(new Uint8Array(buf));
            else buffers.push(buf.subarray(0, z.next_out_index));
            bufferSize += z.next_out_index;
            if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
                onprogress(z.next_in_index);
                lastIndex = z.next_in_index;
            }
        }while (z.avail_in > 0 || z.avail_out === 0)
        if (buffers.length > 1) {
            array = new Uint8Array(bufferSize);
            buffers.forEach(function(chunk) {
                array.set(chunk, bufferIndex);
                bufferIndex += chunk.length;
            });
        } else {
            array = buffers[0] ? new Uint8Array(buffers[0]) : new Uint8Array();
        }
        return array;
    };
    that.flush = function() {
        let err, array, bufferIndex = 0, bufferSize = 0;
        const buffers = [];
        do {
            z.next_out_index = 0;
            z.avail_out = bufsize;
            err = z.deflate(Z_FINISH);
            if (err != Z_STREAM_END && err != Z_OK) throw new Error("deflating: " + z.msg);
            if (bufsize - z.avail_out > 0) buffers.push(buf.slice(0, z.next_out_index));
            bufferSize += z.next_out_index;
        }while (z.avail_in > 0 || z.avail_out === 0)
        z.deflateEnd();
        array = new Uint8Array(bufferSize);
        buffers.forEach(function(chunk) {
            array.set(chunk, bufferIndex);
            bufferIndex += chunk.length;
        });
        return array;
    };
}
function getMaximumCompressedSize(uncompressedSize) {
    return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);
}
const MAX_BITS1 = 15;
const Z_OK1 = 0;
const Z_STREAM_END1 = 1;
const Z_NEED_DICT1 = 2;
const Z_STREAM_ERROR1 = -2;
const Z_DATA_ERROR1 = -3;
const Z_MEM_ERROR = -4;
const Z_BUF_ERROR1 = -5;
const inflate_mask = [
    0x00000000,
    0x00000001,
    0x00000003,
    0x00000007,
    0x0000000f,
    0x0000001f,
    0x0000003f,
    0x0000007f,
    0x000000ff,
    0x000001ff,
    0x000003ff,
    0x000007ff,
    0x00000fff,
    0x00001fff,
    0x00003fff,
    0x00007fff,
    0x0000ffff
];
const Z_FINISH1 = 4;
const fixed_bl = 9;
const fixed_bd = 5;
const fixed_tl = [
    96,
    7,
    256,
    0,
    8,
    80,
    0,
    8,
    16,
    84,
    8,
    115,
    82,
    7,
    31,
    0,
    8,
    112,
    0,
    8,
    48,
    0,
    9,
    192,
    80,
    7,
    10,
    0,
    8,
    96,
    0,
    8,
    32,
    0,
    9,
    160,
    0,
    8,
    0,
    0,
    8,
    128,
    0,
    8,
    64,
    0,
    9,
    224,
    80,
    7,
    6,
    0,
    8,
    88,
    0,
    8,
    24,
    0,
    9,
    144,
    83,
    7,
    59,
    0,
    8,
    120,
    0,
    8,
    56,
    0,
    9,
    208,
    81,
    7,
    17,
    0,
    8,
    104,
    0,
    8,
    40,
    0,
    9,
    176,
    0,
    8,
    8,
    0,
    8,
    136,
    0,
    8,
    72,
    0,
    9,
    240,
    80,
    7,
    4,
    0,
    8,
    84,
    0,
    8,
    20,
    85,
    8,
    227,
    83,
    7,
    43,
    0,
    8,
    116,
    0,
    8,
    52,
    0,
    9,
    200,
    81,
    7,
    13,
    0,
    8,
    100,
    0,
    8,
    36,
    0,
    9,
    168,
    0,
    8,
    4,
    0,
    8,
    132,
    0,
    8,
    68,
    0,
    9,
    232,
    80,
    7,
    8,
    0,
    8,
    92,
    0,
    8,
    28,
    0,
    9,
    152,
    84,
    7,
    83,
    0,
    8,
    124,
    0,
    8,
    60,
    0,
    9,
    216,
    82,
    7,
    23,
    0,
    8,
    108,
    0,
    8,
    44,
    0,
    9,
    184,
    0,
    8,
    12,
    0,
    8,
    140,
    0,
    8,
    76,
    0,
    9,
    248,
    80,
    7,
    3,
    0,
    8,
    82,
    0,
    8,
    18,
    85,
    8,
    163,
    83,
    7,
    35,
    0,
    8,
    114,
    0,
    8,
    50,
    0,
    9,
    196,
    81,
    7,
    11,
    0,
    8,
    98,
    0,
    8,
    34,
    0,
    9,
    164,
    0,
    8,
    2,
    0,
    8,
    130,
    0,
    8,
    66,
    0,
    9,
    228,
    80,
    7,
    7,
    0,
    8,
    90,
    0,
    8,
    26,
    0,
    9,
    148,
    84,
    7,
    67,
    0,
    8,
    122,
    0,
    8,
    58,
    0,
    9,
    212,
    82,
    7,
    19,
    0,
    8,
    106,
    0,
    8,
    42,
    0,
    9,
    180,
    0,
    8,
    10,
    0,
    8,
    138,
    0,
    8,
    74,
    0,
    9,
    244,
    80,
    7,
    5,
    0,
    8,
    86,
    0,
    8,
    22,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    118,
    0,
    8,
    54,
    0,
    9,
    204,
    81,
    7,
    15,
    0,
    8,
    102,
    0,
    8,
    38,
    0,
    9,
    172,
    0,
    8,
    6,
    0,
    8,
    134,
    0,
    8,
    70,
    0,
    9,
    236,
    80,
    7,
    9,
    0,
    8,
    94,
    0,
    8,
    30,
    0,
    9,
    156,
    84,
    7,
    99,
    0,
    8,
    126,
    0,
    8,
    62,
    0,
    9,
    220,
    82,
    7,
    27,
    0,
    8,
    110,
    0,
    8,
    46,
    0,
    9,
    188,
    0,
    8,
    14,
    0,
    8,
    142,
    0,
    8,
    78,
    0,
    9,
    252,
    96,
    7,
    256,
    0,
    8,
    81,
    0,
    8,
    17,
    85,
    8,
    131,
    82,
    7,
    31,
    0,
    8,
    113,
    0,
    8,
    49,
    0,
    9,
    194,
    80,
    7,
    10,
    0,
    8,
    97,
    0,
    8,
    33,
    0,
    9,
    162,
    0,
    8,
    1,
    0,
    8,
    129,
    0,
    8,
    65,
    0,
    9,
    226,
    80,
    7,
    6,
    0,
    8,
    89,
    0,
    8,
    25,
    0,
    9,
    146,
    83,
    7,
    59,
    0,
    8,
    121,
    0,
    8,
    57,
    0,
    9,
    210,
    81,
    7,
    17,
    0,
    8,
    105,
    0,
    8,
    41,
    0,
    9,
    178,
    0,
    8,
    9,
    0,
    8,
    137,
    0,
    8,
    73,
    0,
    9,
    242,
    80,
    7,
    4,
    0,
    8,
    85,
    0,
    8,
    21,
    80,
    8,
    258,
    83,
    7,
    43,
    0,
    8,
    117,
    0,
    8,
    53,
    0,
    9,
    202,
    81,
    7,
    13,
    0,
    8,
    101,
    0,
    8,
    37,
    0,
    9,
    170,
    0,
    8,
    5,
    0,
    8,
    133,
    0,
    8,
    69,
    0,
    9,
    234,
    80,
    7,
    8,
    0,
    8,
    93,
    0,
    8,
    29,
    0,
    9,
    154,
    84,
    7,
    83,
    0,
    8,
    125,
    0,
    8,
    61,
    0,
    9,
    218,
    82,
    7,
    23,
    0,
    8,
    109,
    0,
    8,
    45,
    0,
    9,
    186,
    0,
    8,
    13,
    0,
    8,
    141,
    0,
    8,
    77,
    0,
    9,
    250,
    80,
    7,
    3,
    0,
    8,
    83,
    0,
    8,
    19,
    85,
    8,
    195,
    83,
    7,
    35,
    0,
    8,
    115,
    0,
    8,
    51,
    0,
    9,
    198,
    81,
    7,
    11,
    0,
    8,
    99,
    0,
    8,
    35,
    0,
    9,
    166,
    0,
    8,
    3,
    0,
    8,
    131,
    0,
    8,
    67,
    0,
    9,
    230,
    80,
    7,
    7,
    0,
    8,
    91,
    0,
    8,
    27,
    0,
    9,
    150,
    84,
    7,
    67,
    0,
    8,
    123,
    0,
    8,
    59,
    0,
    9,
    214,
    82,
    7,
    19,
    0,
    8,
    107,
    0,
    8,
    43,
    0,
    9,
    182,
    0,
    8,
    11,
    0,
    8,
    139,
    0,
    8,
    75,
    0,
    9,
    246,
    80,
    7,
    5,
    0,
    8,
    87,
    0,
    8,
    23,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    119,
    0,
    8,
    55,
    0,
    9,
    206,
    81,
    7,
    15,
    0,
    8,
    103,
    0,
    8,
    39,
    0,
    9,
    174,
    0,
    8,
    7,
    0,
    8,
    135,
    0,
    8,
    71,
    0,
    9,
    238,
    80,
    7,
    9,
    0,
    8,
    95,
    0,
    8,
    31,
    0,
    9,
    158,
    84,
    7,
    99,
    0,
    8,
    127,
    0,
    8,
    63,
    0,
    9,
    222,
    82,
    7,
    27,
    0,
    8,
    111,
    0,
    8,
    47,
    0,
    9,
    190,
    0,
    8,
    15,
    0,
    8,
    143,
    0,
    8,
    79,
    0,
    9,
    254,
    96,
    7,
    256,
    0,
    8,
    80,
    0,
    8,
    16,
    84,
    8,
    115,
    82,
    7,
    31,
    0,
    8,
    112,
    0,
    8,
    48,
    0,
    9,
    193,
    80,
    7,
    10,
    0,
    8,
    96,
    0,
    8,
    32,
    0,
    9,
    161,
    0,
    8,
    0,
    0,
    8,
    128,
    0,
    8,
    64,
    0,
    9,
    225,
    80,
    7,
    6,
    0,
    8,
    88,
    0,
    8,
    24,
    0,
    9,
    145,
    83,
    7,
    59,
    0,
    8,
    120,
    0,
    8,
    56,
    0,
    9,
    209,
    81,
    7,
    17,
    0,
    8,
    104,
    0,
    8,
    40,
    0,
    9,
    177,
    0,
    8,
    8,
    0,
    8,
    136,
    0,
    8,
    72,
    0,
    9,
    241,
    80,
    7,
    4,
    0,
    8,
    84,
    0,
    8,
    20,
    85,
    8,
    227,
    83,
    7,
    43,
    0,
    8,
    116,
    0,
    8,
    52,
    0,
    9,
    201,
    81,
    7,
    13,
    0,
    8,
    100,
    0,
    8,
    36,
    0,
    9,
    169,
    0,
    8,
    4,
    0,
    8,
    132,
    0,
    8,
    68,
    0,
    9,
    233,
    80,
    7,
    8,
    0,
    8,
    92,
    0,
    8,
    28,
    0,
    9,
    153,
    84,
    7,
    83,
    0,
    8,
    124,
    0,
    8,
    60,
    0,
    9,
    217,
    82,
    7,
    23,
    0,
    8,
    108,
    0,
    8,
    44,
    0,
    9,
    185,
    0,
    8,
    12,
    0,
    8,
    140,
    0,
    8,
    76,
    0,
    9,
    249,
    80,
    7,
    3,
    0,
    8,
    82,
    0,
    8,
    18,
    85,
    8,
    163,
    83,
    7,
    35,
    0,
    8,
    114,
    0,
    8,
    50,
    0,
    9,
    197,
    81,
    7,
    11,
    0,
    8,
    98,
    0,
    8,
    34,
    0,
    9,
    165,
    0,
    8,
    2,
    0,
    8,
    130,
    0,
    8,
    66,
    0,
    9,
    229,
    80,
    7,
    7,
    0,
    8,
    90,
    0,
    8,
    26,
    0,
    9,
    149,
    84,
    7,
    67,
    0,
    8,
    122,
    0,
    8,
    58,
    0,
    9,
    213,
    82,
    7,
    19,
    0,
    8,
    106,
    0,
    8,
    42,
    0,
    9,
    181,
    0,
    8,
    10,
    0,
    8,
    138,
    0,
    8,
    74,
    0,
    9,
    245,
    80,
    7,
    5,
    0,
    8,
    86,
    0,
    8,
    22,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    118,
    0,
    8,
    54,
    0,
    9,
    205,
    81,
    7,
    15,
    0,
    8,
    102,
    0,
    8,
    38,
    0,
    9,
    173,
    0,
    8,
    6,
    0,
    8,
    134,
    0,
    8,
    70,
    0,
    9,
    237,
    80,
    7,
    9,
    0,
    8,
    94,
    0,
    8,
    30,
    0,
    9,
    157,
    84,
    7,
    99,
    0,
    8,
    126,
    0,
    8,
    62,
    0,
    9,
    221,
    82,
    7,
    27,
    0,
    8,
    110,
    0,
    8,
    46,
    0,
    9,
    189,
    0,
    8,
    14,
    0,
    8,
    142,
    0,
    8,
    78,
    0,
    9,
    253,
    96,
    7,
    256,
    0,
    8,
    81,
    0,
    8,
    17,
    85,
    8,
    131,
    82,
    7,
    31,
    0,
    8,
    113,
    0,
    8,
    49,
    0,
    9,
    195,
    80,
    7,
    10,
    0,
    8,
    97,
    0,
    8,
    33,
    0,
    9,
    163,
    0,
    8,
    1,
    0,
    8,
    129,
    0,
    8,
    65,
    0,
    9,
    227,
    80,
    7,
    6,
    0,
    8,
    89,
    0,
    8,
    25,
    0,
    9,
    147,
    83,
    7,
    59,
    0,
    8,
    121,
    0,
    8,
    57,
    0,
    9,
    211,
    81,
    7,
    17,
    0,
    8,
    105,
    0,
    8,
    41,
    0,
    9,
    179,
    0,
    8,
    9,
    0,
    8,
    137,
    0,
    8,
    73,
    0,
    9,
    243,
    80,
    7,
    4,
    0,
    8,
    85,
    0,
    8,
    21,
    80,
    8,
    258,
    83,
    7,
    43,
    0,
    8,
    117,
    0,
    8,
    53,
    0,
    9,
    203,
    81,
    7,
    13,
    0,
    8,
    101,
    0,
    8,
    37,
    0,
    9,
    171,
    0,
    8,
    5,
    0,
    8,
    133,
    0,
    8,
    69,
    0,
    9,
    235,
    80,
    7,
    8,
    0,
    8,
    93,
    0,
    8,
    29,
    0,
    9,
    155,
    84,
    7,
    83,
    0,
    8,
    125,
    0,
    8,
    61,
    0,
    9,
    219,
    82,
    7,
    23,
    0,
    8,
    109,
    0,
    8,
    45,
    0,
    9,
    187,
    0,
    8,
    13,
    0,
    8,
    141,
    0,
    8,
    77,
    0,
    9,
    251,
    80,
    7,
    3,
    0,
    8,
    83,
    0,
    8,
    19,
    85,
    8,
    195,
    83,
    7,
    35,
    0,
    8,
    115,
    0,
    8,
    51,
    0,
    9,
    199,
    81,
    7,
    11,
    0,
    8,
    99,
    0,
    8,
    35,
    0,
    9,
    167,
    0,
    8,
    3,
    0,
    8,
    131,
    0,
    8,
    67,
    0,
    9,
    231,
    80,
    7,
    7,
    0,
    8,
    91,
    0,
    8,
    27,
    0,
    9,
    151,
    84,
    7,
    67,
    0,
    8,
    123,
    0,
    8,
    59,
    0,
    9,
    215,
    82,
    7,
    19,
    0,
    8,
    107,
    0,
    8,
    43,
    0,
    9,
    183,
    0,
    8,
    11,
    0,
    8,
    139,
    0,
    8,
    75,
    0,
    9,
    247,
    80,
    7,
    5,
    0,
    8,
    87,
    0,
    8,
    23,
    192,
    8,
    0,
    83,
    7,
    51,
    0,
    8,
    119,
    0,
    8,
    55,
    0,
    9,
    207,
    81,
    7,
    15,
    0,
    8,
    103,
    0,
    8,
    39,
    0,
    9,
    175,
    0,
    8,
    7,
    0,
    8,
    135,
    0,
    8,
    71,
    0,
    9,
    239,
    80,
    7,
    9,
    0,
    8,
    95,
    0,
    8,
    31,
    0,
    9,
    159,
    84,
    7,
    99,
    0,
    8,
    127,
    0,
    8,
    63,
    0,
    9,
    223,
    82,
    7,
    27,
    0,
    8,
    111,
    0,
    8,
    47,
    0,
    9,
    191,
    0,
    8,
    15,
    0,
    8,
    143,
    0,
    8,
    79,
    0,
    9,
    255
];
const fixed_td = [
    80,
    5,
    1,
    87,
    5,
    257,
    83,
    5,
    17,
    91,
    5,
    4097,
    81,
    5,
    5,
    89,
    5,
    1025,
    85,
    5,
    65,
    93,
    5,
    16385,
    80,
    5,
    3,
    88,
    5,
    513,
    84,
    5,
    33,
    92,
    5,
    8193,
    82,
    5,
    9,
    90,
    5,
    2049,
    86,
    5,
    129,
    192,
    5,
    24577,
    80,
    5,
    2,
    87,
    5,
    385,
    83,
    5,
    25,
    91,
    5,
    6145,
    81,
    5,
    7,
    89,
    5,
    1537,
    85,
    5,
    97,
    93,
    5,
    24577,
    80,
    5,
    4,
    88,
    5,
    769,
    84,
    5,
    49,
    92,
    5,
    12289,
    82,
    5,
    13,
    90,
    5,
    3073,
    86,
    5,
    193,
    192,
    5,
    24577
];
const cplens = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
];
const cplext = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    112,
    112
];
const cpdist = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577
];
const cpdext = [
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
];
const BMAX = 15;
function InfTree() {
    const that = this;
    let hn;
    let v;
    let c;
    let r;
    let u;
    let x;
    function huft_build(b, bindex, n, s, d, e, t, m, hp, hn, v) {
        let a;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let mask;
        let p;
        let q;
        let w;
        let xp;
        let y;
        let z;
        p = 0;
        i = n;
        do {
            c[b[bindex + p]]++;
            p++;
            i--;
        }while (i !== 0)
        if (c[0] == n) {
            t[0] = -1;
            m[0] = 0;
            return 0;
        }
        l = m[0];
        for(j = 1; j <= 15; j++)if (c[j] !== 0) break;
        k = j;
        if (l < j) {
            l = j;
        }
        for(i = BMAX; i !== 0; i--){
            if (c[i] !== 0) break;
        }
        g = i;
        if (l > i) {
            l = i;
        }
        m[0] = l;
        for(y = 1 << j; j < i; j++, y <<= 1){
            if ((y -= c[j]) < 0) {
                return Z_DATA_ERROR1;
            }
        }
        if ((y -= c[i]) < 0) {
            return Z_DATA_ERROR1;
        }
        c[i] += y;
        x[1] = j = 0;
        p = 1;
        xp = 2;
        while(--i !== 0){
            x[xp] = j += c[p];
            xp++;
            p++;
        }
        i = 0;
        p = 0;
        do {
            if ((j = b[bindex + p]) !== 0) {
                v[x[j]++] = i;
            }
            p++;
        }while (++i < n)
        n = x[g];
        x[0] = i = 0;
        p = 0;
        h = -1;
        w = -l;
        u[0] = 0;
        q = 0;
        z = 0;
        for(; k <= g; k++){
            a = c[k];
            while(a-- !== 0){
                while(k > w + l){
                    h++;
                    w += l;
                    z = g - w;
                    z = z > l ? l : z;
                    if ((f = 1 << (j = k - w)) > a + 1) {
                        f -= a + 1;
                        xp = k;
                        if (j < z) {
                            while(++j < z){
                                if ((f <<= 1) <= c[++xp]) break;
                                f -= c[xp];
                            }
                        }
                    }
                    z = 1 << j;
                    if (hn[0] + z > 1440) {
                        return Z_DATA_ERROR1;
                    }
                    u[h] = q = hn[0];
                    hn[0] += z;
                    if (h !== 0) {
                        x[h] = i;
                        r[0] = j;
                        r[1] = l;
                        j = i >>> w - l;
                        r[2] = q - u[h - 1] - j;
                        hp.set(r, (u[h - 1] + j) * 3);
                    } else {
                        t[0] = q;
                    }
                }
                r[1] = k - w;
                if (p >= n) {
                    r[0] = 128 + 64;
                } else if (v[p] < s) {
                    r[0] = v[p] < 256 ? 0 : 32 + 64;
                    r[2] = v[p++];
                } else {
                    r[0] = e[v[p] - s] + 16 + 64;
                    r[2] = d[v[p++] - s];
                }
                f = 1 << k - w;
                for(j = i >>> w; j < z; j += f){
                    hp.set(r, (q + j) * 3);
                }
                for(j = 1 << k - 1; (i & j) !== 0; j >>>= 1){
                    i ^= j;
                }
                i ^= j;
                mask = (1 << w) - 1;
                while((i & mask) != x[h]){
                    h--;
                    w -= l;
                    mask = (1 << w) - 1;
                }
            }
        }
        return y !== 0 && g != 1 ? Z_BUF_ERROR1 : 0;
    }
    function initWorkArea(vsize) {
        let i;
        if (!hn) {
            hn = [];
            v = [];
            c = new Int32Array(BMAX + 1);
            r = [];
            u = new Int32Array(BMAX);
            x = new Int32Array(BMAX + 1);
        }
        if (v.length < vsize) {
            v = [];
        }
        for(i = 0; i < vsize; i++){
            v[i] = 0;
        }
        for(i = 0; i < 15 + 1; i++){
            c[i] = 0;
        }
        for(i = 0; i < 3; i++){
            r[i] = 0;
        }
        u.set(c.subarray(0, 15), 0);
        x.set(c.subarray(0, 15 + 1), 0);
    }
    that.inflate_trees_bits = function(c, bb, tb, hp, z) {
        let result;
        initWorkArea(19);
        hn[0] = 0;
        result = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);
        if (result == Z_DATA_ERROR1) {
            z.msg = "oversubscribed dynamic bit lengths tree";
        } else if (result == Z_BUF_ERROR1 || bb[0] === 0) {
            z.msg = "incomplete dynamic bit lengths tree";
            result = Z_DATA_ERROR1;
        }
        return result;
    };
    that.inflate_trees_dynamic = function(nl, nd, c, bl, bd, tl, td, hp, z) {
        let result;
        initWorkArea(288);
        hn[0] = 0;
        result = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
        if (result != Z_OK1 || bl[0] === 0) {
            if (result == Z_DATA_ERROR1) {
                z.msg = "oversubscribed literal/length tree";
            } else if (result != Z_MEM_ERROR) {
                z.msg = "incomplete literal/length tree";
                result = Z_DATA_ERROR1;
            }
            return result;
        }
        initWorkArea(288);
        result = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);
        if (result != Z_OK1 || bd[0] === 0 && nl > 257) {
            if (result == Z_DATA_ERROR1) {
                z.msg = "oversubscribed distance tree";
            } else if (result == Z_BUF_ERROR1) {
                z.msg = "incomplete distance tree";
                result = Z_DATA_ERROR1;
            } else if (result != Z_MEM_ERROR) {
                z.msg = "empty distance tree with lengths";
                result = Z_DATA_ERROR1;
            }
            return result;
        }
        return Z_OK1;
    };
}
InfTree.inflate_trees_fixed = function(bl, bd, tl, td) {
    bl[0] = fixed_bl;
    bd[0] = fixed_bd;
    tl[0] = fixed_tl;
    td[0] = fixed_td;
    return Z_OK1;
};
const START = 0;
const LEN = 1;
const LENEXT = 2;
const DIST = 3;
const DISTEXT = 4;
const COPY = 5;
const LIT = 6;
const WASH = 7;
const END = 8;
const BADCODE = 9;
function InfCodes() {
    const that = this;
    let mode;
    let len = 0;
    let tree;
    let tree_index = 0;
    let need = 0;
    let lit = 0;
    let get = 0;
    let dist = 0;
    let lbits = 0;
    let dbits = 0;
    let ltree;
    let ltree_index = 0;
    let dtree;
    let dtree_index = 0;
    function inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {
        let t;
        let tp;
        let tp_index;
        let e;
        let b;
        let k;
        let p;
        let n;
        let q;
        let m;
        let ml;
        let md;
        let c;
        let d;
        let r;
        let tp_index_t_3;
        p = z.next_in_index;
        n = z.avail_in;
        b = s.bitb;
        k = s.bitk;
        q = s.write;
        m = q < s.read ? s.read - q - 1 : s.end - q;
        ml = inflate_mask[bl];
        md = inflate_mask[bd];
        do {
            while(k < 20){
                n--;
                b |= (z.read_byte(p++) & 0xff) << k;
                k += 8;
            }
            t = b & ml;
            tp = tl;
            tp_index = tl_index;
            tp_index_t_3 = (tp_index + t) * 3;
            if ((e = tp[tp_index_t_3]) === 0) {
                b >>= tp[tp_index_t_3 + 1];
                k -= tp[tp_index_t_3 + 1];
                s.win[q++] = tp[tp_index_t_3 + 2];
                m--;
                continue;
            }
            do {
                b >>= tp[tp_index_t_3 + 1];
                k -= tp[tp_index_t_3 + 1];
                if ((e & 16) !== 0) {
                    e &= 15;
                    c = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);
                    b >>= e;
                    k -= e;
                    while(k < 15){
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    t = b & md;
                    tp = td;
                    tp_index = td_index;
                    tp_index_t_3 = (tp_index + t) * 3;
                    e = tp[tp_index_t_3];
                    do {
                        b >>= tp[tp_index_t_3 + 1];
                        k -= tp[tp_index_t_3 + 1];
                        if ((e & 16) !== 0) {
                            e &= 15;
                            while(k < e){
                                n--;
                                b |= (z.read_byte(p++) & 0xff) << k;
                                k += 8;
                            }
                            d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);
                            b >>= e;
                            k -= e;
                            m -= c;
                            if (q >= d) {
                                r = q - d;
                                if (q - r > 0 && 2 > q - r) {
                                    s.win[q++] = s.win[r++];
                                    s.win[q++] = s.win[r++];
                                    c -= 2;
                                } else {
                                    s.win.set(s.win.subarray(r, r + 2), q);
                                    q += 2;
                                    r += 2;
                                    c -= 2;
                                }
                            } else {
                                r = q - d;
                                do {
                                    r += s.end;
                                }while (r < 0)
                                e = s.end - r;
                                if (c > e) {
                                    c -= e;
                                    if (q - r > 0 && e > q - r) {
                                        do {
                                            s.win[q++] = s.win[r++];
                                        }while (--e !== 0)
                                    } else {
                                        s.win.set(s.win.subarray(r, r + e), q);
                                        q += e;
                                        r += e;
                                        e = 0;
                                    }
                                    r = 0;
                                }
                            }
                            if (q - r > 0 && c > q - r) {
                                do {
                                    s.win[q++] = s.win[r++];
                                }while (--c !== 0)
                            } else {
                                s.win.set(s.win.subarray(r, r + c), q);
                                q += c;
                                r += c;
                                c = 0;
                            }
                            break;
                        } else if ((e & 64) === 0) {
                            t += tp[tp_index_t_3 + 2];
                            t += b & inflate_mask[e];
                            tp_index_t_3 = (tp_index + t) * 3;
                            e = tp[tp_index_t_3];
                        } else {
                            z.msg = "invalid distance code";
                            c = z.avail_in - n;
                            c = k >> 3 < c ? k >> 3 : c;
                            n += c;
                            p -= c;
                            k -= c << 3;
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return Z_DATA_ERROR1;
                        }
                    }while (true)
                    break;
                }
                if ((e & 64) === 0) {
                    t += tp[tp_index_t_3 + 2];
                    t += b & inflate_mask[e];
                    tp_index_t_3 = (tp_index + t) * 3;
                    if ((e = tp[tp_index_t_3]) === 0) {
                        b >>= tp[tp_index_t_3 + 1];
                        k -= tp[tp_index_t_3 + 1];
                        s.win[q++] = tp[tp_index_t_3 + 2];
                        m--;
                        break;
                    }
                } else if ((e & 32) !== 0) {
                    c = z.avail_in - n;
                    c = k >> 3 < c ? k >> 3 : c;
                    n += c;
                    p -= c;
                    k -= c << 3;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return 1;
                } else {
                    z.msg = "invalid literal/length code";
                    c = z.avail_in - n;
                    c = k >> 3 < c ? k >> 3 : c;
                    n += c;
                    p -= c;
                    k -= c << 3;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return Z_DATA_ERROR1;
                }
            }while (true)
        }while (m >= 258 && n >= 10)
        c = z.avail_in - n;
        c = k >> 3 < c ? k >> 3 : c;
        n += c;
        p -= c;
        k -= c << 3;
        s.bitb = b;
        s.bitk = k;
        z.avail_in = n;
        z.total_in += p - z.next_in_index;
        z.next_in_index = p;
        s.write = q;
        return 0;
    }
    that.init = function(bl, bd, tl, tl_index, td, td_index) {
        mode = START;
        lbits = bl;
        dbits = bd;
        ltree = tl;
        ltree_index = tl_index;
        dtree = td;
        dtree_index = td_index;
        tree = null;
    };
    that.proc = function(s, z, r) {
        let j;
        let tindex;
        let e;
        let b = 0;
        let k = 0;
        let p = 0;
        let n;
        let q;
        let m;
        let f;
        p = z.next_in_index;
        n = z.avail_in;
        b = s.bitb;
        k = s.bitk;
        q = s.write;
        m = q < s.read ? s.read - q - 1 : s.end - q;
        while(true){
            switch(mode){
                case START:
                    if (m >= 258 && n >= 10) {
                        s.bitb = b;
                        s.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        s.write = q;
                        r = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);
                        p = z.next_in_index;
                        n = z.avail_in;
                        b = s.bitb;
                        k = s.bitk;
                        q = s.write;
                        m = q < s.read ? s.read - q - 1 : s.end - q;
                        if (r != Z_OK1) {
                            mode = r == Z_STREAM_END1 ? WASH : BADCODE;
                            break;
                        }
                    }
                    need = lbits;
                    tree = ltree;
                    tree_index = ltree_index;
                    mode = LEN;
                case LEN:
                    j = need;
                    while(k < j){
                        if (n !== 0) r = Z_OK1;
                        else {
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return s.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    tindex = (tree_index + (b & inflate_mask[j])) * 3;
                    b >>>= tree[tindex + 1];
                    k -= tree[tindex + 1];
                    e = tree[tindex];
                    if (e === 0) {
                        lit = tree[tindex + 2];
                        mode = LIT;
                        break;
                    }
                    if ((e & 16) !== 0) {
                        get = e & 15;
                        len = tree[tindex + 2];
                        mode = LENEXT;
                        break;
                    }
                    if ((e & 64) === 0) {
                        need = e;
                        tree_index = tindex / 3 + tree[tindex + 2];
                        break;
                    }
                    if ((e & 32) !== 0) {
                        mode = WASH;
                        break;
                    }
                    mode = BADCODE;
                    z.msg = "invalid literal/length code";
                    r = Z_DATA_ERROR1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
                case LENEXT:
                    j = get;
                    while(k < j){
                        if (n !== 0) r = Z_OK1;
                        else {
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return s.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    len += b & inflate_mask[j];
                    b >>= j;
                    k -= j;
                    need = dbits;
                    tree = dtree;
                    tree_index = dtree_index;
                    mode = DIST;
                case DIST:
                    j = need;
                    while(k < j){
                        if (n !== 0) r = Z_OK1;
                        else {
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return s.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    tindex = (tree_index + (b & inflate_mask[j])) * 3;
                    b >>= tree[tindex + 1];
                    k -= tree[tindex + 1];
                    e = tree[tindex];
                    if ((e & 16) !== 0) {
                        get = e & 15;
                        dist = tree[tindex + 2];
                        mode = DISTEXT;
                        break;
                    }
                    if ((e & 64) === 0) {
                        need = e;
                        tree_index = tindex / 3 + tree[tindex + 2];
                        break;
                    }
                    mode = BADCODE;
                    z.msg = "invalid distance code";
                    r = Z_DATA_ERROR1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
                case DISTEXT:
                    j = get;
                    while(k < j){
                        if (n !== 0) r = Z_OK1;
                        else {
                            s.bitb = b;
                            s.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            s.write = q;
                            return s.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    dist += b & inflate_mask[j];
                    b >>= j;
                    k -= j;
                    mode = COPY;
                case COPY:
                    f = q - dist;
                    while(f < 0){
                        f += s.end;
                    }
                    while(len !== 0){
                        if (m === 0) {
                            if (q == s.end && s.read !== 0) {
                                q = 0;
                                m = q < s.read ? s.read - q - 1 : s.end - q;
                            }
                            if (m === 0) {
                                s.write = q;
                                r = s.inflate_flush(z, r);
                                q = s.write;
                                m = q < s.read ? s.read - q - 1 : s.end - q;
                                if (q == s.end && s.read !== 0) {
                                    q = 0;
                                    m = q < s.read ? s.read - q - 1 : s.end - q;
                                }
                                if (m === 0) {
                                    s.bitb = b;
                                    s.bitk = k;
                                    z.avail_in = n;
                                    z.total_in += p - z.next_in_index;
                                    z.next_in_index = p;
                                    s.write = q;
                                    return s.inflate_flush(z, r);
                                }
                            }
                        }
                        s.win[q++] = s.win[f++];
                        m--;
                        if (f == s.end) f = 0;
                        len--;
                    }
                    mode = START;
                    break;
                case LIT:
                    if (m === 0) {
                        if (q == s.end && s.read !== 0) {
                            q = 0;
                            m = q < s.read ? s.read - q - 1 : s.end - q;
                        }
                        if (m === 0) {
                            s.write = q;
                            r = s.inflate_flush(z, r);
                            q = s.write;
                            m = q < s.read ? s.read - q - 1 : s.end - q;
                            if (q == s.end && s.read !== 0) {
                                q = 0;
                                m = q < s.read ? s.read - q - 1 : s.end - q;
                            }
                            if (m === 0) {
                                s.bitb = b;
                                s.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                s.write = q;
                                return s.inflate_flush(z, r);
                            }
                        }
                    }
                    r = Z_OK1;
                    s.win[q++] = lit;
                    m--;
                    mode = START;
                    break;
                case WASH:
                    if (k > 7) {
                        k -= 8;
                        n++;
                        p--;
                    }
                    s.write = q;
                    r = s.inflate_flush(z, r);
                    q = s.write;
                    m = q < s.read ? s.read - q - 1 : s.end - q;
                    if (s.read != s.write) {
                        s.bitb = b;
                        s.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        s.write = q;
                        return s.inflate_flush(z, r);
                    }
                    mode = END;
                case END:
                    r = Z_STREAM_END1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
                case BADCODE:
                    r = Z_DATA_ERROR1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
                default:
                    r = Z_STREAM_ERROR1;
                    s.bitb = b;
                    s.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    s.write = q;
                    return s.inflate_flush(z, r);
            }
        }
    };
    that.free = function() {};
}
const border = [
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
];
const TYPE = 0;
const LENS = 1;
const STORED1 = 2;
const TABLE = 3;
const BTREE = 4;
const DTREE = 5;
const CODES = 6;
const DRY = 7;
const DONELOCKS = 8;
const BADBLOCKS = 9;
function InfBlocks(z, w) {
    const that = this;
    let mode = 0;
    let left = 0;
    let table = 0;
    let index = 0;
    let blens;
    const bb = [
        0
    ];
    const tb = [
        0
    ];
    const codes = new InfCodes();
    let last = 0;
    let hufts = new Int32Array(1440 * 3);
    const check = 0;
    const inftree = new InfTree();
    that.bitk = 0;
    that.bitb = 0;
    that.win = new Uint8Array(w);
    that.end = w;
    that.read = 0;
    that.write = 0;
    that.reset = function(z, c) {
        if (c) c[0] = check;
        if (mode == CODES) {
            codes.free(z);
        }
        mode = TYPE;
        that.bitk = 0;
        that.bitb = 0;
        that.read = that.write = 0;
    };
    that.reset(z, null);
    that.inflate_flush = function(z, r) {
        let n;
        let p;
        let q;
        p = z.next_out_index;
        q = that.read;
        n = (q <= that.write ? that.write : that.end) - q;
        if (n > z.avail_out) n = z.avail_out;
        if (n !== 0 && r == Z_BUF_ERROR1) r = Z_OK1;
        z.avail_out -= n;
        z.total_out += n;
        z.next_out.set(that.win.subarray(q, q + n), p);
        p += n;
        q += n;
        if (q == that.end) {
            q = 0;
            if (that.write == that.end) that.write = 0;
            n = that.write - q;
            if (n > z.avail_out) n = z.avail_out;
            if (n !== 0 && r == Z_BUF_ERROR1) r = Z_OK1;
            z.avail_out -= n;
            z.total_out += n;
            z.next_out.set(that.win.subarray(q, q + n), p);
            p += n;
            q += n;
        }
        z.next_out_index = p;
        that.read = q;
        return r;
    };
    that.proc = function(z, r) {
        let t;
        let b;
        let k;
        let p;
        let n;
        let q;
        let m;
        let i;
        p = z.next_in_index;
        n = z.avail_in;
        b = that.bitb;
        k = that.bitk;
        q = that.write;
        m = q < that.read ? that.read - q - 1 : that.end - q;
        while(true){
            let bl, bd, tl, td, bl_, bd_, tl_, td_;
            switch(mode){
                case TYPE:
                    while(k < 3){
                        if (n !== 0) {
                            r = Z_OK1;
                        } else {
                            that.bitb = b;
                            that.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            that.write = q;
                            return that.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    t = b & 7;
                    last = t & 1;
                    switch(t >>> 1){
                        case 0:
                            b >>>= 3;
                            k -= 3;
                            t = k & 7;
                            b >>>= t;
                            k -= t;
                            mode = LENS;
                            break;
                        case 1:
                            bl = [];
                            bd = [];
                            tl = [
                                []
                            ];
                            td = [
                                []
                            ];
                            InfTree.inflate_trees_fixed(bl, bd, tl, td);
                            codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);
                            b >>>= 3;
                            k -= 3;
                            mode = CODES;
                            break;
                        case 2:
                            b >>>= 3;
                            k -= 3;
                            mode = TABLE;
                            break;
                        case 3:
                            b >>>= 3;
                            k -= 3;
                            mode = BADBLOCKS;
                            z.msg = "invalid block type";
                            r = Z_DATA_ERROR1;
                            that.bitb = b;
                            that.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            that.write = q;
                            return that.inflate_flush(z, r);
                    }
                    break;
                case LENS:
                    while(k < 32){
                        if (n !== 0) {
                            r = Z_OK1;
                        } else {
                            that.bitb = b;
                            that.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            that.write = q;
                            return that.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    if ((~b >>> 16 & 0xffff) != (b & 0xffff)) {
                        mode = BADBLOCKS;
                        z.msg = "invalid stored block lengths";
                        r = Z_DATA_ERROR1;
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    left = b & 0xffff;
                    b = k = 0;
                    mode = left !== 0 ? STORED1 : last !== 0 ? DRY : TYPE;
                    break;
                case STORED1:
                    if (n === 0) {
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    if (m === 0) {
                        if (q == that.end && that.read !== 0) {
                            q = 0;
                            m = q < that.read ? that.read - q - 1 : that.end - q;
                        }
                        if (m === 0) {
                            that.write = q;
                            r = that.inflate_flush(z, r);
                            q = that.write;
                            m = q < that.read ? that.read - q - 1 : that.end - q;
                            if (q == that.end && that.read !== 0) {
                                q = 0;
                                m = q < that.read ? that.read - q - 1 : that.end - q;
                            }
                            if (m === 0) {
                                that.bitb = b;
                                that.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                that.write = q;
                                return that.inflate_flush(z, r);
                            }
                        }
                    }
                    r = Z_OK1;
                    t = left;
                    if (t > n) t = n;
                    if (t > m) t = m;
                    that.win.set(z.read_buf(p, t), q);
                    p += t;
                    n -= t;
                    q += t;
                    m -= t;
                    if ((left -= t) !== 0) break;
                    mode = last !== 0 ? DRY : TYPE;
                    break;
                case TABLE:
                    while(k < 14){
                        if (n !== 0) {
                            r = Z_OK1;
                        } else {
                            that.bitb = b;
                            that.bitk = k;
                            z.avail_in = n;
                            z.total_in += p - z.next_in_index;
                            z.next_in_index = p;
                            that.write = q;
                            return that.inflate_flush(z, r);
                        }
                        n--;
                        b |= (z.read_byte(p++) & 0xff) << k;
                        k += 8;
                    }
                    table = t = b & 0x3fff;
                    if ((t & 0x1f) > 29 || (t >> 5 & 0x1f) > 29) {
                        mode = BADBLOCKS;
                        z.msg = "too many length or distance symbols";
                        r = Z_DATA_ERROR1;
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    t = 258 + (t & 0x1f) + (t >> 5 & 0x1f);
                    if (!blens || blens.length < t) {
                        blens = [];
                    } else {
                        for(i = 0; i < t; i++){
                            blens[i] = 0;
                        }
                    }
                    b >>>= 14;
                    k -= 14;
                    index = 0;
                    mode = BTREE;
                case BTREE:
                    while(index < 4 + (table >>> 10)){
                        while(k < 3){
                            if (n !== 0) {
                                r = Z_OK1;
                            } else {
                                that.bitb = b;
                                that.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                that.write = q;
                                return that.inflate_flush(z, r);
                            }
                            n--;
                            b |= (z.read_byte(p++) & 0xff) << k;
                            k += 8;
                        }
                        blens[border[index++]] = b & 7;
                        b >>>= 3;
                        k -= 3;
                    }
                    while(index < 19){
                        blens[border[index++]] = 0;
                    }
                    bb[0] = 7;
                    t = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);
                    if (t != Z_OK1) {
                        r = t;
                        if (r == Z_DATA_ERROR1) {
                            blens = null;
                            mode = BADBLOCKS;
                        }
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    index = 0;
                    mode = DTREE;
                case DTREE:
                    while(true){
                        t = table;
                        if (index >= 258 + (t & 0x1f) + (t >> 5 & 0x1f)) {
                            break;
                        }
                        let j, c;
                        t = bb[0];
                        while(k < t){
                            if (n !== 0) {
                                r = Z_OK1;
                            } else {
                                that.bitb = b;
                                that.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                that.write = q;
                                return that.inflate_flush(z, r);
                            }
                            n--;
                            b |= (z.read_byte(p++) & 0xff) << k;
                            k += 8;
                        }
                        t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];
                        c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];
                        if (c < 16) {
                            b >>>= t;
                            k -= t;
                            blens[index++] = c;
                        } else {
                            i = c == 18 ? 7 : c - 14;
                            j = c == 18 ? 11 : 3;
                            while(k < t + i){
                                if (n !== 0) {
                                    r = Z_OK1;
                                } else {
                                    that.bitb = b;
                                    that.bitk = k;
                                    z.avail_in = n;
                                    z.total_in += p - z.next_in_index;
                                    z.next_in_index = p;
                                    that.write = q;
                                    return that.inflate_flush(z, r);
                                }
                                n--;
                                b |= (z.read_byte(p++) & 0xff) << k;
                                k += 8;
                            }
                            b >>>= t;
                            k -= t;
                            j += b & inflate_mask[i];
                            b >>>= i;
                            k -= i;
                            i = index;
                            t = table;
                            if (i + j > 258 + (t & 0x1f) + (t >> 5 & 0x1f) || c == 16 && i < 1) {
                                blens = null;
                                mode = BADBLOCKS;
                                z.msg = "invalid bit length repeat";
                                r = Z_DATA_ERROR1;
                                that.bitb = b;
                                that.bitk = k;
                                z.avail_in = n;
                                z.total_in += p - z.next_in_index;
                                z.next_in_index = p;
                                that.write = q;
                                return that.inflate_flush(z, r);
                            }
                            c = c == 16 ? blens[i - 1] : 0;
                            do {
                                blens[i++] = c;
                            }while (--j !== 0)
                            index = i;
                        }
                    }
                    tb[0] = -1;
                    bl_ = [];
                    bd_ = [];
                    tl_ = [];
                    td_ = [];
                    bl_[0] = 9;
                    bd_[0] = 6;
                    t = table;
                    t = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + (t >> 5 & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);
                    if (t != Z_OK1) {
                        if (t == Z_DATA_ERROR1) {
                            blens = null;
                            mode = BADBLOCKS;
                        }
                        r = t;
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);
                    mode = CODES;
                case CODES:
                    that.bitb = b;
                    that.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    that.write = q;
                    if ((r = codes.proc(that, z, r)) != Z_STREAM_END1) {
                        return that.inflate_flush(z, r);
                    }
                    r = Z_OK1;
                    codes.free(z);
                    p = z.next_in_index;
                    n = z.avail_in;
                    b = that.bitb;
                    k = that.bitk;
                    q = that.write;
                    m = q < that.read ? that.read - q - 1 : that.end - q;
                    if (last === 0) {
                        mode = TYPE;
                        break;
                    }
                    mode = DRY;
                case DRY:
                    that.write = q;
                    r = that.inflate_flush(z, r);
                    q = that.write;
                    m = q < that.read ? that.read - q - 1 : that.end - q;
                    if (that.read != that.write) {
                        that.bitb = b;
                        that.bitk = k;
                        z.avail_in = n;
                        z.total_in += p - z.next_in_index;
                        z.next_in_index = p;
                        that.write = q;
                        return that.inflate_flush(z, r);
                    }
                    mode = DONELOCKS;
                case DONELOCKS:
                    r = Z_STREAM_END1;
                    that.bitb = b;
                    that.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    that.write = q;
                    return that.inflate_flush(z, r);
                case BADBLOCKS:
                    r = Z_DATA_ERROR1;
                    that.bitb = b;
                    that.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    that.write = q;
                    return that.inflate_flush(z, r);
                default:
                    r = Z_STREAM_ERROR1;
                    that.bitb = b;
                    that.bitk = k;
                    z.avail_in = n;
                    z.total_in += p - z.next_in_index;
                    z.next_in_index = p;
                    that.write = q;
                    return that.inflate_flush(z, r);
            }
        }
    };
    that.free = function(z) {
        that.reset(z, null);
        that.win = null;
        hufts = null;
    };
    that.set_dictionary = function(d, start, n) {
        that.win.set(d.subarray(start, start + n), 0);
        that.read = that.write = n;
    };
    that.sync_point = function() {
        return mode == LENS ? 1 : 0;
    };
}
const PRESET_DICT1 = 0x20;
const Z_DEFLATED1 = 8;
const METHOD = 0;
const FLAG = 1;
const DICT4 = 2;
const DICT3 = 3;
const DICT2 = 4;
const DICT1 = 5;
const DICT0 = 6;
const BLOCKS = 7;
const DONE = 12;
const BAD = 13;
const mark = [
    0,
    0,
    0xff,
    0xff
];
function Inflate() {
    const that = this;
    that.mode = 0;
    that.method = 0;
    that.was = [
        0
    ];
    that.need = 0;
    that.marker = 0;
    that.wbits = 0;
    function inflateReset(z) {
        if (!z || !z.istate) return Z_STREAM_ERROR1;
        z.total_in = z.total_out = 0;
        z.msg = null;
        z.istate.mode = BLOCKS;
        z.istate.blocks.reset(z, null);
        return 0;
    }
    that.inflateEnd = function(z) {
        if (that.blocks) that.blocks.free(z);
        that.blocks = null;
        return Z_OK1;
    };
    that.inflateInit = function(z, w) {
        z.msg = null;
        that.blocks = null;
        if (w < 8 || w > 15) {
            that.inflateEnd(z);
            return Z_STREAM_ERROR1;
        }
        that.wbits = w;
        z.istate.blocks = new InfBlocks(z, 1 << w);
        inflateReset(z);
        return Z_OK1;
    };
    that.inflate = function(z, f) {
        let r;
        let b;
        if (!z || !z.istate || !z.next_in) return Z_STREAM_ERROR1;
        const istate = z.istate;
        f = f == Z_FINISH1 ? Z_BUF_ERROR1 : Z_OK1;
        r = Z_BUF_ERROR1;
        while(true){
            switch(istate.mode){
                case METHOD:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    if (((istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED1) {
                        istate.mode = BAD;
                        z.msg = "unknown compression method";
                        istate.marker = 5;
                        break;
                    }
                    if ((istate.method >> 4) + 8 > istate.wbits) {
                        istate.mode = BAD;
                        z.msg = "invalid win size";
                        istate.marker = 5;
                        break;
                    }
                    istate.mode = FLAG;
                case FLAG:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    b = z.read_byte(z.next_in_index++) & 0xff;
                    if (((istate.method << 8) + b) % 31 !== 0) {
                        istate.mode = BAD;
                        z.msg = "incorrect header check";
                        istate.marker = 5;
                        break;
                    }
                    if ((b & PRESET_DICT1) === 0) {
                        istate.mode = BLOCKS;
                        break;
                    }
                    istate.mode = DICT4;
                case DICT4:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    istate.need = (z.read_byte(z.next_in_index++) & 0xff) << 24 & 0xff000000;
                    istate.mode = DICT3;
                case DICT3:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    istate.need += (z.read_byte(z.next_in_index++) & 0xff) << 16 & 0xff0000;
                    istate.mode = DICT2;
                case DICT2:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    istate.need += (z.read_byte(z.next_in_index++) & 0xff) << 8 & 0xff00;
                    istate.mode = DICT1;
                case DICT1:
                    if (z.avail_in === 0) return r;
                    r = f;
                    z.avail_in--;
                    z.total_in++;
                    istate.need += z.read_byte(z.next_in_index++) & 0xff;
                    istate.mode = DICT0;
                    return Z_NEED_DICT1;
                case DICT0:
                    istate.mode = BAD;
                    z.msg = "need dictionary";
                    istate.marker = 0;
                    return Z_STREAM_ERROR1;
                case BLOCKS:
                    r = istate.blocks.proc(z, r);
                    if (r == Z_DATA_ERROR1) {
                        istate.mode = BAD;
                        istate.marker = 0;
                        break;
                    }
                    if (r == Z_OK1) {
                        r = f;
                    }
                    if (r != Z_STREAM_END1) {
                        return r;
                    }
                    r = f;
                    istate.blocks.reset(z, istate.was);
                    istate.mode = DONE;
                case DONE:
                    z.avail_in = 0;
                    return Z_STREAM_END1;
                case BAD:
                    return Z_DATA_ERROR1;
                default:
                    return Z_STREAM_ERROR1;
            }
        }
    };
    that.inflateSetDictionary = function(z, dictionary, dictLength) {
        let index = 0, length = dictLength;
        if (!z || !z.istate || z.istate.mode != DICT0) return Z_STREAM_ERROR1;
        const istate = z.istate;
        if (length >= 1 << istate.wbits) {
            length = (1 << istate.wbits) - 1;
            index = dictLength - length;
        }
        istate.blocks.set_dictionary(dictionary, index, length);
        istate.mode = BLOCKS;
        return Z_OK1;
    };
    that.inflateSync = function(z) {
        let n;
        let p;
        let m;
        let r, w;
        if (!z || !z.istate) return Z_STREAM_ERROR1;
        const istate = z.istate;
        if (istate.mode != BAD) {
            istate.mode = BAD;
            istate.marker = 0;
        }
        if ((n = z.avail_in) === 0) return Z_BUF_ERROR1;
        p = z.next_in_index;
        m = istate.marker;
        while(n !== 0 && m < 4){
            if (z.read_byte(p) == mark[m]) {
                m++;
            } else if (z.read_byte(p) !== 0) {
                m = 0;
            } else {
                m = 4 - m;
            }
            p++;
            n--;
        }
        z.total_in += p - z.next_in_index;
        z.next_in_index = p;
        z.avail_in = n;
        istate.marker = m;
        if (m != 4) {
            return Z_DATA_ERROR1;
        }
        r = z.total_in;
        w = z.total_out;
        inflateReset(z);
        z.total_in = r;
        z.total_out = w;
        istate.mode = BLOCKS;
        return Z_OK1;
    };
    that.inflateSyncPoint = function(z) {
        if (!z || !z.istate || !z.istate.blocks) return Z_STREAM_ERROR1;
        return z.istate.blocks.sync_point();
    };
}
function ZStream1() {}
ZStream1.prototype = {
    inflateInit (bits) {
        const that = this;
        that.istate = new Inflate();
        if (!bits) bits = MAX_BITS1;
        return that.istate.inflateInit(that, bits);
    },
    inflate (f) {
        const that = this;
        if (!that.istate) return Z_STREAM_ERROR1;
        return that.istate.inflate(that, f);
    },
    inflateEnd () {
        const that = this;
        if (!that.istate) return Z_STREAM_ERROR1;
        const ret = that.istate.inflateEnd(that);
        that.istate = null;
        return ret;
    },
    inflateSync () {
        const that = this;
        if (!that.istate) return Z_STREAM_ERROR1;
        return that.istate.inflateSync(that);
    },
    inflateSetDictionary (dictionary, dictLength) {
        const that = this;
        if (!that.istate) return Z_STREAM_ERROR1;
        return that.istate.inflateSetDictionary(that, dictionary, dictLength);
    },
    read_byte (start) {
        const that = this;
        return that.next_in[start];
    },
    read_buf (start, size) {
        const that = this;
        return that.next_in.subarray(start, start + size);
    }
};
function ZipInflate(options) {
    const that = this;
    const z = new ZStream1();
    const bufsize = options && options.chunkSize ? Math.floor(options.chunkSize * 2) : 128 * 1024;
    const flush = 0;
    const buf = new Uint8Array(bufsize);
    let nomoreinput = false;
    z.inflateInit();
    z.next_out = buf;
    that.append = function(data, onprogress) {
        const buffers = [];
        let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
        if (data.length === 0) return;
        z.next_in_index = 0;
        z.next_in = data;
        z.avail_in = data.length;
        do {
            z.next_out_index = 0;
            z.avail_out = bufsize;
            if (z.avail_in === 0 && !nomoreinput) {
                z.next_in_index = 0;
                nomoreinput = true;
            }
            err = z.inflate(flush);
            if (nomoreinput && err === Z_BUF_ERROR1) {
                if (z.avail_in !== 0) throw new Error("inflating: bad input");
            } else if (err !== Z_OK1 && err !== Z_STREAM_END1) throw new Error("inflating: " + z.msg);
            if ((nomoreinput || err === Z_STREAM_END1) && z.avail_in === data.length) throw new Error("inflating: bad input");
            if (z.next_out_index) if (z.next_out_index === bufsize) buffers.push(new Uint8Array(buf));
            else buffers.push(buf.subarray(0, z.next_out_index));
            bufferSize += z.next_out_index;
            if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
                onprogress(z.next_in_index);
                lastIndex = z.next_in_index;
            }
        }while (z.avail_in > 0 || z.avail_out === 0)
        if (buffers.length > 1) {
            array = new Uint8Array(bufferSize);
            buffers.forEach(function(chunk) {
                array.set(chunk, bufferIndex);
                bufferIndex += chunk.length;
            });
        } else {
            array = buffers[0] ? new Uint8Array(buffers[0]) : new Uint8Array();
        }
        return array;
    };
    that.flush = function() {
        z.inflateEnd();
    };
}
const END_OF_CENTRAL_DIR_LENGTH = 22;
const ZIP64_END_OF_CENTRAL_DIR_LENGTH = 56;
const DIRECTORY_SIGNATURE = "/";
new Date(2107, 11, 31);
new Date(1980, 0, 1);
const UNDEFINED_VALUE = undefined;
const UNDEFINED_TYPE = "undefined";
const FUNCTION_TYPE = "function";
class StreamAdapter {
    constructor(Codec){
        return class extends TransformStream {
            constructor(_format, options){
                const codec = new Codec(options);
                super({
                    transform (chunk, controller) {
                        controller.enqueue(codec.append(chunk));
                    },
                    flush (controller) {
                        const chunk = codec.flush();
                        if (chunk) {
                            controller.enqueue(chunk);
                        }
                    }
                });
            }
        };
    }
}
let maxWorkers = 2;
try {
    if (typeof navigator != UNDEFINED_TYPE && navigator.hardwareConcurrency) {
        maxWorkers = navigator.hardwareConcurrency;
    }
} catch (_error) {}
const DEFAULT_CONFIGURATION = {
    chunkSize: 512 * 1024,
    maxWorkers,
    terminateWorkerTimeout: 5000,
    useWebWorkers: true,
    useCompressionStream: true,
    workerScripts: UNDEFINED_VALUE,
    CompressionStreamNative: typeof CompressionStream != UNDEFINED_TYPE && CompressionStream,
    DecompressionStreamNative: typeof DecompressionStream != UNDEFINED_TYPE && DecompressionStream
};
const config = Object.assign({}, DEFAULT_CONFIGURATION);
function getConfiguration() {
    return config;
}
function getChunkSize(config) {
    return Math.max(config.chunkSize, 64);
}
function configure(configuration) {
    const { baseURL, chunkSize, maxWorkers, terminateWorkerTimeout, useCompressionStream, useWebWorkers, Deflate, Inflate, CompressionStream: CompressionStream1, DecompressionStream: DecompressionStream1, workerScripts } = configuration;
    setIfDefined("baseURL", baseURL);
    setIfDefined("chunkSize", chunkSize);
    setIfDefined("maxWorkers", maxWorkers);
    setIfDefined("terminateWorkerTimeout", terminateWorkerTimeout);
    setIfDefined("useCompressionStream", useCompressionStream);
    setIfDefined("useWebWorkers", useWebWorkers);
    if (Deflate) {
        config.CompressionStream = new StreamAdapter(Deflate);
    }
    if (Inflate) {
        config.DecompressionStream = new StreamAdapter(Inflate);
    }
    setIfDefined("CompressionStream", CompressionStream1);
    setIfDefined("DecompressionStream", DecompressionStream1);
    if (workerScripts !== UNDEFINED_VALUE) {
        const { deflate, inflate } = workerScripts;
        if (deflate || inflate) {
            if (!config.workerScripts) {
                config.workerScripts = {};
            }
        }
        if (deflate) {
            if (!Array.isArray(deflate)) {
                throw new Error("workerScripts.deflate must be an array");
            }
            config.workerScripts.deflate = deflate;
        }
        if (inflate) {
            if (!Array.isArray(inflate)) {
                throw new Error("workerScripts.inflate must be an array");
            }
            config.workerScripts.inflate = inflate;
        }
    }
}
function setIfDefined(propertyName, propertyValue) {
    if (propertyValue !== UNDEFINED_VALUE) {
        config[propertyName] = propertyValue;
    }
}
const table = {
    "application": {
        "andrew-inset": "ez",
        "annodex": "anx",
        "atom+xml": "atom",
        "atomcat+xml": "atomcat",
        "atomserv+xml": "atomsrv",
        "bbolin": "lin",
        "cap": [
            "cap",
            "pcap"
        ],
        "cu-seeme": "cu",
        "davmount+xml": "davmount",
        "dsptype": "tsp",
        "ecmascript": [
            "es",
            "ecma"
        ],
        "futuresplash": "spl",
        "hta": "hta",
        "java-archive": "jar",
        "java-serialized-object": "ser",
        "java-vm": "class",
        "javascript": "js",
        "m3g": "m3g",
        "mac-binhex40": "hqx",
        "mathematica": [
            "nb",
            "ma",
            "mb"
        ],
        "msaccess": "mdb",
        "msword": [
            "doc",
            "dot"
        ],
        "mxf": "mxf",
        "oda": "oda",
        "ogg": "ogx",
        "pdf": "pdf",
        "pgp-keys": "key",
        "pgp-signature": [
            "asc",
            "sig"
        ],
        "pics-rules": "prf",
        "postscript": [
            "ps",
            "ai",
            "eps",
            "epsi",
            "epsf",
            "eps2",
            "eps3"
        ],
        "rar": "rar",
        "rdf+xml": "rdf",
        "rss+xml": "rss",
        "rtf": "rtf",
        "smil": [
            "smi",
            "smil"
        ],
        "xhtml+xml": [
            "xhtml",
            "xht"
        ],
        "xml": [
            "xml",
            "xsl",
            "xsd"
        ],
        "xspf+xml": "xspf",
        "zip": "zip",
        "vnd.android.package-archive": "apk",
        "vnd.cinderella": "cdy",
        "vnd.google-earth.kml+xml": "kml",
        "vnd.google-earth.kmz": "kmz",
        "vnd.mozilla.xul+xml": "xul",
        "vnd.ms-excel": [
            "xls",
            "xlb",
            "xlt",
            "xlm",
            "xla",
            "xlc",
            "xlw"
        ],
        "vnd.ms-pki.seccat": "cat",
        "vnd.ms-pki.stl": "stl",
        "vnd.ms-powerpoint": [
            "ppt",
            "pps",
            "pot"
        ],
        "vnd.oasis.opendocument.chart": "odc",
        "vnd.oasis.opendocument.database": "odb",
        "vnd.oasis.opendocument.formula": "odf",
        "vnd.oasis.opendocument.graphics": "odg",
        "vnd.oasis.opendocument.graphics-template": "otg",
        "vnd.oasis.opendocument.image": "odi",
        "vnd.oasis.opendocument.presentation": "odp",
        "vnd.oasis.opendocument.presentation-template": "otp",
        "vnd.oasis.opendocument.spreadsheet": "ods",
        "vnd.oasis.opendocument.spreadsheet-template": "ots",
        "vnd.oasis.opendocument.text": "odt",
        "vnd.oasis.opendocument.text-master": "odm",
        "vnd.oasis.opendocument.text-template": "ott",
        "vnd.oasis.opendocument.text-web": "oth",
        "vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
        "vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
        "vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
        "vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
        "vnd.openxmlformats-officedocument.presentationml.template": "potx",
        "vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
        "vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
        "vnd.smaf": "mmf",
        "vnd.stardivision.calc": "sdc",
        "vnd.stardivision.chart": "sds",
        "vnd.stardivision.draw": "sda",
        "vnd.stardivision.impress": "sdd",
        "vnd.stardivision.math": [
            "sdf",
            "smf"
        ],
        "vnd.stardivision.writer": [
            "sdw",
            "vor"
        ],
        "vnd.stardivision.writer-global": "sgl",
        "vnd.sun.xml.calc": "sxc",
        "vnd.sun.xml.calc.template": "stc",
        "vnd.sun.xml.draw": "sxd",
        "vnd.sun.xml.draw.template": "std",
        "vnd.sun.xml.impress": "sxi",
        "vnd.sun.xml.impress.template": "sti",
        "vnd.sun.xml.math": "sxm",
        "vnd.sun.xml.writer": "sxw",
        "vnd.sun.xml.writer.global": "sxg",
        "vnd.sun.xml.writer.template": "stw",
        "vnd.symbian.install": [
            "sis",
            "sisx"
        ],
        "vnd.visio": [
            "vsd",
            "vst",
            "vss",
            "vsw"
        ],
        "vnd.wap.wbxml": "wbxml",
        "vnd.wap.wmlc": "wmlc",
        "vnd.wap.wmlscriptc": "wmlsc",
        "vnd.wordperfect": "wpd",
        "vnd.wordperfect5.1": "wp5",
        "x-123": "wk",
        "x-7z-compressed": "7z",
        "x-abiword": "abw",
        "x-apple-diskimage": "dmg",
        "x-bcpio": "bcpio",
        "x-bittorrent": "torrent",
        "x-cbr": [
            "cbr",
            "cba",
            "cbt",
            "cb7"
        ],
        "x-cbz": "cbz",
        "x-cdf": [
            "cdf",
            "cda"
        ],
        "x-cdlink": "vcd",
        "x-chess-pgn": "pgn",
        "x-cpio": "cpio",
        "x-csh": "csh",
        "x-debian-package": [
            "deb",
            "udeb"
        ],
        "x-director": [
            "dcr",
            "dir",
            "dxr",
            "cst",
            "cct",
            "cxt",
            "w3d",
            "fgd",
            "swa"
        ],
        "x-dms": "dms",
        "x-doom": "wad",
        "x-dvi": "dvi",
        "x-httpd-eruby": "rhtml",
        "x-font": "pcf.Z",
        "x-freemind": "mm",
        "x-gnumeric": "gnumeric",
        "x-go-sgf": "sgf",
        "x-graphing-calculator": "gcf",
        "x-gtar": [
            "gtar",
            "taz"
        ],
        "x-hdf": "hdf",
        "x-httpd-php": [
            "phtml",
            "pht",
            "php"
        ],
        "x-httpd-php-source": "phps",
        "x-httpd-php3": "php3",
        "x-httpd-php3-preprocessed": "php3p",
        "x-httpd-php4": "php4",
        "x-httpd-php5": "php5",
        "x-ica": "ica",
        "x-info": "info",
        "x-internet-signup": [
            "ins",
            "isp"
        ],
        "x-iphone": "iii",
        "x-iso9660-image": "iso",
        "x-java-jnlp-file": "jnlp",
        "x-jmol": "jmz",
        "x-killustrator": "kil",
        "x-koan": [
            "skp",
            "skd",
            "skt",
            "skm"
        ],
        "x-kpresenter": [
            "kpr",
            "kpt"
        ],
        "x-kword": [
            "kwd",
            "kwt"
        ],
        "x-latex": "latex",
        "x-lha": "lha",
        "x-lyx": "lyx",
        "x-lzh": "lzh",
        "x-lzx": "lzx",
        "x-maker": [
            "frm",
            "maker",
            "frame",
            "fm",
            "fb",
            "book",
            "fbdoc"
        ],
        "x-ms-wmd": "wmd",
        "x-ms-wmz": "wmz",
        "x-msdos-program": [
            "com",
            "exe",
            "bat",
            "dll"
        ],
        "x-msi": "msi",
        "x-netcdf": [
            "nc",
            "cdf"
        ],
        "x-ns-proxy-autoconfig": [
            "pac",
            "dat"
        ],
        "x-nwc": "nwc",
        "x-object": "o",
        "x-oz-application": "oza",
        "x-pkcs7-certreqresp": "p7r",
        "x-python-code": [
            "pyc",
            "pyo"
        ],
        "x-qgis": [
            "qgs",
            "shp",
            "shx"
        ],
        "x-quicktimeplayer": "qtl",
        "x-redhat-package-manager": "rpm",
        "x-ruby": "rb",
        "x-sh": "sh",
        "x-shar": "shar",
        "x-shockwave-flash": [
            "swf",
            "swfl"
        ],
        "x-silverlight": "scr",
        "x-stuffit": "sit",
        "x-sv4cpio": "sv4cpio",
        "x-sv4crc": "sv4crc",
        "x-tar": "tar",
        "x-tcl": "tcl",
        "x-tex-gf": "gf",
        "x-tex-pk": "pk",
        "x-texinfo": [
            "texinfo",
            "texi"
        ],
        "x-trash": [
            "~",
            "%",
            "bak",
            "old",
            "sik"
        ],
        "x-troff": [
            "t",
            "tr",
            "roff"
        ],
        "x-troff-man": "man",
        "x-troff-me": "me",
        "x-troff-ms": "ms",
        "x-ustar": "ustar",
        "x-wais-source": "src",
        "x-wingz": "wz",
        "x-x509-ca-cert": [
            "crt",
            "der",
            "cer"
        ],
        "x-xcf": "xcf",
        "x-xfig": "fig",
        "x-xpinstall": "xpi",
        "applixware": "aw",
        "atomsvc+xml": "atomsvc",
        "ccxml+xml": "ccxml",
        "cdmi-capability": "cdmia",
        "cdmi-container": "cdmic",
        "cdmi-domain": "cdmid",
        "cdmi-object": "cdmio",
        "cdmi-queue": "cdmiq",
        "docbook+xml": "dbk",
        "dssc+der": "dssc",
        "dssc+xml": "xdssc",
        "emma+xml": "emma",
        "epub+zip": "epub",
        "exi": "exi",
        "font-tdpfr": "pfr",
        "gml+xml": "gml",
        "gpx+xml": "gpx",
        "gxf": "gxf",
        "hyperstudio": "stk",
        "inkml+xml": [
            "ink",
            "inkml"
        ],
        "ipfix": "ipfix",
        "json": "json",
        "jsonml+json": "jsonml",
        "lost+xml": "lostxml",
        "mads+xml": "mads",
        "marc": "mrc",
        "marcxml+xml": "mrcx",
        "mathml+xml": "mathml",
        "mbox": "mbox",
        "mediaservercontrol+xml": "mscml",
        "metalink+xml": "metalink",
        "metalink4+xml": "meta4",
        "mets+xml": "mets",
        "mods+xml": "mods",
        "mp21": [
            "m21",
            "mp21"
        ],
        "mp4": "mp4s",
        "oebps-package+xml": "opf",
        "omdoc+xml": "omdoc",
        "onenote": [
            "onetoc",
            "onetoc2",
            "onetmp",
            "onepkg"
        ],
        "oxps": "oxps",
        "patch-ops-error+xml": "xer",
        "pgp-encrypted": "pgp",
        "pkcs10": "p10",
        "pkcs7-mime": [
            "p7m",
            "p7c"
        ],
        "pkcs7-signature": "p7s",
        "pkcs8": "p8",
        "pkix-attr-cert": "ac",
        "pkix-crl": "crl",
        "pkix-pkipath": "pkipath",
        "pkixcmp": "pki",
        "pls+xml": "pls",
        "prs.cww": "cww",
        "pskc+xml": "pskcxml",
        "reginfo+xml": "rif",
        "relax-ng-compact-syntax": "rnc",
        "resource-lists+xml": "rl",
        "resource-lists-diff+xml": "rld",
        "rls-services+xml": "rs",
        "rpki-ghostbusters": "gbr",
        "rpki-manifest": "mft",
        "rpki-roa": "roa",
        "rsd+xml": "rsd",
        "sbml+xml": "sbml",
        "scvp-cv-request": "scq",
        "scvp-cv-response": "scs",
        "scvp-vp-request": "spq",
        "scvp-vp-response": "spp",
        "sdp": "sdp",
        "set-payment-initiation": "setpay",
        "set-registration-initiation": "setreg",
        "shf+xml": "shf",
        "sparql-query": "rq",
        "sparql-results+xml": "srx",
        "srgs": "gram",
        "srgs+xml": "grxml",
        "sru+xml": "sru",
        "ssdl+xml": "ssdl",
        "ssml+xml": "ssml",
        "tei+xml": [
            "tei",
            "teicorpus"
        ],
        "thraud+xml": "tfi",
        "timestamped-data": "tsd",
        "vnd.3gpp.pic-bw-large": "plb",
        "vnd.3gpp.pic-bw-small": "psb",
        "vnd.3gpp.pic-bw-var": "pvb",
        "vnd.3gpp2.tcap": "tcap",
        "vnd.3m.post-it-notes": "pwn",
        "vnd.accpac.simply.aso": "aso",
        "vnd.accpac.simply.imp": "imp",
        "vnd.acucobol": "acu",
        "vnd.acucorp": [
            "atc",
            "acutc"
        ],
        "vnd.adobe.air-application-installer-package+zip": "air",
        "vnd.adobe.formscentral.fcdt": "fcdt",
        "vnd.adobe.fxp": [
            "fxp",
            "fxpl"
        ],
        "vnd.adobe.xdp+xml": "xdp",
        "vnd.adobe.xfdf": "xfdf",
        "vnd.ahead.space": "ahead",
        "vnd.airzip.filesecure.azf": "azf",
        "vnd.airzip.filesecure.azs": "azs",
        "vnd.amazon.ebook": "azw",
        "vnd.americandynamics.acc": "acc",
        "vnd.amiga.ami": "ami",
        "vnd.anser-web-certificate-issue-initiation": "cii",
        "vnd.anser-web-funds-transfer-initiation": "fti",
        "vnd.antix.game-component": "atx",
        "vnd.apple.installer+xml": "mpkg",
        "vnd.apple.mpegurl": "m3u8",
        "vnd.aristanetworks.swi": "swi",
        "vnd.astraea-software.iota": "iota",
        "vnd.audiograph": "aep",
        "vnd.blueice.multipass": "mpm",
        "vnd.bmi": "bmi",
        "vnd.businessobjects": "rep",
        "vnd.chemdraw+xml": "cdxml",
        "vnd.chipnuts.karaoke-mmd": "mmd",
        "vnd.claymore": "cla",
        "vnd.cloanto.rp9": "rp9",
        "vnd.clonk.c4group": [
            "c4g",
            "c4d",
            "c4f",
            "c4p",
            "c4u"
        ],
        "vnd.cluetrust.cartomobile-config": "c11amc",
        "vnd.cluetrust.cartomobile-config-pkg": "c11amz",
        "vnd.commonspace": "csp",
        "vnd.contact.cmsg": "cdbcmsg",
        "vnd.cosmocaller": "cmc",
        "vnd.crick.clicker": "clkx",
        "vnd.crick.clicker.keyboard": "clkk",
        "vnd.crick.clicker.palette": "clkp",
        "vnd.crick.clicker.template": "clkt",
        "vnd.crick.clicker.wordbank": "clkw",
        "vnd.criticaltools.wbs+xml": "wbs",
        "vnd.ctc-posml": "pml",
        "vnd.cups-ppd": "ppd",
        "vnd.curl.car": "car",
        "vnd.curl.pcurl": "pcurl",
        "vnd.dart": "dart",
        "vnd.data-vision.rdz": "rdz",
        "vnd.dece.data": [
            "uvf",
            "uvvf",
            "uvd",
            "uvvd"
        ],
        "vnd.dece.ttml+xml": [
            "uvt",
            "uvvt"
        ],
        "vnd.dece.unspecified": [
            "uvx",
            "uvvx"
        ],
        "vnd.dece.zip": [
            "uvz",
            "uvvz"
        ],
        "vnd.denovo.fcselayout-link": "fe_launch",
        "vnd.dna": "dna",
        "vnd.dolby.mlp": "mlp",
        "vnd.dpgraph": "dpg",
        "vnd.dreamfactory": "dfac",
        "vnd.ds-keypoint": "kpxx",
        "vnd.dvb.ait": "ait",
        "vnd.dvb.service": "svc",
        "vnd.dynageo": "geo",
        "vnd.ecowin.chart": "mag",
        "vnd.enliven": "nml",
        "vnd.epson.esf": "esf",
        "vnd.epson.msf": "msf",
        "vnd.epson.quickanime": "qam",
        "vnd.epson.salt": "slt",
        "vnd.epson.ssf": "ssf",
        "vnd.eszigno3+xml": [
            "es3",
            "et3"
        ],
        "vnd.ezpix-album": "ez2",
        "vnd.ezpix-package": "ez3",
        "vnd.fdf": "fdf",
        "vnd.fdsn.mseed": "mseed",
        "vnd.fdsn.seed": [
            "seed",
            "dataless"
        ],
        "vnd.flographit": "gph",
        "vnd.fluxtime.clip": "ftc",
        "vnd.framemaker": [
            "fm",
            "frame",
            "maker",
            "book"
        ],
        "vnd.frogans.fnc": "fnc",
        "vnd.frogans.ltf": "ltf",
        "vnd.fsc.weblaunch": "fsc",
        "vnd.fujitsu.oasys": "oas",
        "vnd.fujitsu.oasys2": "oa2",
        "vnd.fujitsu.oasys3": "oa3",
        "vnd.fujitsu.oasysgp": "fg5",
        "vnd.fujitsu.oasysprs": "bh2",
        "vnd.fujixerox.ddd": "ddd",
        "vnd.fujixerox.docuworks": "xdw",
        "vnd.fujixerox.docuworks.binder": "xbd",
        "vnd.fuzzysheet": "fzs",
        "vnd.genomatix.tuxedo": "txd",
        "vnd.geogebra.file": "ggb",
        "vnd.geogebra.tool": "ggt",
        "vnd.geometry-explorer": [
            "gex",
            "gre"
        ],
        "vnd.geonext": "gxt",
        "vnd.geoplan": "g2w",
        "vnd.geospace": "g3w",
        "vnd.gmx": "gmx",
        "vnd.grafeq": [
            "gqf",
            "gqs"
        ],
        "vnd.groove-account": "gac",
        "vnd.groove-help": "ghf",
        "vnd.groove-identity-message": "gim",
        "vnd.groove-injector": "grv",
        "vnd.groove-tool-message": "gtm",
        "vnd.groove-tool-template": "tpl",
        "vnd.groove-vcard": "vcg",
        "vnd.hal+xml": "hal",
        "vnd.handheld-entertainment+xml": "zmm",
        "vnd.hbci": "hbci",
        "vnd.hhe.lesson-player": "les",
        "vnd.hp-hpgl": "hpgl",
        "vnd.hp-hpid": "hpid",
        "vnd.hp-hps": "hps",
        "vnd.hp-jlyt": "jlt",
        "vnd.hp-pcl": "pcl",
        "vnd.hp-pclxl": "pclxl",
        "vnd.hydrostatix.sof-data": "sfd-hdstx",
        "vnd.ibm.minipay": "mpy",
        "vnd.ibm.modcap": [
            "afp",
            "listafp",
            "list3820"
        ],
        "vnd.ibm.rights-management": "irm",
        "vnd.ibm.secure-container": "sc",
        "vnd.iccprofile": [
            "icc",
            "icm"
        ],
        "vnd.igloader": "igl",
        "vnd.immervision-ivp": "ivp",
        "vnd.immervision-ivu": "ivu",
        "vnd.insors.igm": "igm",
        "vnd.intercon.formnet": [
            "xpw",
            "xpx"
        ],
        "vnd.intergeo": "i2g",
        "vnd.intu.qbo": "qbo",
        "vnd.intu.qfx": "qfx",
        "vnd.ipunplugged.rcprofile": "rcprofile",
        "vnd.irepository.package+xml": "irp",
        "vnd.is-xpr": "xpr",
        "vnd.isac.fcs": "fcs",
        "vnd.jam": "jam",
        "vnd.jcp.javame.midlet-rms": "rms",
        "vnd.jisp": "jisp",
        "vnd.joost.joda-archive": "joda",
        "vnd.kahootz": [
            "ktz",
            "ktr"
        ],
        "vnd.kde.karbon": "karbon",
        "vnd.kde.kchart": "chrt",
        "vnd.kde.kformula": "kfo",
        "vnd.kde.kivio": "flw",
        "vnd.kde.kontour": "kon",
        "vnd.kde.kpresenter": [
            "kpr",
            "kpt"
        ],
        "vnd.kde.kspread": "ksp",
        "vnd.kde.kword": [
            "kwd",
            "kwt"
        ],
        "vnd.kenameaapp": "htke",
        "vnd.kidspiration": "kia",
        "vnd.kinar": [
            "kne",
            "knp"
        ],
        "vnd.koan": [
            "skp",
            "skd",
            "skt",
            "skm"
        ],
        "vnd.kodak-descriptor": "sse",
        "vnd.las.las+xml": "lasxml",
        "vnd.llamagraphics.life-balance.desktop": "lbd",
        "vnd.llamagraphics.life-balance.exchange+xml": "lbe",
        "vnd.lotus-1-2-3": "123",
        "vnd.lotus-approach": "apr",
        "vnd.lotus-freelance": "pre",
        "vnd.lotus-notes": "nsf",
        "vnd.lotus-organizer": "org",
        "vnd.lotus-screencam": "scm",
        "vnd.lotus-wordpro": "lwp",
        "vnd.macports.portpkg": "portpkg",
        "vnd.mcd": "mcd",
        "vnd.medcalcdata": "mc1",
        "vnd.mediastation.cdkey": "cdkey",
        "vnd.mfer": "mwf",
        "vnd.mfmp": "mfm",
        "vnd.micrografx.flo": "flo",
        "vnd.micrografx.igx": "igx",
        "vnd.mif": "mif",
        "vnd.mobius.daf": "daf",
        "vnd.mobius.dis": "dis",
        "vnd.mobius.mbk": "mbk",
        "vnd.mobius.mqy": "mqy",
        "vnd.mobius.msl": "msl",
        "vnd.mobius.plc": "plc",
        "vnd.mobius.txf": "txf",
        "vnd.mophun.application": "mpn",
        "vnd.mophun.certificate": "mpc",
        "vnd.ms-artgalry": "cil",
        "vnd.ms-cab-compressed": "cab",
        "vnd.ms-excel.addin.macroenabled.12": "xlam",
        "vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
        "vnd.ms-excel.sheet.macroenabled.12": "xlsm",
        "vnd.ms-excel.template.macroenabled.12": "xltm",
        "vnd.ms-fontobject": "eot",
        "vnd.ms-htmlhelp": "chm",
        "vnd.ms-ims": "ims",
        "vnd.ms-lrm": "lrm",
        "vnd.ms-officetheme": "thmx",
        "vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
        "vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
        "vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
        "vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
        "vnd.ms-powerpoint.template.macroenabled.12": "potm",
        "vnd.ms-project": [
            "mpp",
            "mpt"
        ],
        "vnd.ms-word.document.macroenabled.12": "docm",
        "vnd.ms-word.template.macroenabled.12": "dotm",
        "vnd.ms-works": [
            "wps",
            "wks",
            "wcm",
            "wdb"
        ],
        "vnd.ms-wpl": "wpl",
        "vnd.ms-xpsdocument": "xps",
        "vnd.mseq": "mseq",
        "vnd.musician": "mus",
        "vnd.muvee.style": "msty",
        "vnd.mynfc": "taglet",
        "vnd.neurolanguage.nlu": "nlu",
        "vnd.nitf": [
            "ntf",
            "nitf"
        ],
        "vnd.noblenet-directory": "nnd",
        "vnd.noblenet-sealer": "nns",
        "vnd.noblenet-web": "nnw",
        "vnd.nokia.n-gage.data": "ngdat",
        "vnd.nokia.n-gage.symbian.install": "n-gage",
        "vnd.nokia.radio-preset": "rpst",
        "vnd.nokia.radio-presets": "rpss",
        "vnd.novadigm.edm": "edm",
        "vnd.novadigm.edx": "edx",
        "vnd.novadigm.ext": "ext",
        "vnd.oasis.opendocument.chart-template": "otc",
        "vnd.oasis.opendocument.formula-template": "odft",
        "vnd.oasis.opendocument.image-template": "oti",
        "vnd.olpc-sugar": "xo",
        "vnd.oma.dd2+xml": "dd2",
        "vnd.openofficeorg.extension": "oxt",
        "vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
        "vnd.osgeo.mapguide.package": "mgp",
        "vnd.osgi.dp": "dp",
        "vnd.osgi.subsystem": "esa",
        "vnd.palm": [
            "pdb",
            "pqa",
            "oprc"
        ],
        "vnd.pawaafile": "paw",
        "vnd.pg.format": "str",
        "vnd.pg.osasli": "ei6",
        "vnd.picsel": "efif",
        "vnd.pmi.widget": "wg",
        "vnd.pocketlearn": "plf",
        "vnd.powerbuilder6": "pbd",
        "vnd.previewsystems.box": "box",
        "vnd.proteus.magazine": "mgz",
        "vnd.publishare-delta-tree": "qps",
        "vnd.pvi.ptid1": "ptid",
        "vnd.quark.quarkxpress": [
            "qxd",
            "qxt",
            "qwd",
            "qwt",
            "qxl",
            "qxb"
        ],
        "vnd.realvnc.bed": "bed",
        "vnd.recordare.musicxml": "mxl",
        "vnd.recordare.musicxml+xml": "musicxml",
        "vnd.rig.cryptonote": "cryptonote",
        "vnd.rn-realmedia": "rm",
        "vnd.rn-realmedia-vbr": "rmvb",
        "vnd.route66.link66+xml": "link66",
        "vnd.sailingtracker.track": "st",
        "vnd.seemail": "see",
        "vnd.sema": "sema",
        "vnd.semd": "semd",
        "vnd.semf": "semf",
        "vnd.shana.informed.formdata": "ifm",
        "vnd.shana.informed.formtemplate": "itp",
        "vnd.shana.informed.interchange": "iif",
        "vnd.shana.informed.package": "ipk",
        "vnd.simtech-mindmapper": [
            "twd",
            "twds"
        ],
        "vnd.smart.teacher": "teacher",
        "vnd.solent.sdkm+xml": [
            "sdkm",
            "sdkd"
        ],
        "vnd.spotfire.dxp": "dxp",
        "vnd.spotfire.sfs": "sfs",
        "vnd.stepmania.package": "smzip",
        "vnd.stepmania.stepchart": "sm",
        "vnd.sus-calendar": [
            "sus",
            "susp"
        ],
        "vnd.svd": "svd",
        "vnd.syncml+xml": "xsm",
        "vnd.syncml.dm+wbxml": "bdm",
        "vnd.syncml.dm+xml": "xdm",
        "vnd.tao.intent-module-archive": "tao",
        "vnd.tcpdump.pcap": [
            "pcap",
            "cap",
            "dmp"
        ],
        "vnd.tmobile-livetv": "tmo",
        "vnd.trid.tpt": "tpt",
        "vnd.triscape.mxs": "mxs",
        "vnd.trueapp": "tra",
        "vnd.ufdl": [
            "ufd",
            "ufdl"
        ],
        "vnd.uiq.theme": "utz",
        "vnd.umajin": "umj",
        "vnd.unity": "unityweb",
        "vnd.uoml+xml": "uoml",
        "vnd.vcx": "vcx",
        "vnd.visionary": "vis",
        "vnd.vsf": "vsf",
        "vnd.webturbo": "wtb",
        "vnd.wolfram.player": "nbp",
        "vnd.wqd": "wqd",
        "vnd.wt.stf": "stf",
        "vnd.xara": "xar",
        "vnd.xfdl": "xfdl",
        "vnd.yamaha.hv-dic": "hvd",
        "vnd.yamaha.hv-script": "hvs",
        "vnd.yamaha.hv-voice": "hvp",
        "vnd.yamaha.openscoreformat": "osf",
        "vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
        "vnd.yamaha.smaf-audio": "saf",
        "vnd.yamaha.smaf-phrase": "spf",
        "vnd.yellowriver-custom-menu": "cmp",
        "vnd.zul": [
            "zir",
            "zirz"
        ],
        "vnd.zzazz.deck+xml": "zaz",
        "voicexml+xml": "vxml",
        "widget": "wgt",
        "winhlp": "hlp",
        "wsdl+xml": "wsdl",
        "wspolicy+xml": "wspolicy",
        "x-ace-compressed": "ace",
        "x-authorware-bin": [
            "aab",
            "x32",
            "u32",
            "vox"
        ],
        "x-authorware-map": "aam",
        "x-authorware-seg": "aas",
        "x-blorb": [
            "blb",
            "blorb"
        ],
        "x-bzip": "bz",
        "x-bzip2": [
            "bz2",
            "boz"
        ],
        "x-cfs-compressed": "cfs",
        "x-chat": "chat",
        "x-conference": "nsc",
        "x-dgc-compressed": "dgc",
        "x-dtbncx+xml": "ncx",
        "x-dtbook+xml": "dtb",
        "x-dtbresource+xml": "res",
        "x-eva": "eva",
        "x-font-bdf": "bdf",
        "x-font-ghostscript": "gsf",
        "x-font-linux-psf": "psf",
        "x-font-otf": "otf",
        "x-font-pcf": "pcf",
        "x-font-snf": "snf",
        "x-font-ttf": [
            "ttf",
            "ttc"
        ],
        "x-font-type1": [
            "pfa",
            "pfb",
            "pfm",
            "afm"
        ],
        "x-font-woff": "woff",
        "x-freearc": "arc",
        "x-gca-compressed": "gca",
        "x-glulx": "ulx",
        "x-gramps-xml": "gramps",
        "x-install-instructions": "install",
        "x-lzh-compressed": [
            "lzh",
            "lha"
        ],
        "x-mie": "mie",
        "x-mobipocket-ebook": [
            "prc",
            "mobi"
        ],
        "x-ms-application": "application",
        "x-ms-shortcut": "lnk",
        "x-ms-xbap": "xbap",
        "x-msbinder": "obd",
        "x-mscardfile": "crd",
        "x-msclip": "clp",
        "x-msdownload": [
            "exe",
            "dll",
            "com",
            "bat",
            "msi"
        ],
        "x-msmediaview": [
            "mvb",
            "m13",
            "m14"
        ],
        "x-msmetafile": [
            "wmf",
            "wmz",
            "emf",
            "emz"
        ],
        "x-msmoney": "mny",
        "x-mspublisher": "pub",
        "x-msschedule": "scd",
        "x-msterminal": "trm",
        "x-mswrite": "wri",
        "x-nzb": "nzb",
        "x-pkcs12": [
            "p12",
            "pfx"
        ],
        "x-pkcs7-certificates": [
            "p7b",
            "spc"
        ],
        "x-research-info-systems": "ris",
        "x-silverlight-app": "xap",
        "x-sql": "sql",
        "x-stuffitx": "sitx",
        "x-subrip": "srt",
        "x-t3vm-image": "t3",
        "x-tads": "gam",
        "x-tex": "tex",
        "x-tex-tfm": "tfm",
        "x-tgif": "obj",
        "x-xliff+xml": "xlf",
        "x-xz": "xz",
        "x-zmachine": [
            "z1",
            "z2",
            "z3",
            "z4",
            "z5",
            "z6",
            "z7",
            "z8"
        ],
        "xaml+xml": "xaml",
        "xcap-diff+xml": "xdf",
        "xenc+xml": "xenc",
        "xml-dtd": "dtd",
        "xop+xml": "xop",
        "xproc+xml": "xpl",
        "xslt+xml": "xslt",
        "xv+xml": [
            "mxml",
            "xhvml",
            "xvml",
            "xvm"
        ],
        "yang": "yang",
        "yin+xml": "yin",
        "envoy": "evy",
        "fractals": "fif",
        "internet-property-stream": "acx",
        "olescript": "axs",
        "vnd.ms-outlook": "msg",
        "vnd.ms-pkicertstore": "sst",
        "x-compress": "z",
        "x-compressed": "tgz",
        "x-gzip": "gz",
        "x-perfmon": [
            "pma",
            "pmc",
            "pml",
            "pmr",
            "pmw"
        ],
        "x-pkcs7-mime": [
            "p7c",
            "p7m"
        ],
        "ynd.ms-pkipko": "pko"
    },
    "audio": {
        "amr": "amr",
        "amr-wb": "awb",
        "annodex": "axa",
        "basic": [
            "au",
            "snd"
        ],
        "flac": "flac",
        "midi": [
            "mid",
            "midi",
            "kar",
            "rmi"
        ],
        "mpeg": [
            "mpga",
            "mpega",
            "mp2",
            "mp3",
            "m4a",
            "mp2a",
            "m2a",
            "m3a"
        ],
        "mpegurl": "m3u",
        "ogg": [
            "oga",
            "ogg",
            "spx"
        ],
        "prs.sid": "sid",
        "x-aiff": [
            "aif",
            "aiff",
            "aifc"
        ],
        "x-gsm": "gsm",
        "x-ms-wma": "wma",
        "x-ms-wax": "wax",
        "x-pn-realaudio": "ram",
        "x-realaudio": "ra",
        "x-sd2": "sd2",
        "x-wav": "wav",
        "adpcm": "adp",
        "mp4": "mp4a",
        "s3m": "s3m",
        "silk": "sil",
        "vnd.dece.audio": [
            "uva",
            "uvva"
        ],
        "vnd.digital-winds": "eol",
        "vnd.dra": "dra",
        "vnd.dts": "dts",
        "vnd.dts.hd": "dtshd",
        "vnd.lucent.voice": "lvp",
        "vnd.ms-playready.media.pya": "pya",
        "vnd.nuera.ecelp4800": "ecelp4800",
        "vnd.nuera.ecelp7470": "ecelp7470",
        "vnd.nuera.ecelp9600": "ecelp9600",
        "vnd.rip": "rip",
        "webm": "weba",
        "x-aac": "aac",
        "x-caf": "caf",
        "x-matroska": "mka",
        "x-pn-realaudio-plugin": "rmp",
        "xm": "xm",
        "mid": [
            "mid",
            "rmi"
        ]
    },
    "chemical": {
        "x-alchemy": "alc",
        "x-cache": [
            "cac",
            "cache"
        ],
        "x-cache-csf": "csf",
        "x-cactvs-binary": [
            "cbin",
            "cascii",
            "ctab"
        ],
        "x-cdx": "cdx",
        "x-chem3d": "c3d",
        "x-cif": "cif",
        "x-cmdf": "cmdf",
        "x-cml": "cml",
        "x-compass": "cpa",
        "x-crossfire": "bsd",
        "x-csml": [
            "csml",
            "csm"
        ],
        "x-ctx": "ctx",
        "x-cxf": [
            "cxf",
            "cef"
        ],
        "x-embl-dl-nucleotide": [
            "emb",
            "embl"
        ],
        "x-gamess-input": [
            "inp",
            "gam",
            "gamin"
        ],
        "x-gaussian-checkpoint": [
            "fch",
            "fchk"
        ],
        "x-gaussian-cube": "cub",
        "x-gaussian-input": [
            "gau",
            "gjc",
            "gjf"
        ],
        "x-gaussian-log": "gal",
        "x-gcg8-sequence": "gcg",
        "x-genbank": "gen",
        "x-hin": "hin",
        "x-isostar": [
            "istr",
            "ist"
        ],
        "x-jcamp-dx": [
            "jdx",
            "dx"
        ],
        "x-kinemage": "kin",
        "x-macmolecule": "mcm",
        "x-macromodel-input": [
            "mmd",
            "mmod"
        ],
        "x-mdl-molfile": "mol",
        "x-mdl-rdfile": "rd",
        "x-mdl-rxnfile": "rxn",
        "x-mdl-sdfile": [
            "sd",
            "sdf"
        ],
        "x-mdl-tgf": "tgf",
        "x-mmcif": "mcif",
        "x-mol2": "mol2",
        "x-molconn-Z": "b",
        "x-mopac-graph": "gpt",
        "x-mopac-input": [
            "mop",
            "mopcrt",
            "mpc",
            "zmt"
        ],
        "x-mopac-out": "moo",
        "x-ncbi-asn1": "asn",
        "x-ncbi-asn1-ascii": [
            "prt",
            "ent"
        ],
        "x-ncbi-asn1-binary": [
            "val",
            "aso"
        ],
        "x-pdb": [
            "pdb",
            "ent"
        ],
        "x-rosdal": "ros",
        "x-swissprot": "sw",
        "x-vamas-iso14976": "vms",
        "x-vmd": "vmd",
        "x-xtel": "xtel",
        "x-xyz": "xyz"
    },
    "image": {
        "gif": "gif",
        "ief": "ief",
        "jpeg": [
            "jpeg",
            "jpg",
            "jpe"
        ],
        "pcx": "pcx",
        "png": "png",
        "svg+xml": [
            "svg",
            "svgz"
        ],
        "tiff": [
            "tiff",
            "tif"
        ],
        "vnd.djvu": [
            "djvu",
            "djv"
        ],
        "vnd.wap.wbmp": "wbmp",
        "x-canon-cr2": "cr2",
        "x-canon-crw": "crw",
        "x-cmu-raster": "ras",
        "x-coreldraw": "cdr",
        "x-coreldrawpattern": "pat",
        "x-coreldrawtemplate": "cdt",
        "x-corelphotopaint": "cpt",
        "x-epson-erf": "erf",
        "x-icon": "ico",
        "x-jg": "art",
        "x-jng": "jng",
        "x-nikon-nef": "nef",
        "x-olympus-orf": "orf",
        "x-photoshop": "psd",
        "x-portable-anymap": "pnm",
        "x-portable-bitmap": "pbm",
        "x-portable-graymap": "pgm",
        "x-portable-pixmap": "ppm",
        "x-rgb": "rgb",
        "x-xbitmap": "xbm",
        "x-xpixmap": "xpm",
        "x-xwindowdump": "xwd",
        "bmp": "bmp",
        "cgm": "cgm",
        "g3fax": "g3",
        "ktx": "ktx",
        "prs.btif": "btif",
        "sgi": "sgi",
        "vnd.dece.graphic": [
            "uvi",
            "uvvi",
            "uvg",
            "uvvg"
        ],
        "vnd.dwg": "dwg",
        "vnd.dxf": "dxf",
        "vnd.fastbidsheet": "fbs",
        "vnd.fpx": "fpx",
        "vnd.fst": "fst",
        "vnd.fujixerox.edmics-mmr": "mmr",
        "vnd.fujixerox.edmics-rlc": "rlc",
        "vnd.ms-modi": "mdi",
        "vnd.ms-photo": "wdp",
        "vnd.net-fpx": "npx",
        "vnd.xiff": "xif",
        "webp": "webp",
        "x-3ds": "3ds",
        "x-cmx": "cmx",
        "x-freehand": [
            "fh",
            "fhc",
            "fh4",
            "fh5",
            "fh7"
        ],
        "x-pict": [
            "pic",
            "pct"
        ],
        "x-tga": "tga",
        "cis-cod": "cod",
        "pipeg": "jfif"
    },
    "message": {
        "rfc822": [
            "eml",
            "mime",
            "mht",
            "mhtml",
            "nws"
        ]
    },
    "model": {
        "iges": [
            "igs",
            "iges"
        ],
        "mesh": [
            "msh",
            "mesh",
            "silo"
        ],
        "vrml": [
            "wrl",
            "vrml"
        ],
        "x3d+vrml": [
            "x3dv",
            "x3dvz"
        ],
        "x3d+xml": [
            "x3d",
            "x3dz"
        ],
        "x3d+binary": [
            "x3db",
            "x3dbz"
        ],
        "vnd.collada+xml": "dae",
        "vnd.dwf": "dwf",
        "vnd.gdl": "gdl",
        "vnd.gtw": "gtw",
        "vnd.mts": "mts",
        "vnd.vtu": "vtu"
    },
    "text": {
        "cache-manifest": [
            "manifest",
            "appcache"
        ],
        "calendar": [
            "ics",
            "icz",
            "ifb"
        ],
        "css": "css",
        "csv": "csv",
        "h323": "323",
        "html": [
            "html",
            "htm",
            "shtml",
            "stm"
        ],
        "iuls": "uls",
        "mathml": "mml",
        "plain": [
            "txt",
            "text",
            "brf",
            "conf",
            "def",
            "list",
            "log",
            "in",
            "bas"
        ],
        "richtext": "rtx",
        "scriptlet": [
            "sct",
            "wsc"
        ],
        "texmacs": [
            "tm",
            "ts"
        ],
        "tab-separated-values": "tsv",
        "vnd.sun.j2me.app-descriptor": "jad",
        "vnd.wap.wml": "wml",
        "vnd.wap.wmlscript": "wmls",
        "x-bibtex": "bib",
        "x-boo": "boo",
        "x-c++hdr": [
            "h++",
            "hpp",
            "hxx",
            "hh"
        ],
        "x-c++src": [
            "c++",
            "cpp",
            "cxx",
            "cc"
        ],
        "x-component": "htc",
        "x-dsrc": "d",
        "x-diff": [
            "diff",
            "patch"
        ],
        "x-haskell": "hs",
        "x-java": "java",
        "x-literate-haskell": "lhs",
        "x-moc": "moc",
        "x-pascal": [
            "p",
            "pas"
        ],
        "x-pcs-gcd": "gcd",
        "x-perl": [
            "pl",
            "pm"
        ],
        "x-python": "py",
        "x-scala": "scala",
        "x-setext": "etx",
        "x-tcl": [
            "tcl",
            "tk"
        ],
        "x-tex": [
            "tex",
            "ltx",
            "sty",
            "cls"
        ],
        "x-vcalendar": "vcs",
        "x-vcard": "vcf",
        "n3": "n3",
        "prs.lines.tag": "dsc",
        "sgml": [
            "sgml",
            "sgm"
        ],
        "troff": [
            "t",
            "tr",
            "roff",
            "man",
            "me",
            "ms"
        ],
        "turtle": "ttl",
        "uri-list": [
            "uri",
            "uris",
            "urls"
        ],
        "vcard": "vcard",
        "vnd.curl": "curl",
        "vnd.curl.dcurl": "dcurl",
        "vnd.curl.scurl": "scurl",
        "vnd.curl.mcurl": "mcurl",
        "vnd.dvb.subtitle": "sub",
        "vnd.fly": "fly",
        "vnd.fmi.flexstor": "flx",
        "vnd.graphviz": "gv",
        "vnd.in3d.3dml": "3dml",
        "vnd.in3d.spot": "spot",
        "x-asm": [
            "s",
            "asm"
        ],
        "x-c": [
            "c",
            "cc",
            "cxx",
            "cpp",
            "h",
            "hh",
            "dic"
        ],
        "x-fortran": [
            "f",
            "for",
            "f77",
            "f90"
        ],
        "x-opml": "opml",
        "x-nfo": "nfo",
        "x-sfv": "sfv",
        "x-uuencode": "uu",
        "webviewhtml": "htt"
    },
    "video": {
        "avif": ".avif",
        "3gpp": "3gp",
        "annodex": "axv",
        "dl": "dl",
        "dv": [
            "dif",
            "dv"
        ],
        "fli": "fli",
        "gl": "gl",
        "mpeg": [
            "mpeg",
            "mpg",
            "mpe",
            "m1v",
            "m2v",
            "mp2",
            "mpa",
            "mpv2"
        ],
        "mp4": [
            "mp4",
            "mp4v",
            "mpg4"
        ],
        "quicktime": [
            "qt",
            "mov"
        ],
        "ogg": "ogv",
        "vnd.mpegurl": [
            "mxu",
            "m4u"
        ],
        "x-flv": "flv",
        "x-la-asf": [
            "lsf",
            "lsx"
        ],
        "x-mng": "mng",
        "x-ms-asf": [
            "asf",
            "asx",
            "asr"
        ],
        "x-ms-wm": "wm",
        "x-ms-wmv": "wmv",
        "x-ms-wmx": "wmx",
        "x-ms-wvx": "wvx",
        "x-msvideo": "avi",
        "x-sgi-movie": "movie",
        "x-matroska": [
            "mpv",
            "mkv",
            "mk3d",
            "mks"
        ],
        "3gpp2": "3g2",
        "h261": "h261",
        "h263": "h263",
        "h264": "h264",
        "jpeg": "jpgv",
        "jpm": [
            "jpm",
            "jpgm"
        ],
        "mj2": [
            "mj2",
            "mjp2"
        ],
        "vnd.dece.hd": [
            "uvh",
            "uvvh"
        ],
        "vnd.dece.mobile": [
            "uvm",
            "uvvm"
        ],
        "vnd.dece.pd": [
            "uvp",
            "uvvp"
        ],
        "vnd.dece.sd": [
            "uvs",
            "uvvs"
        ],
        "vnd.dece.video": [
            "uvv",
            "uvvv"
        ],
        "vnd.dvb.file": "dvb",
        "vnd.fvt": "fvt",
        "vnd.ms-playready.media.pyv": "pyv",
        "vnd.uvvu.mp4": [
            "uvu",
            "uvvu"
        ],
        "vnd.vivo": "viv",
        "webm": "webm",
        "x-f4v": "f4v",
        "x-m4v": "m4v",
        "x-ms-vob": "vob",
        "x-smv": "smv"
    },
    "x-conference": {
        "x-cooltalk": "ice"
    },
    "x-world": {
        "x-vrml": [
            "vrm",
            "vrml",
            "wrl",
            "flr",
            "wrz",
            "xaf",
            "xof"
        ]
    }
};
(()=>{
    const mimeTypes = {};
    for(const type in table){
        if (table.hasOwnProperty(type)) {
            for(const subtype in table[type]){
                if (table[type].hasOwnProperty(subtype)) {
                    const value1 = table[type][subtype];
                    if (typeof value1 == "string") {
                        mimeTypes[value1] = type + "/" + subtype;
                    } else {
                        for(let indexMimeType = 0; indexMimeType < value1.length; indexMimeType++){
                            mimeTypes[value1[indexMimeType]] = type + "/" + subtype;
                        }
                    }
                }
            }
        }
    }
    return mimeTypes;
})();
const table1 = [];
for(let i = 0; i < 256; i++){
    let t = i;
    for(let j = 0; j < 8; j++){
        if (t & 1) {
            t = t >>> 1 ^ 0xEDB88320;
        } else {
            t = t >>> 1;
        }
    }
    table1[i] = t;
}
class Crc32 {
    constructor(crc){
        this.crc = crc || -1;
    }
    append(data) {
        let crc = this.crc | 0;
        for(let offset = 0, length = data.length | 0; offset < length; offset++){
            crc = crc >>> 8 ^ table1[(crc ^ data[offset]) & 0xFF];
        }
        this.crc = crc;
    }
    get() {
        return ~this.crc;
    }
}
class Crc32Stream extends TransformStream {
    constructor(){
        let stream;
        const crc32 = new Crc32();
        super({
            transform (chunk, controller) {
                crc32.append(chunk);
                controller.enqueue(chunk);
            },
            flush () {
                const value1 = new Uint8Array(4);
                const dataView = new DataView(value1.buffer);
                dataView.setUint32(0, crc32.get());
                stream.value = value1;
            }
        });
        stream = this;
    }
}
function encodeText(value1) {
    if (typeof TextEncoder == "undefined") {
        value1 = unescape(encodeURIComponent(value1));
        const result = new Uint8Array(value1.length);
        for(let i = 0; i < result.length; i++){
            result[i] = value1.charCodeAt(i);
        }
        return result;
    } else {
        return new TextEncoder().encode(value1);
    }
}
const bitArray = {
    concat (a1, a2) {
        if (a1.length === 0 || a2.length === 0) {
            return a1.concat(a2);
        }
        const last = a1[a1.length - 1], shift = bitArray.getPartial(last);
        if (shift === 32) {
            return a1.concat(a2);
        } else {
            return bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));
        }
    },
    bitLength (a) {
        const l = a.length;
        if (l === 0) {
            return 0;
        }
        const x = a[l - 1];
        return (l - 1) * 32 + bitArray.getPartial(x);
    },
    clamp (a, len) {
        if (a.length * 32 < len) {
            return a;
        }
        a = a.slice(0, Math.ceil(len / 32));
        const l = a.length;
        len = len & 31;
        if (l > 0 && len) {
            a[l - 1] = bitArray.partial(len, a[l - 1] & 0x80000000 >> len - 1, 1);
        }
        return a;
    },
    partial (len, x, _end) {
        if (len === 32) {
            return x;
        }
        return (_end ? x | 0 : x << 32 - len) + len * 0x10000000000;
    },
    getPartial (x) {
        return Math.round(x / 0x10000000000) || 32;
    },
    _shiftRight (a, shift, carry, out) {
        if (out === undefined) {
            out = [];
        }
        for(; shift >= 32; shift -= 32){
            out.push(carry);
            carry = 0;
        }
        if (shift === 0) {
            return out.concat(a);
        }
        for(let i = 0; i < a.length; i++){
            out.push(carry | a[i] >>> shift);
            carry = a[i] << 32 - shift;
        }
        const last2 = a.length ? a[a.length - 1] : 0;
        const shift2 = bitArray.getPartial(last2);
        out.push(bitArray.partial(shift + shift2 & 31, shift + shift2 > 32 ? carry : out.pop(), 1));
        return out;
    }
};
const codec = {
    bytes: {
        fromBits (arr) {
            const bl = bitArray.bitLength(arr);
            const byteLength = bl / 8;
            const out = new Uint8Array(byteLength);
            let tmp;
            for(let i = 0; i < byteLength; i++){
                if ((i & 3) === 0) {
                    tmp = arr[i / 4];
                }
                out[i] = tmp >>> 24;
                tmp <<= 8;
            }
            return out;
        },
        toBits (bytes) {
            const out = [];
            let i;
            let tmp = 0;
            for(i = 0; i < bytes.length; i++){
                tmp = tmp << 8 | bytes[i];
                if ((i & 3) === 3) {
                    out.push(tmp);
                    tmp = 0;
                }
            }
            if (i & 3) {
                out.push(bitArray.partial(8 * (i & 3), tmp));
            }
            return out;
        }
    }
};
const hash = {};
hash.sha1 = class {
    constructor(hash){
        const sha1 = this;
        sha1.blockSize = 512;
        sha1._init = [
            0x67452301,
            0xEFCDAB89,
            0x98BADCFE,
            0x10325476,
            0xC3D2E1F0
        ];
        sha1._key = [
            0x5A827999,
            0x6ED9EBA1,
            0x8F1BBCDC,
            0xCA62C1D6
        ];
        if (hash) {
            sha1._h = hash._h.slice(0);
            sha1._buffer = hash._buffer.slice(0);
            sha1._length = hash._length;
        } else {
            sha1.reset();
        }
    }
    reset() {
        const sha1 = this;
        sha1._h = sha1._init.slice(0);
        sha1._buffer = [];
        sha1._length = 0;
        return sha1;
    }
    update(data) {
        const sha1 = this;
        if (typeof data === "string") {
            data = codec.utf8String.toBits(data);
        }
        const b = sha1._buffer = bitArray.concat(sha1._buffer, data);
        const ol = sha1._length;
        const nl = sha1._length = ol + bitArray.bitLength(data);
        if (nl > 9007199254740991) {
            throw new Error("Cannot hash more than 2^53 - 1 bits");
        }
        const c = new Uint32Array(b);
        let j = 0;
        for(let i = sha1.blockSize + ol - (sha1.blockSize + ol & sha1.blockSize - 1); i <= nl; i += sha1.blockSize){
            sha1._block(c.subarray(16 * j, 16 * (j + 1)));
            j += 1;
        }
        b.splice(0, 16 * j);
        return sha1;
    }
    finalize() {
        const sha1 = this;
        let b = sha1._buffer;
        const h = sha1._h;
        b = bitArray.concat(b, [
            bitArray.partial(1, 1)
        ]);
        for(let i = b.length + 2; i & 15; i++){
            b.push(0);
        }
        b.push(Math.floor(sha1._length / 0x100000000));
        b.push(sha1._length | 0);
        while(b.length){
            sha1._block(b.splice(0, 16));
        }
        sha1.reset();
        return h;
    }
    _f(t, b, c, d) {
        if (t <= 19) {
            return b & c | ~b & d;
        } else if (t <= 39) {
            return b ^ c ^ d;
        } else if (t <= 59) {
            return b & c | b & d | c & d;
        } else if (t <= 79) {
            return b ^ c ^ d;
        }
    }
    _S(n, x) {
        return x << n | x >>> 32 - n;
    }
    _block(words) {
        const sha1 = this;
        const h = sha1._h;
        const w = Array(80);
        for(let j = 0; j < 16; j++){
            w[j] = words[j];
        }
        let a = h[0];
        let b = h[1];
        let c = h[2];
        let d = h[3];
        let e = h[4];
        for(let t = 0; t <= 79; t++){
            if (t >= 16) {
                w[t] = sha1._S(1, w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]);
            }
            const tmp = sha1._S(5, a) + sha1._f(t, b, c, d) + e + w[t] + sha1._key[Math.floor(t / 20)] | 0;
            e = d;
            d = c;
            c = sha1._S(30, b);
            b = a;
            a = tmp;
        }
        h[0] = h[0] + a | 0;
        h[1] = h[1] + b | 0;
        h[2] = h[2] + c | 0;
        h[3] = h[3] + d | 0;
        h[4] = h[4] + e | 0;
    }
};
const cipher = {};
cipher.aes = class {
    constructor(key){
        const aes = this;
        aes._tables = [
            [
                [],
                [],
                [],
                [],
                []
            ],
            [
                [],
                [],
                [],
                [],
                []
            ]
        ];
        if (!aes._tables[0][0][0]) {
            aes._precompute();
        }
        const sbox = aes._tables[0][4];
        const decTable = aes._tables[1];
        const keyLen = key.length;
        let i, encKey, decKey, rcon = 1;
        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
            throw new Error("invalid aes key size");
        }
        aes._key = [
            encKey = key.slice(0),
            decKey = []
        ];
        for(i = keyLen; i < 4 * keyLen + 28; i++){
            let tmp = encKey[i - 1];
            if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
                tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
                if (i % keyLen === 0) {
                    tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
                    rcon = rcon << 1 ^ (rcon >> 7) * 283;
                }
            }
            encKey[i] = encKey[i - keyLen] ^ tmp;
        }
        for(let j = 0; i; j++, i--){
            const tmp = encKey[j & 3 ? i : i - 4];
            if (i <= 4 || j < 4) {
                decKey[j] = tmp;
            } else {
                decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
            }
        }
    }
    encrypt(data) {
        return this._crypt(data, 0);
    }
    decrypt(data) {
        return this._crypt(data, 1);
    }
    _precompute() {
        const encTable = this._tables[0];
        const decTable = this._tables[1];
        const sbox = encTable[4];
        const sboxInv = decTable[4];
        const d = [];
        const th = [];
        let xInv, x2, x4, x8;
        for(let i = 0; i < 256; i++){
            th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
        }
        for(let x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1){
            let s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
            s = s >> 8 ^ s & 255 ^ 99;
            sbox[x] = s;
            sboxInv[s] = x;
            x8 = d[x4 = d[x2 = d[x]]];
            let tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
            let tEnc = d[s] * 0x101 ^ s * 0x1010100;
            for(let i = 0; i < 4; i++){
                encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
                decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
            }
        }
        for(let i = 0; i < 5; i++){
            encTable[i] = encTable[i].slice(0);
            decTable[i] = decTable[i].slice(0);
        }
    }
    _crypt(input, dir) {
        if (input.length !== 4) {
            throw new Error("invalid aes block size");
        }
        const key = this._key[dir];
        const nInnerRounds = key.length / 4 - 2;
        const out = [
            0,
            0,
            0,
            0
        ];
        const table = this._tables[dir];
        const t0 = table[0];
        const t1 = table[1];
        const t2 = table[2];
        const t3 = table[3];
        const sbox = table[4];
        let a = input[0] ^ key[0];
        let b = input[dir ? 3 : 1] ^ key[1];
        let c = input[2] ^ key[2];
        let d = input[dir ? 1 : 3] ^ key[3];
        let kIndex = 4;
        let a2, b2, c2;
        for(let i = 0; i < nInnerRounds; i++){
            a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];
            b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
            c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
            d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
            kIndex += 4;
            a = a2;
            b = b2;
            c = c2;
        }
        for(let i = 0; i < 4; i++){
            out[dir ? 3 & -i : i] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
            a2 = a;
            a = b;
            b = c;
            c = d;
            d = a2;
        }
        return out;
    }
};
const random = {
    getRandomValues (typedArray) {
        const words = new Uint32Array(typedArray.buffer);
        const r = (m_w)=>{
            let m_z = 0x3ade68b1;
            const mask = 0xffffffff;
            return function() {
                m_z = 0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10) & mask;
                m_w = 0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10) & mask;
                const result = ((m_z << 0x10) + m_w & 0xffffffff) / 0x100000000 + .5;
                return result * (Math.random() > .5 ? 1 : -1);
            };
        };
        for(let i = 0, rcache; i < typedArray.length; i += 4){
            const _r = r((rcache || Math.random()) * 0x100000000);
            rcache = _r() * 0x3ade67b7;
            words[i / 4] = _r() * 0x100000000 | 0;
        }
        return typedArray;
    }
};
const mode = {};
mode.ctrGladman = class {
    constructor(prf, iv){
        this._prf = prf;
        this._initIv = iv;
        this._iv = iv;
    }
    reset() {
        this._iv = this._initIv;
    }
    update(data) {
        return this.calculate(this._prf, data, this._iv);
    }
    incWord(word) {
        if ((word >> 24 & 0xff) === 0xff) {
            let b1 = word >> 16 & 0xff;
            let b2 = word >> 8 & 0xff;
            let b3 = word & 0xff;
            if (b1 === 0xff) {
                b1 = 0;
                if (b2 === 0xff) {
                    b2 = 0;
                    if (b3 === 0xff) {
                        b3 = 0;
                    } else {
                        ++b3;
                    }
                } else {
                    ++b2;
                }
            } else {
                ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
        } else {
            word += 0x01 << 24;
        }
        return word;
    }
    incCounter(counter) {
        if ((counter[0] = this.incWord(counter[0])) === 0) {
            counter[1] = this.incWord(counter[1]);
        }
    }
    calculate(prf, data, iv) {
        let l;
        if (!(l = data.length)) {
            return [];
        }
        const bl = bitArray.bitLength(data);
        for(let i = 0; i < l; i += 4){
            this.incCounter(iv);
            const e = prf.encrypt(iv);
            data[i] ^= e[0];
            data[i + 1] ^= e[1];
            data[i + 2] ^= e[2];
            data[i + 3] ^= e[3];
        }
        return bitArray.clamp(data, bl);
    }
};
const misc = {
    importKey (password) {
        return new misc.hmacSha1(codec.bytes.toBits(password));
    },
    pbkdf2 (prf, salt, count, length) {
        count = count || 10000;
        if (length < 0 || count < 0) {
            throw new Error("invalid params to pbkdf2");
        }
        const byteLength = (length >> 5) + 1 << 2;
        let u, ui, i, j, k;
        const arrayBuffer = new ArrayBuffer(byteLength);
        const out = new DataView(arrayBuffer);
        let outLength = 0;
        const b = bitArray;
        salt = codec.bytes.toBits(salt);
        for(k = 1; outLength < (byteLength || 1); k++){
            u = ui = prf.encrypt(b.concat(salt, [
                k
            ]));
            for(i = 1; i < count; i++){
                ui = prf.encrypt(ui);
                for(j = 0; j < ui.length; j++){
                    u[j] ^= ui[j];
                }
            }
            for(i = 0; outLength < (byteLength || 1) && i < u.length; i++){
                out.setInt32(outLength, u[i]);
                outLength += 4;
            }
        }
        return arrayBuffer.slice(0, length / 8);
    }
};
misc.hmacSha1 = class {
    constructor(key){
        const hmac = this;
        const Hash = hmac._hash = hash.sha1;
        const exKey = [
            [],
            []
        ];
        hmac._baseHash = [
            new Hash(),
            new Hash()
        ];
        const bs = hmac._baseHash[0].blockSize / 32;
        if (key.length > bs) {
            key = new Hash().update(key).finalize();
        }
        for(let i = 0; i < bs; i++){
            exKey[0][i] = key[i] ^ 0x36363636;
            exKey[1][i] = key[i] ^ 0x5C5C5C5C;
        }
        hmac._baseHash[0].update(exKey[0]);
        hmac._baseHash[1].update(exKey[1]);
        hmac._resultHash = new Hash(hmac._baseHash[0]);
    }
    reset() {
        const hmac = this;
        hmac._resultHash = new hmac._hash(hmac._baseHash[0]);
        hmac._updated = false;
    }
    update(data) {
        const hmac = this;
        hmac._updated = true;
        hmac._resultHash.update(data);
    }
    digest() {
        const hmac = this;
        const w = hmac._resultHash.finalize();
        const result = new hmac._hash(hmac._baseHash[1]).update(w).finalize();
        hmac.reset();
        return result;
    }
    encrypt(data) {
        if (!this._updated) {
            this.update(data);
            return this.digest(data);
        } else {
            throw new Error("encrypt on already updated hmac called!");
        }
    }
};
const GET_RANDOM_VALUES_SUPPORTED = typeof crypto != "undefined" && typeof crypto.getRandomValues == "function";
const ERR_INVALID_PASSWORD = "Invalid password";
const ERR_INVALID_SIGNATURE = "Invalid signature";
const ERR_ABORT_CHECK_PASSWORD = "zipjs-abort-check-password";
function getRandomValues(array) {
    if (GET_RANDOM_VALUES_SUPPORTED) {
        return crypto.getRandomValues(array);
    } else {
        return random.getRandomValues(array);
    }
}
const BLOCK_LENGTH = 16;
const RAW_FORMAT = "raw";
const PBKDF2_ALGORITHM = {
    name: "PBKDF2"
};
const HASH_ALGORITHM = {
    name: "HMAC"
};
const HASH_FUNCTION = "SHA-1";
const BASE_KEY_ALGORITHM = Object.assign({
    hash: HASH_ALGORITHM
}, PBKDF2_ALGORITHM);
const DERIVED_BITS_ALGORITHM = Object.assign({
    iterations: 1000,
    hash: {
        name: HASH_FUNCTION
    }
}, PBKDF2_ALGORITHM);
const DERIVED_BITS_USAGE = [
    "deriveBits"
];
const SALT_LENGTH = [
    8,
    12,
    16
];
const KEY_LENGTH = [
    16,
    24,
    32
];
const SIGNATURE_LENGTH = 10;
const COUNTER_DEFAULT_VALUE = [
    0,
    0,
    0,
    0
];
const UNDEFINED_TYPE1 = "undefined";
const FUNCTION_TYPE1 = "function";
const CRYPTO_API_SUPPORTED = typeof crypto != UNDEFINED_TYPE1;
const subtle = CRYPTO_API_SUPPORTED && crypto.subtle;
const SUBTLE_API_SUPPORTED = CRYPTO_API_SUPPORTED && typeof subtle != UNDEFINED_TYPE1;
const codecBytes = codec.bytes;
const Aes = cipher.aes;
const CtrGladman = mode.ctrGladman;
const HmacSha1 = misc.hmacSha1;
let IMPORT_KEY_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.importKey == FUNCTION_TYPE1;
let DERIVE_BITS_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.deriveBits == FUNCTION_TYPE1;
class AESDecryptionStream extends TransformStream {
    constructor({ password, signed, encryptionStrength, checkPasswordOnly }){
        super({
            start () {
                Object.assign(this, {
                    ready: new Promise((resolve)=>this.resolveReady = resolve),
                    password,
                    signed,
                    strength: encryptionStrength - 1,
                    pending: new Uint8Array()
                });
            },
            async transform (chunk, controller) {
                const aesCrypto = this;
                const { password, strength, resolveReady, ready } = aesCrypto;
                if (password) {
                    await createDecryptionKeys(aesCrypto, strength, password, subarray(chunk, 0, SALT_LENGTH[strength] + 2));
                    chunk = subarray(chunk, SALT_LENGTH[strength] + 2);
                    if (checkPasswordOnly) {
                        controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
                    } else {
                        resolveReady();
                    }
                } else {
                    await ready;
                }
                const output = new Uint8Array(chunk.length - 10 - (chunk.length - 10) % 16);
                controller.enqueue(append(aesCrypto, chunk, output, 0, 10, true));
            },
            async flush (controller) {
                const { signed, ctr, hmac, pending, ready } = this;
                await ready;
                const chunkToDecrypt = subarray(pending, 0, pending.length - 10);
                const originalSignature = subarray(pending, pending.length - 10);
                let decryptedChunkArray = new Uint8Array();
                if (chunkToDecrypt.length) {
                    const encryptedChunk = toBits(codecBytes, chunkToDecrypt);
                    hmac.update(encryptedChunk);
                    const decryptedChunk = ctr.update(encryptedChunk);
                    decryptedChunkArray = fromBits(codecBytes, decryptedChunk);
                }
                if (signed) {
                    const signature = subarray(fromBits(codecBytes, hmac.digest()), 0, 10);
                    for(let indexSignature = 0; indexSignature < 10; indexSignature++){
                        if (signature[indexSignature] != originalSignature[indexSignature]) {
                            throw new Error(ERR_INVALID_SIGNATURE);
                        }
                    }
                }
                controller.enqueue(decryptedChunkArray);
            }
        });
    }
}
class AESEncryptionStream extends TransformStream {
    constructor({ password, encryptionStrength }){
        let stream;
        super({
            start () {
                Object.assign(this, {
                    ready: new Promise((resolve)=>this.resolveReady = resolve),
                    password,
                    strength: encryptionStrength - 1,
                    pending: new Uint8Array()
                });
            },
            async transform (chunk, controller) {
                const aesCrypto = this;
                const { password, strength, resolveReady, ready } = aesCrypto;
                let preamble = new Uint8Array();
                if (password) {
                    preamble = await createEncryptionKeys(aesCrypto, strength, password);
                    resolveReady();
                } else {
                    await ready;
                }
                const output = new Uint8Array(preamble.length + chunk.length - chunk.length % 16);
                output.set(preamble, 0);
                controller.enqueue(append(aesCrypto, chunk, output, preamble.length, 0));
            },
            async flush (controller) {
                const { ctr, hmac, pending, ready } = this;
                await ready;
                let encryptedChunkArray = new Uint8Array();
                if (pending.length) {
                    const encryptedChunk = ctr.update(toBits(codecBytes, pending));
                    hmac.update(encryptedChunk);
                    encryptedChunkArray = fromBits(codecBytes, encryptedChunk);
                }
                stream.signature = fromBits(codecBytes, hmac.digest()).slice(0, SIGNATURE_LENGTH);
                controller.enqueue(concat(encryptedChunkArray, stream.signature));
            }
        });
        stream = this;
    }
}
function append(aesCrypto, input, output, paddingStart, paddingEnd, verifySignature) {
    const { ctr, hmac, pending } = aesCrypto;
    const inputLength = input.length - paddingEnd;
    if (pending.length) {
        input = concat(pending, input);
        output = expand(output, inputLength - inputLength % BLOCK_LENGTH);
    }
    let offset;
    for(offset = 0; offset <= inputLength - 16; offset += BLOCK_LENGTH){
        const inputChunk = toBits(codecBytes, subarray(input, offset, offset + 16));
        if (verifySignature) {
            hmac.update(inputChunk);
        }
        const outputChunk = ctr.update(inputChunk);
        if (!verifySignature) {
            hmac.update(outputChunk);
        }
        output.set(fromBits(codecBytes, outputChunk), offset + paddingStart);
    }
    aesCrypto.pending = subarray(input, offset);
    return output;
}
async function createDecryptionKeys(decrypt, strength, password, preamble) {
    const passwordVerificationKey = await createKeys(decrypt, strength, password, subarray(preamble, 0, SALT_LENGTH[strength]));
    const passwordVerification = subarray(preamble, SALT_LENGTH[strength]);
    if (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {
        throw new Error(ERR_INVALID_PASSWORD);
    }
}
async function createEncryptionKeys(encrypt, strength, password) {
    const salt = getRandomValues(new Uint8Array(SALT_LENGTH[strength]));
    const passwordVerification = await createKeys(encrypt, strength, password, salt);
    return concat(salt, passwordVerification);
}
async function createKeys(aesCrypto, strength, password, salt) {
    aesCrypto.password = null;
    const encodedPassword = encodeText(password);
    const baseKey = await importKey(RAW_FORMAT, encodedPassword, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);
    const derivedBits = await deriveBits(Object.assign({
        salt
    }, DERIVED_BITS_ALGORITHM), baseKey, 8 * (KEY_LENGTH[strength] * 2 + 2));
    const compositeKey = new Uint8Array(derivedBits);
    const key = toBits(codecBytes, subarray(compositeKey, 0, KEY_LENGTH[strength]));
    const authentication = toBits(codecBytes, subarray(compositeKey, KEY_LENGTH[strength], KEY_LENGTH[strength] * 2));
    const passwordVerification = subarray(compositeKey, KEY_LENGTH[strength] * 2);
    Object.assign(aesCrypto, {
        keys: {
            key,
            authentication,
            passwordVerification
        },
        ctr: new CtrGladman(new Aes(key), Array.from(COUNTER_DEFAULT_VALUE)),
        hmac: new HmacSha1(authentication)
    });
    return passwordVerification;
}
async function importKey(format, password, algorithm, extractable, keyUsages) {
    if (IMPORT_KEY_SUPPORTED) {
        try {
            return await subtle.importKey(format, password, algorithm, extractable, keyUsages);
        } catch (_error) {
            IMPORT_KEY_SUPPORTED = false;
            return misc.importKey(password);
        }
    } else {
        return misc.importKey(password);
    }
}
async function deriveBits(algorithm, baseKey, length) {
    if (DERIVE_BITS_SUPPORTED) {
        try {
            return await subtle.deriveBits(algorithm, baseKey, length);
        } catch (_error) {
            DERIVE_BITS_SUPPORTED = false;
            return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
        }
    } else {
        return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
    }
}
function concat(leftArray, rightArray) {
    let array = leftArray;
    if (leftArray.length + rightArray.length) {
        array = new Uint8Array(leftArray.length + rightArray.length);
        array.set(leftArray, 0);
        array.set(rightArray, leftArray.length);
    }
    return array;
}
function expand(inputArray, length) {
    if (length && length > inputArray.length) {
        const array = inputArray;
        inputArray = new Uint8Array(length);
        inputArray.set(array, 0);
    }
    return inputArray;
}
function subarray(array, begin, end) {
    return array.subarray(begin, end);
}
function fromBits(codecBytes, chunk) {
    return codecBytes.fromBits(chunk);
}
function toBits(codecBytes, chunk) {
    return codecBytes.toBits(chunk);
}
const HEADER_LENGTH = 12;
class ZipCryptoDecryptionStream extends TransformStream {
    constructor({ password, passwordVerification, checkPasswordOnly }){
        super({
            start () {
                Object.assign(this, {
                    password,
                    passwordVerification
                });
                createKeys1(this, password);
            },
            transform (chunk, controller) {
                const zipCrypto = this;
                if (zipCrypto.password) {
                    const decryptedHeader = decrypt(zipCrypto, chunk.subarray(0, 12));
                    zipCrypto.password = null;
                    if (decryptedHeader[12 - 1] != zipCrypto.passwordVerification) {
                        throw new Error(ERR_INVALID_PASSWORD);
                    }
                    chunk = chunk.subarray(HEADER_LENGTH);
                }
                if (checkPasswordOnly) {
                    controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
                } else {
                    controller.enqueue(decrypt(zipCrypto, chunk));
                }
            }
        });
    }
}
class ZipCryptoEncryptionStream extends TransformStream {
    constructor({ password, passwordVerification }){
        super({
            start () {
                Object.assign(this, {
                    password,
                    passwordVerification
                });
                createKeys1(this, password);
            },
            transform (chunk, controller) {
                const zipCrypto = this;
                let output;
                let offset;
                if (zipCrypto.password) {
                    zipCrypto.password = null;
                    const header = getRandomValues(new Uint8Array(12));
                    header[HEADER_LENGTH - 1] = zipCrypto.passwordVerification;
                    output = new Uint8Array(chunk.length + header.length);
                    output.set(encrypt(zipCrypto, header), 0);
                    offset = HEADER_LENGTH;
                } else {
                    output = new Uint8Array(chunk.length);
                    offset = 0;
                }
                output.set(encrypt(zipCrypto, chunk), offset);
                controller.enqueue(output);
            }
        });
    }
}
function decrypt(target, input) {
    const output = new Uint8Array(input.length);
    for(let index = 0; index < input.length; index++){
        output[index] = getByte(target) ^ input[index];
        updateKeys(target, output[index]);
    }
    return output;
}
function encrypt(target, input) {
    const output = new Uint8Array(input.length);
    for(let index = 0; index < input.length; index++){
        output[index] = getByte(target) ^ input[index];
        updateKeys(target, input[index]);
    }
    return output;
}
function createKeys1(target, password) {
    const keys = [
        0x12345678,
        0x23456789,
        0x34567890
    ];
    Object.assign(target, {
        keys,
        crcKey0: new Crc32(keys[0]),
        crcKey2: new Crc32(keys[2])
    });
    for(let index = 0; index < password.length; index++){
        updateKeys(target, password.charCodeAt(index));
    }
}
function updateKeys(target, __byte) {
    let [key0, key1, key2] = target.keys;
    target.crcKey0.append([
        __byte
    ]);
    key0 = ~target.crcKey0.get();
    key1 = getInt32(Math.imul(getInt32(key1 + getInt8(key0)), 134775813) + 1);
    target.crcKey2.append([
        key1 >>> 24
    ]);
    key2 = ~target.crcKey2.get();
    target.keys = [
        key0,
        key1,
        key2
    ];
}
function getByte(target) {
    const temp = target.keys[2] | 2;
    return getInt8(Math.imul(temp, temp ^ 1) >>> 8);
}
function getInt8(number) {
    return number & 0xFF;
}
function getInt32(number) {
    return number & 0xFFFFFFFF;
}
const COMPRESSION_FORMAT = "deflate-raw";
class DeflateStream extends TransformStream {
    constructor(options, { chunkSize, CompressionStream: CompressionStream1, CompressionStreamNative }){
        super({});
        const { compressed, encrypted, useCompressionStream, zipCrypto, signed, level } = options;
        const stream = this;
        let crc32Stream, encryptionStream;
        let readable = filterEmptyChunks(super.readable);
        if ((!encrypted || zipCrypto) && signed) {
            crc32Stream = new Crc32Stream();
            readable = pipeThrough(readable, crc32Stream);
        }
        if (compressed) {
            readable = pipeThroughCommpressionStream(readable, useCompressionStream, {
                level,
                chunkSize
            }, CompressionStreamNative, CompressionStream1);
        }
        if (encrypted) {
            if (zipCrypto) {
                readable = pipeThrough(readable, new ZipCryptoEncryptionStream(options));
            } else {
                encryptionStream = new AESEncryptionStream(options);
                readable = pipeThrough(readable, encryptionStream);
            }
        }
        setReadable(stream, readable, async ()=>{
            let signature;
            if (encrypted && !zipCrypto) {
                signature = encryptionStream.signature;
            }
            if ((!encrypted || zipCrypto) && signed) {
                signature = new DataView(crc32Stream.value.buffer).getUint32(0);
            }
            stream.signature = signature;
        });
    }
}
class InflateStream extends TransformStream {
    constructor(options, { chunkSize, DecompressionStream: DecompressionStream1, DecompressionStreamNative }){
        super({});
        const { zipCrypto, encrypted, signed, signature, compressed, useCompressionStream } = options;
        let crc32Stream, decryptionStream;
        let readable = filterEmptyChunks(super.readable);
        if (encrypted) {
            if (zipCrypto) {
                readable = pipeThrough(readable, new ZipCryptoDecryptionStream(options));
            } else {
                decryptionStream = new AESDecryptionStream(options);
                readable = pipeThrough(readable, decryptionStream);
            }
        }
        if (compressed) {
            readable = pipeThroughCommpressionStream(readable, useCompressionStream, {
                chunkSize
            }, DecompressionStreamNative, DecompressionStream1);
        }
        if ((!encrypted || zipCrypto) && signed) {
            crc32Stream = new Crc32Stream();
            readable = pipeThrough(readable, crc32Stream);
        }
        setReadable(this, readable, async ()=>{
            if ((!encrypted || zipCrypto) && signed) {
                const dataViewSignature = new DataView(crc32Stream.value.buffer);
                if (signature != dataViewSignature.getUint32(0, false)) {
                    throw new Error(ERR_INVALID_SIGNATURE);
                }
            }
        });
    }
}
function filterEmptyChunks(readable) {
    return pipeThrough(readable, new TransformStream({
        transform (chunk, controller) {
            if (chunk && chunk.length) {
                controller.enqueue(chunk);
            }
        }
    }));
}
function setReadable(stream, readable, flush) {
    readable = pipeThrough(readable, new TransformStream({
        flush
    }));
    Object.defineProperty(stream, "readable", {
        get () {
            return readable;
        }
    });
}
function pipeThroughCommpressionStream(readable, useCompressionStream, options, CodecStreamNative, CodecStream) {
    try {
        const CompressionStream1 = useCompressionStream && CodecStreamNative ? CodecStreamNative : CodecStream;
        readable = pipeThrough(readable, new CompressionStream1(COMPRESSION_FORMAT, options));
    } catch (error) {
        if (useCompressionStream) {
            readable = pipeThrough(readable, new CodecStream(COMPRESSION_FORMAT, options));
        } else {
            throw error;
        }
    }
    return readable;
}
function pipeThrough(readable, transformStream) {
    return readable.pipeThrough(transformStream);
}
const MESSAGE_EVENT_TYPE = "message";
const MESSAGE_START = "start";
const MESSAGE_PULL = "pull";
const MESSAGE_DATA = "data";
const MESSAGE_ACK_DATA = "ack";
const MESSAGE_CLOSE = "close";
const CODEC_DEFLATE = "deflate";
const CODEC_INFLATE = "inflate";
class CodecStream extends TransformStream {
    constructor(options, config){
        super({});
        const codec = this;
        const { codecType } = options;
        let Stream;
        if (codecType.startsWith(CODEC_DEFLATE)) {
            Stream = DeflateStream;
        } else if (codecType.startsWith(CODEC_INFLATE)) {
            Stream = InflateStream;
        }
        let size = 0;
        const stream = new Stream(options, config);
        const readable = super.readable;
        const transformStream = new TransformStream({
            transform (chunk, controller) {
                if (chunk && chunk.length) {
                    size += chunk.length;
                    controller.enqueue(chunk);
                }
            },
            flush () {
                const { signature } = stream;
                Object.assign(codec, {
                    signature,
                    size
                });
            }
        });
        Object.defineProperty(codec, "readable", {
            get () {
                return readable.pipeThrough(stream).pipeThrough(transformStream);
            }
        });
    }
}
const WEB_WORKERS_SUPPORTED = typeof Worker != UNDEFINED_TYPE;
class CodecWorker {
    constructor(workerData, { readable, writable }, { options, config, streamOptions, useWebWorkers, transferStreams, scripts }, onTaskFinished){
        const { signal } = streamOptions;
        Object.assign(workerData, {
            busy: true,
            readable: readable.pipeThrough(new ProgressWatcherStream(readable, streamOptions, config), {
                signal
            }),
            writable,
            options: Object.assign({}, options),
            scripts,
            transferStreams,
            terminate () {
                const { worker, busy } = workerData;
                if (worker && !busy) {
                    worker.terminate();
                    workerData.interface = null;
                }
            },
            onTaskFinished () {
                workerData.busy = false;
                onTaskFinished(workerData);
            }
        });
        return (useWebWorkers && WEB_WORKERS_SUPPORTED ? createWebWorkerInterface : createWorkerInterface)(workerData, config);
    }
}
class ProgressWatcherStream extends TransformStream {
    constructor(readableSource, { onstart, onprogress, size, onend }, { chunkSize }){
        let chunkOffset = 0;
        super({
            start () {
                if (onstart) {
                    callHandler(onstart, size);
                }
            },
            async transform (chunk, controller) {
                chunkOffset += chunk.length;
                if (onprogress) {
                    await callHandler(onprogress, chunkOffset, size);
                }
                controller.enqueue(chunk);
            },
            flush () {
                readableSource.size = chunkOffset;
                if (onend) {
                    callHandler(onend, chunkOffset);
                }
            }
        }, {
            highWaterMark: 1,
            size: ()=>chunkSize
        });
    }
}
async function callHandler(handler, ...parameters) {
    try {
        await handler(...parameters);
    } catch (_error) {}
}
function createWorkerInterface(workerData, config) {
    return {
        run: ()=>runWorker(workerData, config)
    };
}
function createWebWorkerInterface(workerData, { baseURL, chunkSize }) {
    if (!workerData.interface) {
        Object.assign(workerData, {
            worker: getWebWorker(workerData.scripts[0], baseURL, workerData),
            interface: {
                run: ()=>runWebWorker(workerData, {
                        chunkSize
                    })
            }
        });
    }
    return workerData.interface;
}
async function runWorker({ options, readable, writable, onTaskFinished }, config) {
    const codecStream = new CodecStream(options, config);
    try {
        await readable.pipeThrough(codecStream).pipeTo(writable, {
            preventClose: true,
            preventAbort: true
        });
        const { signature, size } = codecStream;
        return {
            signature,
            size
        };
    } finally{
        onTaskFinished();
    }
}
async function runWebWorker(workerData, config) {
    let resolveResult, rejectResult;
    const result = new Promise((resolve, reject)=>{
        resolveResult = resolve;
        rejectResult = reject;
    });
    Object.assign(workerData, {
        reader: null,
        writer: null,
        resolveResult,
        rejectResult,
        result
    });
    const { readable, options, scripts } = workerData;
    const { writable, closed } = watchClosedStream(workerData.writable);
    const streamsTransferred = sendMessage({
        type: MESSAGE_START,
        scripts: scripts.slice(1),
        options,
        config,
        readable,
        writable
    }, workerData);
    if (!streamsTransferred) {
        Object.assign(workerData, {
            reader: readable.getReader(),
            writer: writable.getWriter()
        });
    }
    const resultValue = await result;
    try {
        await writable.getWriter().close();
    } catch (_error) {}
    await closed;
    return resultValue;
}
function watchClosedStream(writableSource) {
    const writer = writableSource.getWriter();
    let resolveStreamClosed;
    const closed = new Promise((resolve)=>resolveStreamClosed = resolve);
    const writable = new WritableStream({
        async write (chunk) {
            await writer.ready;
            await writer.write(chunk);
        },
        close () {
            writer.releaseLock();
            resolveStreamClosed();
        },
        abort (reason) {
            return writer.abort(reason);
        }
    });
    return {
        writable,
        closed
    };
}
let classicWorkersSupported = true;
let transferStreamsSupported = true;
function getWebWorker(url, baseURL, workerData) {
    const workerOptions = {
        type: "module"
    };
    let scriptUrl, worker;
    if (typeof url == FUNCTION_TYPE) {
        url = url();
    }
    try {
        scriptUrl = new URL(url, baseURL);
    } catch (_error) {
        scriptUrl = url;
    }
    if (classicWorkersSupported) {
        try {
            worker = new Worker(scriptUrl);
        } catch (_error) {
            classicWorkersSupported = false;
            worker = new Worker(scriptUrl, workerOptions);
        }
    } else {
        worker = new Worker(scriptUrl, workerOptions);
    }
    worker.addEventListener(MESSAGE_EVENT_TYPE, (event)=>onMessage(event, workerData));
    return worker;
}
function sendMessage(message, { worker, writer, onTaskFinished, transferStreams }) {
    try {
        let { value: value1, readable, writable } = message;
        const transferables = [];
        if (value1) {
            message.value = value1.buffer;
            transferables.push(message.value);
        }
        if (transferStreams && transferStreamsSupported) {
            if (readable) {
                transferables.push(readable);
            }
            if (writable) {
                transferables.push(writable);
            }
        } else {
            message.readable = message.writable = null;
        }
        if (transferables.length) {
            try {
                worker.postMessage(message, transferables);
                return true;
            } catch (_error) {
                transferStreamsSupported = false;
                message.readable = message.writable = null;
                worker.postMessage(message);
            }
        } else {
            worker.postMessage(message);
        }
    } catch (error) {
        if (writer) {
            writer.releaseLock();
        }
        onTaskFinished();
        throw error;
    }
}
async function onMessage({ data }, workerData) {
    const { type, value: value1, messageId, result, error } = data;
    const { reader, writer, resolveResult, rejectResult, onTaskFinished } = workerData;
    try {
        if (error) {
            const { message, stack, code, name } = error;
            const responseError = new Error(message);
            Object.assign(responseError, {
                stack,
                code,
                name
            });
            close(responseError);
        } else {
            if (type == MESSAGE_PULL) {
                const { value: value1, done } = await reader.read();
                sendMessage({
                    type: MESSAGE_DATA,
                    value: value1,
                    done,
                    messageId
                }, workerData);
            }
            if (type == MESSAGE_DATA) {
                await writer.ready;
                await writer.write(new Uint8Array(value1));
                sendMessage({
                    type: MESSAGE_ACK_DATA,
                    messageId
                }, workerData);
            }
            if (type == MESSAGE_CLOSE) {
                close(null, result);
            }
        }
    } catch (error) {
        close(error);
    }
    function close(error, result) {
        if (error) {
            rejectResult(error);
        } else {
            resolveResult(result);
        }
        if (writer) {
            writer.releaseLock();
        }
        onTaskFinished();
    }
}
let pool = [];
const pendingRequests = [];
let indexWorker = 0;
async function runWorker1(stream, workerOptions) {
    const { options, config } = workerOptions;
    const { transferStreams, useWebWorkers, useCompressionStream, codecType, compressed, signed, encrypted } = options;
    const { workerScripts, maxWorkers, terminateWorkerTimeout } = config;
    workerOptions.transferStreams = transferStreams || transferStreams === UNDEFINED_VALUE;
    const streamCopy = !compressed && !signed && !encrypted && !workerOptions.transferStreams;
    workerOptions.useWebWorkers = !streamCopy && (useWebWorkers || useWebWorkers === UNDEFINED_VALUE && config.useWebWorkers);
    workerOptions.scripts = workerOptions.useWebWorkers && workerScripts ? workerScripts[codecType] : [];
    options.useCompressionStream = useCompressionStream || useCompressionStream === UNDEFINED_VALUE && config.useCompressionStream;
    let worker;
    const workerData = pool.find((workerData)=>!workerData.busy);
    if (workerData) {
        clearTerminateTimeout(workerData);
        worker = new CodecWorker(workerData, stream, workerOptions, onTaskFinished);
    } else if (pool.length < maxWorkers) {
        const workerData = {
            indexWorker
        };
        indexWorker++;
        pool.push(workerData);
        worker = new CodecWorker(workerData, stream, workerOptions, onTaskFinished);
    } else {
        worker = await new Promise((resolve)=>pendingRequests.push({
                resolve,
                stream,
                workerOptions
            }));
    }
    return worker.run();
    function onTaskFinished(workerData) {
        if (pendingRequests.length) {
            const [{ resolve, stream, workerOptions }] = pendingRequests.splice(0, 1);
            resolve(new CodecWorker(workerData, stream, workerOptions, onTaskFinished));
        } else if (workerData.worker) {
            clearTerminateTimeout(workerData);
            if (Number.isFinite(terminateWorkerTimeout) && terminateWorkerTimeout >= 0) {
                workerData.terminateTimeout = setTimeout(()=>{
                    pool = pool.filter((data)=>data != workerData);
                    workerData.terminate();
                }, terminateWorkerTimeout);
            }
        } else {
            pool = pool.filter((data)=>data != workerData);
        }
    }
}
function clearTerminateTimeout(workerData) {
    const { terminateTimeout } = workerData;
    if (terminateTimeout) {
        clearTimeout(terminateTimeout);
        workerData.terminateTimeout = null;
    }
}
function e(e) {
    const t = ()=>URL.createObjectURL(new Blob([
            'const{Array:e,Object:t,Number:n,Math:r,Error:s,Uint8Array:i,Uint16Array:o,Uint32Array:c,Int32Array:f,Map:a,DataView:l,Promise:u,TextEncoder:w,crypto:h,postMessage:d,TransformStream:p,ReadableStream:y,WritableStream:m,CompressionStream:b,DecompressionStream:g}=self;class k{constructor(e){return class extends p{constructor(t,n){const r=new e(n);super({transform(e,t){t.enqueue(r.append(e))},flush(e){const t=r.flush();t&&e.enqueue(t)}})}}}}const v=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;v[e]=t}class S{constructor(e){this.t=e||-1}append(e){let t=0|this.t;for(let n=0,r=0|e.length;r>n;n++)t=t>>>8^v[255&(t^e[n])];this.t=t}get(){return~this.t}}class z extends p{constructor(){let e;const t=new S;super({transform(e,n){t.append(e),n.enqueue(e)},flush(){const n=new i(4);new l(n.buffer).setUint32(0,t.get()),e.value=n}}),e=this}}const C={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const n=e[e.length-1],r=C.i(n);return 32===r?e.concat(t):C.o(t,r,0|n,e.slice(0,e.length-1))},l(e){const t=e.length;if(0===t)return 0;const n=e[t-1];return 32*(t-1)+C.i(n)},u(e,t){if(32*e.length<t)return e;const n=(e=e.slice(0,r.ceil(t/32))).length;return t&=31,n>0&&t&&(e[n-1]=C.h(t,e[n-1]&2147483648>>t-1,1)),e},h:(e,t,n)=>32===e?t:(n?0|t:t<<32-e)+1099511627776*e,i:e=>r.round(e/1099511627776)||32,o(e,t,n,r){for(void 0===r&&(r=[]);t>=32;t-=32)r.push(n),n=0;if(0===t)return r.concat(e);for(let s=0;s<e.length;s++)r.push(n|e[s]>>>t),n=e[s]<<32-t;const s=e.length?e[e.length-1]:0,i=C.i(s);return r.push(C.h(t+i&31,t+i>32?n:r.pop(),1)),r}},x={p:{m(e){const t=C.l(e)/8,n=new i(t);let r;for(let s=0;t>s;s++)0==(3&s)&&(r=e[s/4]),n[s]=r>>>24,r<<=8;return n},g(e){const t=[];let n,r=0;for(n=0;n<e.length;n++)r=r<<8|e[n],3==(3&n)&&(t.push(r),r=0);return 3&n&&t.push(C.h(8*(3&n),r)),t}}},_=class{constructor(e){const t=this;t.blockSize=512,t.k=[1732584193,4023233417,2562383102,271733878,3285377520],t.v=[1518500249,1859775393,2400959708,3395469782],e?(t.S=e.S.slice(0),t.C=e.C.slice(0),t._=e._):t.reset()}reset(){const e=this;return e.S=e.k.slice(0),e.C=[],e._=0,e}update(e){const t=this;"string"==typeof e&&(e=x.A.g(e));const n=t.C=C.concat(t.C,e),r=t._,i=t._=r+C.l(e);if(i>9007199254740991)throw new s("Cannot hash more than 2^53 - 1 bits");const o=new c(n);let f=0;for(let e=t.blockSize+r-(t.blockSize+r&t.blockSize-1);i>=e;e+=t.blockSize)t.I(o.subarray(16*f,16*(f+1))),f+=1;return n.splice(0,16*f),t}D(){const e=this;let t=e.C;const n=e.S;t=C.concat(t,[C.h(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(r.floor(e._/4294967296)),t.push(0|e._);t.length;)e.I(t.splice(0,16));return e.reset(),n}V(e,t,n,r){return e>19?e>39?e>59?e>79?void 0:t^n^r:t&n|t&r|n&r:t^n^r:t&n|~t&r}P(e,t){return t<<e|t>>>32-e}I(t){const n=this,s=n.S,i=e(80);for(let e=0;16>e;e++)i[e]=t[e];let o=s[0],c=s[1],f=s[2],a=s[3],l=s[4];for(let e=0;79>=e;e++){16>e||(i[e]=n.P(1,i[e-3]^i[e-8]^i[e-14]^i[e-16]));const t=n.P(5,o)+n.V(e,c,f,a)+l+i[e]+n.v[r.floor(e/20)]|0;l=a,a=f,f=n.P(30,c),c=o,o=t}s[0]=s[0]+o|0,s[1]=s[1]+c|0,s[2]=s[2]+f|0,s[3]=s[3]+a|0,s[4]=s[4]+l|0}},A={getRandomValues(e){const t=new c(e.buffer),n=e=>{let t=987654321;const n=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&n,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&n)&n)/4294967296+.5)*(r.random()>.5?1:-1))};for(let s,i=0;i<e.length;i+=4){const e=n(4294967296*(s||r.random()));s=987654071*e(),t[i/4]=4294967296*e()|0}return e}},I={importKey:e=>new I.R(x.p.g(e)),B(e,t,n,r){if(n=n||1e4,0>r||0>n)throw new s("invalid params to pbkdf2");const i=1+(r>>5)<<2;let o,c,f,a,u;const w=new ArrayBuffer(i),h=new l(w);let d=0;const p=C;for(t=x.p.g(t),u=1;(i||1)>d;u++){for(o=c=e.encrypt(p.concat(t,[u])),f=1;n>f;f++)for(c=e.encrypt(c),a=0;a<c.length;a++)o[a]^=c[a];for(f=0;(i||1)>d&&f<o.length;f++)h.setInt32(d,o[f]),d+=4}return w.slice(0,r/8)},R:class{constructor(e){const t=this,n=t.M=_,r=[[],[]];t.K=[new n,new n];const s=t.K[0].blockSize/32;e.length>s&&(e=(new n).update(e).D());for(let t=0;s>t;t++)r[0][t]=909522486^e[t],r[1][t]=1549556828^e[t];t.K[0].update(r[0]),t.K[1].update(r[1]),t.U=new n(t.K[0])}reset(){const e=this;e.U=new e.M(e.K[0]),e.N=!1}update(e){this.N=!0,this.U.update(e)}digest(){const e=this,t=e.U.D(),n=new e.M(e.K[1]).update(t).D();return e.reset(),n}encrypt(e){if(this.N)throw new s("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},D=void 0!==h&&"function"==typeof h.getRandomValues,V="Invalid password",P="Invalid signature",R="zipjs-abort-check-password";function B(e){return D?h.getRandomValues(e):A.getRandomValues(e)}const E=16,M={name:"PBKDF2"},K=t.assign({hash:{name:"HMAC"}},M),U=t.assign({iterations:1e3,hash:{name:"SHA-1"}},M),N=["deriveBits"],O=[8,12,16],T=[16,24,32],W=10,j=[0,0,0,0],H="undefined",L="function",F=typeof h!=H,q=F&&h.subtle,G=F&&typeof q!=H,J=x.p,Q=class{constructor(e){const t=this;t.O=[[[],[],[],[],[]],[[],[],[],[],[]]],t.O[0][0][0]||t.T();const n=t.O[0][4],r=t.O[1],i=e.length;let o,c,f,a=1;if(4!==i&&6!==i&&8!==i)throw new s("invalid aes key size");for(t.v=[c=e.slice(0),f=[]],o=i;4*i+28>o;o++){let e=c[o-1];(o%i==0||8===i&&o%i==4)&&(e=n[e>>>24]<<24^n[e>>16&255]<<16^n[e>>8&255]<<8^n[255&e],o%i==0&&(e=e<<8^e>>>24^a<<24,a=a<<1^283*(a>>7))),c[o]=c[o-i]^e}for(let e=0;o;e++,o--){const t=c[3&e?o:o-4];f[e]=4>=o||4>e?t:r[0][n[t>>>24]]^r[1][n[t>>16&255]]^r[2][n[t>>8&255]]^r[3][n[255&t]]}}encrypt(e){return this.W(e,0)}decrypt(e){return this.W(e,1)}T(){const e=this.O[0],t=this.O[1],n=e[4],r=t[4],s=[],i=[];let o,c,f,a;for(let e=0;256>e;e++)i[(s[e]=e<<1^283*(e>>7))^e]=e;for(let l=o=0;!n[l];l^=c||1,o=i[o]||1){let i=o^o<<1^o<<2^o<<3^o<<4;i=i>>8^255&i^99,n[l]=i,r[i]=l,a=s[f=s[c=s[l]]];let u=16843009*a^65537*f^257*c^16843008*l,w=257*s[i]^16843008*i;for(let n=0;4>n;n++)e[n][l]=w=w<<24^w>>>8,t[n][i]=u=u<<24^u>>>8}for(let n=0;5>n;n++)e[n]=e[n].slice(0),t[n]=t[n].slice(0)}W(e,t){if(4!==e.length)throw new s("invalid aes block size");const n=this.v[t],r=n.length/4-2,i=[0,0,0,0],o=this.O[t],c=o[0],f=o[1],a=o[2],l=o[3],u=o[4];let w,h,d,p=e[0]^n[0],y=e[t?3:1]^n[1],m=e[2]^n[2],b=e[t?1:3]^n[3],g=4;for(let e=0;r>e;e++)w=c[p>>>24]^f[y>>16&255]^a[m>>8&255]^l[255&b]^n[g],h=c[y>>>24]^f[m>>16&255]^a[b>>8&255]^l[255&p]^n[g+1],d=c[m>>>24]^f[b>>16&255]^a[p>>8&255]^l[255&y]^n[g+2],b=c[b>>>24]^f[p>>16&255]^a[y>>8&255]^l[255&m]^n[g+3],g+=4,p=w,y=h,m=d;for(let e=0;4>e;e++)i[t?3&-e:e]=u[p>>>24]<<24^u[y>>16&255]<<16^u[m>>8&255]<<8^u[255&b]^n[g++],w=p,p=y,y=m,m=b,b=w;return i}},X=class{constructor(e,t){this.j=e,this.H=t,this.L=t}reset(){this.L=this.H}update(e){return this.F(this.j,e,this.L)}q(e){if(255==(e>>24&255)){let t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}else e+=1<<24;return e}G(e){0===(e[0]=this.q(e[0]))&&(e[1]=this.q(e[1]))}F(e,t,n){let r;if(!(r=t.length))return[];const s=C.l(t);for(let s=0;r>s;s+=4){this.G(n);const r=e.encrypt(n);t[s]^=r[0],t[s+1]^=r[1],t[s+2]^=r[2],t[s+3]^=r[3]}return C.u(t,s)}},Y=I.R;let Z=F&&G&&typeof q.importKey==L,$=F&&G&&typeof q.deriveBits==L;class ee extends p{constructor({password:e,signed:n,encryptionStrength:r,checkPasswordOnly:o}){super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:e,signed:n,X:r-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:c,J:f,ready:a}=n;r?(await(async(e,t,n,r)=>{const i=await re(e,t,n,ie(r,0,O[t])),o=ie(r,O[t]);if(i[0]!=o[0]||i[1]!=o[1])throw new s(V)})(n,c,r,ie(e,0,O[c]+2)),e=ie(e,O[c]+2),o?t.error(new s(R)):f()):await a;const l=new i(e.length-W-(e.length-W)%E);t.enqueue(ne(n,e,l,0,W,!0))},async flush(e){const{signed:t,Y:n,Z:r,pending:o,ready:c}=this;await c;const f=ie(o,0,o.length-W),a=ie(o,o.length-W);let l=new i;if(f.length){const e=ce(J,f);r.update(e);const t=n.update(e);l=oe(J,t)}if(t){const e=ie(oe(J,r.digest()),0,W);for(let t=0;W>t;t++)if(e[t]!=a[t])throw new s(P)}e.enqueue(l)}})}}class te extends p{constructor({password:e,encryptionStrength:n}){let r;super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:e,X:n-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:s,J:o,ready:c}=n;let f=new i;r?(f=await(async(e,t,n)=>{const r=B(new i(O[t]));return se(r,await re(e,t,n,r))})(n,s,r),o()):await c;const a=new i(f.length+e.length-e.length%E);a.set(f,0),t.enqueue(ne(n,e,a,f.length,0))},async flush(e){const{Y:t,Z:n,pending:s,ready:o}=this;await o;let c=new i;if(s.length){const e=t.update(ce(J,s));n.update(e),c=oe(J,e)}r.signature=oe(J,n.digest()).slice(0,W),e.enqueue(se(c,r.signature))}}),r=this}}function ne(e,t,n,r,s,o){const{Y:c,Z:f,pending:a}=e,l=t.length-s;let u;for(a.length&&(t=se(a,t),n=((e,t)=>{if(t&&t>e.length){const n=e;(e=new i(t)).set(n,0)}return e})(n,l-l%E)),u=0;l-E>=u;u+=E){const e=ce(J,ie(t,u,u+E));o&&f.update(e);const s=c.update(e);o||f.update(s),n.set(oe(J,s),u+r)}return e.pending=ie(t,u),n}async function re(n,r,s,o){n.password=null;const c=(e=>{if(void 0===w){const t=new i((e=unescape(encodeURIComponent(e))).length);for(let n=0;n<t.length;n++)t[n]=e.charCodeAt(n);return t}return(new w).encode(e)})(s),f=await(async(e,t,n,r,s)=>{if(!Z)return I.importKey(t);try{return await q.importKey("raw",t,n,!1,s)}catch(e){return Z=!1,I.importKey(t)}})(0,c,K,0,N),a=await(async(e,t,n)=>{if(!$)return I.B(t,e.salt,U.iterations,n);try{return await q.deriveBits(e,t,n)}catch(r){return $=!1,I.B(t,e.salt,U.iterations,n)}})(t.assign({salt:o},U),f,8*(2*T[r]+2)),l=new i(a),u=ce(J,ie(l,0,T[r])),h=ce(J,ie(l,T[r],2*T[r])),d=ie(l,2*T[r]);return t.assign(n,{keys:{key:u,$:h,passwordVerification:d},Y:new X(new Q(u),e.from(j)),Z:new Y(h)}),d}function se(e,t){let n=e;return e.length+t.length&&(n=new i(e.length+t.length),n.set(e,0),n.set(t,e.length)),n}function ie(e,t,n){return e.subarray(t,n)}function oe(e,t){return e.m(t)}function ce(e,t){return e.g(t)}class fe extends p{constructor({password:e,passwordVerification:n,checkPasswordOnly:r}){super({start(){t.assign(this,{password:e,passwordVerification:n}),we(this,e)},transform(e,t){const n=this;if(n.password){const t=le(n,e.subarray(0,12));if(n.password=null,t[11]!=n.passwordVerification)throw new s(V);e=e.subarray(12)}r?t.error(new s(R)):t.enqueue(le(n,e))}})}}class ae extends p{constructor({password:e,passwordVerification:n}){super({start(){t.assign(this,{password:e,passwordVerification:n}),we(this,e)},transform(e,t){const n=this;let r,s;if(n.password){n.password=null;const t=B(new i(12));t[11]=n.passwordVerification,r=new i(e.length+t.length),r.set(ue(n,t),0),s=12}else r=new i(e.length),s=0;r.set(ue(n,e),s),t.enqueue(r)}})}}function le(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=de(e)^t[r],he(e,n[r]);return n}function ue(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=de(e)^t[r],he(e,t[r]);return n}function we(e,n){const r=[305419896,591751049,878082192];t.assign(e,{keys:r,ee:new S(r[0]),te:new S(r[2])});for(let t=0;t<n.length;t++)he(e,n.charCodeAt(t))}function he(e,t){let[n,s,i]=e.keys;e.ee.append([t]),n=~e.ee.get(),s=ye(r.imul(ye(s+pe(n)),134775813)+1),e.te.append([s>>>24]),i=~e.te.get(),e.keys=[n,s,i]}function de(e){const t=2|e.keys[2];return pe(r.imul(t,1^t)>>>8)}function pe(e){return 255&e}function ye(e){return 4294967295&e}const me="deflate-raw";class be extends p{constructor(e,{chunkSize:t,CompressionStream:n,CompressionStreamNative:r}){super({});const{compressed:s,encrypted:i,useCompressionStream:o,zipCrypto:c,signed:f,level:a}=e,u=this;let w,h,d=ke(super.readable);i&&!c||!f||(w=new z,d=ze(d,w)),s&&(d=Se(d,o,{level:a,chunkSize:t},r,n)),i&&(c?d=ze(d,new ae(e)):(h=new te(e),d=ze(d,h))),ve(u,d,(async()=>{let e;i&&!c&&(e=h.signature),i&&!c||!f||(e=new l(w.value.buffer).getUint32(0)),u.signature=e}))}}class ge extends p{constructor(e,{chunkSize:t,DecompressionStream:n,DecompressionStreamNative:r}){super({});const{zipCrypto:i,encrypted:o,signed:c,signature:f,compressed:a,useCompressionStream:u}=e;let w,h,d=ke(super.readable);o&&(i?d=ze(d,new fe(e)):(h=new ee(e),d=ze(d,h))),a&&(d=Se(d,u,{chunkSize:t},r,n)),o&&!i||!c||(w=new z,d=ze(d,w)),ve(this,d,(async()=>{if((!o||i)&&c){const e=new l(w.value.buffer);if(f!=e.getUint32(0,!1))throw new s(P)}}))}}function ke(e){return ze(e,new p({transform(e,t){e&&e.length&&t.enqueue(e)}}))}function ve(e,n,r){n=ze(n,new p({flush:r})),t.defineProperty(e,"readable",{get:()=>n})}function Se(e,t,n,r,s){try{e=ze(e,new(t&&r?r:s)(me,n))}catch(r){if(!t)throw r;e=ze(e,new s(me,n))}return e}function ze(e,t){return e.pipeThrough(t)}const Ce="data";class xe extends p{constructor(e,n){super({});const r=this,{codecType:s}=e;let i;s.startsWith("deflate")?i=be:s.startsWith("inflate")&&(i=ge);let o=0;const c=new i(e,n),f=super.readable,a=new p({transform(e,t){e&&e.length&&(o+=e.length,t.enqueue(e))},flush(){const{signature:e}=c;t.assign(r,{signature:e,size:o})}});t.defineProperty(r,"readable",{get:()=>f.pipeThrough(c).pipeThrough(a)})}}const _e=new a,Ae=new a;let Ie=0;async function De(e){try{const{options:t,scripts:r,config:s}=e;r&&r.length&&importScripts.apply(void 0,r),self.initCodec&&self.initCodec(),s.CompressionStreamNative=self.CompressionStream,s.DecompressionStreamNative=self.DecompressionStream,self.Deflate&&(s.CompressionStream=new k(self.Deflate)),self.Inflate&&(s.DecompressionStream=new k(self.Inflate));const i={highWaterMark:1,size:()=>s.chunkSize},o=e.readable||new y({async pull(e){const t=new u((e=>_e.set(Ie,e)));Ve({type:"pull",messageId:Ie}),Ie=(Ie+1)%n.MAX_SAFE_INTEGER;const{value:r,done:s}=await t;e.enqueue(r),s&&e.close()}},i),c=e.writable||new m({async write(e){let t;const r=new u((e=>t=e));Ae.set(Ie,t),Ve({type:Ce,value:e,messageId:Ie}),Ie=(Ie+1)%n.MAX_SAFE_INTEGER,await r}},i),f=new xe(t,s);await o.pipeThrough(f).pipeTo(c,{preventClose:!0,preventAbort:!0});try{await c.getWriter().close()}catch(e){}const{signature:a,size:l}=f;Ve({type:"close",result:{signature:a,size:l}})}catch(e){Pe(e)}}function Ve(e){let{value:t}=e;if(t)if(t.length)try{t=new i(t),e.value=t.buffer,d(e,[e.value])}catch(t){d(e)}else d(e);else d(e)}function Pe(e){const{message:t,stack:n,code:r,name:s}=e;d({error:{message:t,stack:n,code:r,name:s}})}addEventListener("message",(({data:e})=>{const{type:t,messageId:n,value:r,done:s}=e;try{if("start"==t&&De(e),t==Ce){const e=_e.get(n);_e.delete(n),e({value:new i(r),done:s})}if("ack"==t){const e=Ae.get(n);Ae.delete(n),e()}}catch(e){Pe(e)}}));const Re=-2;function Be(t){return Ee(t.map((([t,n])=>new e(t).fill(n,0,t))))}function Ee(t){return t.reduce(((t,n)=>t.concat(e.isArray(n)?Ee(n):n)),[])}const Me=[0,1,2,3].concat(...Be([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function Ke(){const e=this;function t(e,t){let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1}e.ne=n=>{const s=e.re,i=e.ie.se,o=e.ie.oe;let c,f,a,l=-1;for(n.ce=0,n.fe=573,c=0;o>c;c++)0!==s[2*c]?(n.ae[++n.ce]=l=c,n.le[c]=0):s[2*c+1]=0;for(;2>n.ce;)a=n.ae[++n.ce]=2>l?++l:0,s[2*a]=1,n.le[a]=0,n.ue--,i&&(n.we-=i[2*a+1]);for(e.he=l,c=r.floor(n.ce/2);c>=1;c--)n.de(s,c);a=o;do{c=n.ae[1],n.ae[1]=n.ae[n.ce--],n.de(s,1),f=n.ae[1],n.ae[--n.fe]=c,n.ae[--n.fe]=f,s[2*a]=s[2*c]+s[2*f],n.le[a]=r.max(n.le[c],n.le[f])+1,s[2*c+1]=s[2*f+1]=a,n.ae[1]=a++,n.de(s,1)}while(n.ce>=2);n.ae[--n.fe]=n.ae[1],(t=>{const n=e.re,r=e.ie.se,s=e.ie.pe,i=e.ie.ye,o=e.ie.me;let c,f,a,l,u,w,h=0;for(l=0;15>=l;l++)t.be[l]=0;for(n[2*t.ae[t.fe]+1]=0,c=t.fe+1;573>c;c++)f=t.ae[c],l=n[2*n[2*f+1]+1]+1,l>o&&(l=o,h++),n[2*f+1]=l,f>e.he||(t.be[l]++,u=0,i>f||(u=s[f-i]),w=n[2*f],t.ue+=w*(l+u),r&&(t.we+=w*(r[2*f+1]+u)));if(0!==h){do{for(l=o-1;0===t.be[l];)l--;t.be[l]--,t.be[l+1]+=2,t.be[o]--,h-=2}while(h>0);for(l=o;0!==l;l--)for(f=t.be[l];0!==f;)a=t.ae[--c],a>e.he||(n[2*a+1]!=l&&(t.ue+=(l-n[2*a+1])*n[2*a],n[2*a+1]=l),f--)}})(n),((e,n,r)=>{const s=[];let i,o,c,f=0;for(i=1;15>=i;i++)s[i]=f=f+r[i-1]<<1;for(o=0;n>=o;o++)c=e[2*o+1],0!==c&&(e[2*o]=t(s[c]++,c))})(s,e.he,n.be)}}function Ue(e,t,n,r,s){const i=this;i.se=e,i.pe=t,i.ye=n,i.oe=r,i.me=s}Ke.ge=[0,1,2,3,4,5,6,7].concat(...Be([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),Ke.ke=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],Ke.ve=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],Ke.Se=e=>256>e?Me[e]:Me[256+(e>>>7)],Ke.ze=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],Ke.Ce=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],Ke.xe=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],Ke._e=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];const Ne=Be([[144,8],[112,9],[24,7],[8,8]]);Ue.Ae=Ee([12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,19,275,147,403,83,339,211,467,51,307,179,435,115,371,243,499,11,267,139,395,75,331,203,459,43,299,171,427,107,363,235,491,27,283,155,411,91,347,219,475,59,315,187,443,123,379,251,507,7,263,135,391,71,327,199,455,39,295,167,423,103,359,231,487,23,279,151,407,87,343,215,471,55,311,183,439,119,375,247,503,15,271,143,399,79,335,207,463,47,303,175,431,111,367,239,495,31,287,159,415,95,351,223,479,63,319,191,447,127,383,255,511,0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,3,131,67,195,35,163,99,227].map(((e,t)=>[e,Ne[t]])));const Oe=Be([[30,5]]);function Te(e,t,n,r,s){const i=this;i.Ie=e,i.De=t,i.Ve=n,i.Pe=r,i.Re=s}Ue.Be=Ee([0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,30,1,17,9,25,5,21,13,29,3,19,11,27,7,23].map(((e,t)=>[e,Oe[t]]))),Ue.Ee=new Ue(Ue.Ae,Ke.ze,257,286,15),Ue.Me=new Ue(Ue.Be,Ke.Ce,0,30,15),Ue.Ke=new Ue(null,Ke.xe,0,19,7);const We=[new Te(0,0,0,0,0),new Te(4,4,8,4,1),new Te(4,5,16,8,1),new Te(4,6,32,32,1),new Te(4,4,16,16,2),new Te(8,16,32,32,2),new Te(8,16,128,128,2),new Te(8,32,128,256,2),new Te(32,128,258,1024,2),new Te(32,258,258,4096,2)],je=["need dictionary","stream end","","","stream error","data error","","buffer error","",""],He=113,Le=666,Fe=262;function qe(e,t,n,r){const s=e[2*t],i=e[2*n];return i>s||s==i&&r[t]<=r[n]}function Ge(){const e=this;let t,n,s,c,f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z,C,x,_,A,I,D,V,P,R,B,E,M,K;const U=new Ke,N=new Ke,O=new Ke;let T,W,j,H,L,F;function q(){let t;for(t=0;286>t;t++)E[2*t]=0;for(t=0;30>t;t++)M[2*t]=0;for(t=0;19>t;t++)K[2*t]=0;E[512]=1,e.ue=e.we=0,W=j=0}function G(e,t){let n,r=-1,s=e[1],i=0,o=7,c=4;0===s&&(o=138,c=3),e[2*(t+1)+1]=65535;for(let f=0;t>=f;f++)n=s,s=e[2*(f+1)+1],++i<o&&n==s||(c>i?K[2*n]+=i:0!==n?(n!=r&&K[2*n]++,K[32]++):i>10?K[36]++:K[34]++,i=0,r=n,0===s?(o=138,c=3):n==s?(o=6,c=3):(o=7,c=4))}function J(t){e.Ue[e.pending++]=t}function Q(e){J(255&e),J(e>>>8&255)}function X(e,t){let n;const r=t;F>16-r?(n=e,L|=n<<F&65535,Q(L),L=n>>>16-F,F+=r-16):(L|=e<<F&65535,F+=r)}function Y(e,t){const n=2*e;X(65535&t[n],65535&t[n+1])}function Z(e,t){let n,r,s=-1,i=e[1],o=0,c=7,f=4;for(0===i&&(c=138,f=3),n=0;t>=n;n++)if(r=i,i=e[2*(n+1)+1],++o>=c||r!=i){if(f>o)do{Y(r,K)}while(0!=--o);else 0!==r?(r!=s&&(Y(r,K),o--),Y(16,K),X(o-3,2)):o>10?(Y(18,K),X(o-11,7)):(Y(17,K),X(o-3,3));o=0,s=r,0===i?(c=138,f=3):r==i?(c=6,f=3):(c=7,f=4)}}function $(){16==F?(Q(L),L=0,F=0):8>F||(J(255&L),L>>>=8,F-=8)}function ee(t,n){let s,i,o;if(e.Ne[W]=t,e.Oe[W]=255&n,W++,0===t?E[2*n]++:(j++,t--,E[2*(Ke.ge[n]+256+1)]++,M[2*Ke.Se(t)]++),0==(8191&W)&&V>2){for(s=8*W,i=C-k,o=0;30>o;o++)s+=M[2*o]*(5+Ke.Ce[o]);if(s>>>=3,j<r.floor(W/2)&&s<r.floor(i/2))return!0}return W==T-1}function te(t,n){let r,s,i,o,c=0;if(0!==W)do{r=e.Ne[c],s=e.Oe[c],c++,0===r?Y(s,t):(i=Ke.ge[s],Y(i+256+1,t),o=Ke.ze[i],0!==o&&(s-=Ke.ke[i],X(s,o)),r--,i=Ke.Se(r),Y(i,n),o=Ke.Ce[i],0!==o&&(r-=Ke.ve[i],X(r,o)))}while(W>c);Y(256,t),H=t[513]}function ne(){F>8?Q(L):F>0&&J(255&L),L=0,F=0}function re(t,n,r){X(0+(r?1:0),3),((t,n)=>{ne(),H=8,Q(n),Q(~n),e.Ue.set(u.subarray(t,t+n),e.pending),e.pending+=n})(t,n)}function se(n){((t,n,r)=>{let s,i,o=0;V>0?(U.ne(e),N.ne(e),o=(()=>{let t;for(G(E,U.he),G(M,N.he),O.ne(e),t=18;t>=3&&0===K[2*Ke._e[t]+1];t--);return e.ue+=14+3*(t+1),t})(),s=e.ue+3+7>>>3,i=e.we+3+7>>>3,i>s||(s=i)):s=i=n+5,n+4>s||-1==t?i==s?(X(2+(r?1:0),3),te(Ue.Ae,Ue.Be)):(X(4+(r?1:0),3),((e,t,n)=>{let r;for(X(e-257,5),X(t-1,5),X(n-4,4),r=0;n>r;r++)X(K[2*Ke._e[r]+1],3);Z(E,e-1),Z(M,t-1)})(U.he+1,N.he+1,o+1),te(E,M)):re(t,n,r),q(),r&&ne()})(0>k?-1:k,C-k,n),k=C,t.Te()}function ie(){let e,n,r,s;do{if(s=w-_-C,0===s&&0===C&&0===_)s=f;else if(-1==s)s--;else if(C>=f+f-Fe){u.set(u.subarray(f,f+f),0),x-=f,C-=f,k-=f,e=y,r=e;do{n=65535&d[--r],d[r]=f>n?0:n-f}while(0!=--e);e=f,r=e;do{n=65535&h[--r],h[r]=f>n?0:n-f}while(0!=--e);s+=f}if(0===t.We)return;e=t.je(u,C+_,s),_+=e,3>_||(p=255&u[C],p=(p<<g^255&u[C+1])&b)}while(Fe>_&&0!==t.We)}function oe(e){let t,n,r=I,s=C,i=A;const o=C>f-Fe?C-(f-Fe):0;let c=B;const a=l,w=C+258;let d=u[s+i-1],p=u[s+i];R>A||(r>>=2),c>_&&(c=_);do{if(t=e,u[t+i]==p&&u[t+i-1]==d&&u[t]==u[s]&&u[++t]==u[s+1]){s+=2,t++;do{}while(u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&w>s);if(n=258-(w-s),s=w-258,n>i){if(x=e,i=n,n>=c)break;d=u[s+i-1],p=u[s+i]}}}while((e=65535&h[e&a])>o&&0!=--r);return i>_?_:i}e.le=[],e.be=[],e.ae=[],E=[],M=[],K=[],e.de=(t,n)=>{const r=e.ae,s=r[n];let i=n<<1;for(;i<=e.ce&&(i<e.ce&&qe(t,r[i+1],r[i],e.le)&&i++,!qe(t,s,r[i],e.le));)r[n]=r[i],n=i,i<<=1;r[n]=s},e.He=(t,S,x,W,j,G)=>(W||(W=8),j||(j=8),G||(G=0),t.Le=null,-1==S&&(S=6),1>j||j>9||8!=W||9>x||x>15||0>S||S>9||0>G||G>2?Re:(t.Fe=e,a=x,f=1<<a,l=f-1,m=j+7,y=1<<m,b=y-1,g=r.floor((m+3-1)/3),u=new i(2*f),h=[],d=[],T=1<<j+6,e.Ue=new i(4*T),s=4*T,e.Ne=new o(T),e.Oe=new i(T),V=S,P=G,(t=>(t.qe=t.Ge=0,t.Le=null,e.pending=0,e.Je=0,n=He,c=0,U.re=E,U.ie=Ue.Ee,N.re=M,N.ie=Ue.Me,O.re=K,O.ie=Ue.Ke,L=0,F=0,H=8,q(),(()=>{w=2*f,d[y-1]=0;for(let e=0;y-1>e;e++)d[e]=0;D=We[V].De,R=We[V].Ie,B=We[V].Ve,I=We[V].Pe,C=0,k=0,_=0,v=A=2,z=0,p=0})(),0))(t))),e.Qe=()=>42!=n&&n!=He&&n!=Le?Re:(e.Oe=null,e.Ne=null,e.Ue=null,d=null,h=null,u=null,e.Fe=null,n==He?-3:0),e.Xe=(e,t,n)=>{let r=0;return-1==t&&(t=6),0>t||t>9||0>n||n>2?Re:(We[V].Re!=We[t].Re&&0!==e.qe&&(r=e.Ye(1)),V!=t&&(V=t,D=We[V].De,R=We[V].Ie,B=We[V].Ve,I=We[V].Pe),P=n,r)},e.Ze=(e,t,r)=>{let s,i=r,o=0;if(!t||42!=n)return Re;if(3>i)return 0;for(i>f-Fe&&(i=f-Fe,o=r-i),u.set(t.subarray(o,o+i),0),C=i,k=i,p=255&u[0],p=(p<<g^255&u[1])&b,s=0;i-3>=s;s++)p=(p<<g^255&u[s+2])&b,h[s&l]=d[p],d[p]=s;return 0},e.Ye=(r,i)=>{let o,w,m,I,R;if(i>4||0>i)return Re;if(!r.$e||!r.et&&0!==r.We||n==Le&&4!=i)return r.Le=je[4],Re;if(0===r.tt)return r.Le=je[7],-5;var B;if(t=r,I=c,c=i,42==n&&(w=8+(a-8<<4)<<8,m=(V-1&255)>>1,m>3&&(m=3),w|=m<<6,0!==C&&(w|=32),w+=31-w%31,n=He,J((B=w)>>8&255),J(255&B)),0!==e.pending){if(t.Te(),0===t.tt)return c=-1,0}else if(0===t.We&&I>=i&&4!=i)return t.Le=je[7],-5;if(n==Le&&0!==t.We)return r.Le=je[7],-5;if(0!==t.We||0!==_||0!=i&&n!=Le){switch(R=-1,We[V].Re){case 0:R=(e=>{let n,r=65535;for(r>s-5&&(r=s-5);;){if(1>=_){if(ie(),0===_&&0==e)return 0;if(0===_)break}if(C+=_,_=0,n=k+r,(0===C||C>=n)&&(_=C-n,C=n,se(!1),0===t.tt))return 0;if(C-k>=f-Fe&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 1:R=(e=>{let n,r=0;for(;;){if(Fe>_){if(ie(),Fe>_&&0==e)return 0;if(0===_)break}if(3>_||(p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C),0===r||(C-r&65535)>f-Fe||2!=P&&(v=oe(r)),3>v)n=ee(0,255&u[C]),_--,C++;else if(n=ee(C-x,v-3),_-=v,v>D||3>_)C+=v,v=0,p=255&u[C],p=(p<<g^255&u[C+1])&b;else{v--;do{C++,p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C}while(0!=--v);C++}if(n&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 2:R=(e=>{let n,r,s=0;for(;;){if(Fe>_){if(ie(),Fe>_&&0==e)return 0;if(0===_)break}if(3>_||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C),A=v,S=x,v=2,0!==s&&D>A&&f-Fe>=(C-s&65535)&&(2!=P&&(v=oe(s)),5>=v&&(1==P||3==v&&C-x>4096)&&(v=2)),3>A||v>A)if(0!==z){if(n=ee(0,255&u[C-1]),n&&se(!1),C++,_--,0===t.tt)return 0}else z=1,C++,_--;else{r=C+_-3,n=ee(C-1-S,A-3),_-=A-1,A-=2;do{++C>r||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C)}while(0!=--A);if(z=0,v=2,C++,n&&(se(!1),0===t.tt))return 0}}return 0!==z&&(n=ee(0,255&u[C-1]),z=0),se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i)}if(2!=R&&3!=R||(n=Le),0==R||2==R)return 0===t.tt&&(c=-1),0;if(1==R){if(1==i)X(2,3),Y(256,Ue.Ae),$(),9>1+H+10-F&&(X(2,3),Y(256,Ue.Ae),$()),H=7;else if(re(0,0,!1),3==i)for(o=0;y>o;o++)d[o]=0;if(t.Te(),0===t.tt)return c=-1,0}}return 4!=i?0:1}}function Je(){const e=this;e.nt=0,e.rt=0,e.We=0,e.qe=0,e.tt=0,e.Ge=0}function Qe(e){const t=new Je,n=(o=e&&e.chunkSize?e.chunkSize:65536)+5*(r.floor(o/16383)+1);var o;const c=new i(n);let f=e?e.level:-1;void 0===f&&(f=-1),t.He(f),t.$e=c,this.append=(e,r)=>{let o,f,a=0,l=0,u=0;const w=[];if(e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,o=t.Ye(0),0!=o)throw new s("deflating: "+t.Le);t.rt&&(t.rt==n?w.push(new i(c)):w.push(c.subarray(0,t.rt))),u+=t.rt,r&&t.nt>0&&t.nt!=a&&(r(t.nt),a=t.nt)}while(t.We>0||0===t.tt);return w.length>1?(f=new i(u),w.forEach((e=>{f.set(e,l),l+=e.length}))):f=w[0]?new i(w[0]):new i,f}},this.flush=()=>{let e,r,o=0,f=0;const a=[];do{if(t.rt=0,t.tt=n,e=t.Ye(4),1!=e&&0!=e)throw new s("deflating: "+t.Le);n-t.tt>0&&a.push(c.slice(0,t.rt)),f+=t.rt}while(t.We>0||0===t.tt);return t.Qe(),r=new i(f),a.forEach((e=>{r.set(e,o),o+=e.length})),r}}Je.prototype={He(e,t){const n=this;return n.Fe=new Ge,t||(t=15),n.Fe.He(n,e,t)},Ye(e){const t=this;return t.Fe?t.Fe.Ye(t,e):Re},Qe(){const e=this;if(!e.Fe)return Re;const t=e.Fe.Qe();return e.Fe=null,t},Xe(e,t){const n=this;return n.Fe?n.Fe.Xe(n,e,t):Re},Ze(e,t){const n=this;return n.Fe?n.Fe.Ze(n,e,t):Re},je(e,t,n){const r=this;let s=r.We;return s>n&&(s=n),0===s?0:(r.We-=s,e.set(r.et.subarray(r.nt,r.nt+s),t),r.nt+=s,r.qe+=s,s)},Te(){const e=this;let t=e.Fe.pending;t>e.tt&&(t=e.tt),0!==t&&(e.$e.set(e.Fe.Ue.subarray(e.Fe.Je,e.Fe.Je+t),e.rt),e.rt+=t,e.Fe.Je+=t,e.Ge+=t,e.tt-=t,e.Fe.pending-=t,0===e.Fe.pending&&(e.Fe.Je=0))}};const Xe=-2,Ye=-3,Ze=-5,$e=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],et=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],tt=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],nt=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],rt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],st=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],it=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function ot(){let e,t,n,r,s,i;function o(e,t,o,c,f,a,l,u,w,h,d){let p,y,m,b,g,k,v,S,z,C,x,_,A,I,D;C=0,g=o;do{n[e[t+C]]++,C++,g--}while(0!==g);if(n[0]==o)return l[0]=-1,u[0]=0,0;for(S=u[0],k=1;15>=k&&0===n[k];k++);for(v=k,k>S&&(S=k),g=15;0!==g&&0===n[g];g--);for(m=g,S>g&&(S=g),u[0]=S,I=1<<k;g>k;k++,I<<=1)if(0>(I-=n[k]))return Ye;if(0>(I-=n[g]))return Ye;for(n[g]+=I,i[1]=k=0,C=1,A=2;0!=--g;)i[A]=k+=n[C],A++,C++;g=0,C=0;do{0!==(k=e[t+C])&&(d[i[k]++]=g),C++}while(++g<o);for(o=i[m],i[0]=g=0,C=0,b=-1,_=-S,s[0]=0,x=0,D=0;m>=v;v++)for(p=n[v];0!=p--;){for(;v>_+S;){if(b++,_+=S,D=m-_,D=D>S?S:D,(y=1<<(k=v-_))>p+1&&(y-=p+1,A=v,D>k))for(;++k<D&&(y<<=1)>n[++A];)y-=n[A];if(D=1<<k,h[0]+D>1440)return Ye;s[b]=x=h[0],h[0]+=D,0!==b?(i[b]=g,r[0]=k,r[1]=S,k=g>>>_-S,r[2]=x-s[b-1]-k,w.set(r,3*(s[b-1]+k))):l[0]=x}for(r[1]=v-_,o>C?d[C]<c?(r[0]=256>d[C]?0:96,r[2]=d[C++]):(r[0]=a[d[C]-c]+16+64,r[2]=f[d[C++]-c]):r[0]=192,y=1<<v-_,k=g>>>_;D>k;k+=y)w.set(r,3*(x+k));for(k=1<<v-1;0!=(g&k);k>>>=1)g^=k;for(g^=k,z=(1<<_)-1;(g&z)!=i[b];)b--,_-=S,z=(1<<_)-1}return 0!==I&&1!=m?Ze:0}function c(o){let c;for(e||(e=[],t=[],n=new f(16),r=[],s=new f(15),i=new f(16)),t.length<o&&(t=[]),c=0;o>c;c++)t[c]=0;for(c=0;16>c;c++)n[c]=0;for(c=0;3>c;c++)r[c]=0;s.set(n.subarray(0,15),0),i.set(n.subarray(0,16),0)}this.st=(n,r,s,i,f)=>{let a;return c(19),e[0]=0,a=o(n,0,19,19,null,null,s,r,i,e,t),a==Ye?f.Le="oversubscribed dynamic bit lengths tree":a!=Ze&&0!==r[0]||(f.Le="incomplete dynamic bit lengths tree",a=Ye),a},this.it=(n,r,s,i,f,a,l,u,w)=>{let h;return c(288),e[0]=0,h=o(s,0,n,257,nt,rt,a,i,u,e,t),0!=h||0===i[0]?(h==Ye?w.Le="oversubscribed literal/length tree":-4!=h&&(w.Le="incomplete literal/length tree",h=Ye),h):(c(288),h=o(s,n,r,0,st,it,l,f,u,e,t),0!=h||0===f[0]&&n>257?(h==Ye?w.Le="oversubscribed distance tree":h==Ze?(w.Le="incomplete distance tree",h=Ye):-4!=h&&(w.Le="empty distance tree with lengths",h=Ye),h):0)}}function ct(){const e=this;let t,n,r,s,i=0,o=0,c=0,f=0,a=0,l=0,u=0,w=0,h=0,d=0;function p(e,t,n,r,s,i,o,c){let f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z;d=c.nt,p=c.We,w=o.ot,h=o.ct,y=o.write,m=y<o.read?o.read-y-1:o.end-y,b=$e[e],g=$e[t];do{for(;20>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(f=w&b,a=n,l=r,z=3*(l+f),0!==(u=a[z]))for(;;){if(w>>=a[z+1],h-=a[z+1],0!=(16&u)){for(u&=15,k=a[z+2]+(w&$e[u]),w>>=u,h-=u;15>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;for(f=w&g,a=s,l=i,z=3*(l+f),u=a[z];;){if(w>>=a[z+1],h-=a[z+1],0!=(16&u)){for(u&=15;u>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(v=a[z+2]+(w&$e[u]),w>>=u,h-=u,m-=k,v>y){S=y-v;do{S+=o.end}while(0>S);if(u=o.end-S,k>u){if(k-=u,y-S>0&&u>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--u);else o.lt.set(o.lt.subarray(S,S+u),y),y+=u,S+=u,u=0;S=0}}else S=y-v,y-S>0&&2>y-S?(o.lt[y++]=o.lt[S++],o.lt[y++]=o.lt[S++],k-=2):(o.lt.set(o.lt.subarray(S,S+2),y),y+=2,S+=2,k-=2);if(y-S>0&&k>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--k);else o.lt.set(o.lt.subarray(S,S+k),y),y+=k,S+=k,k=0;break}if(0!=(64&u))return c.Le="invalid distance code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,Ye;f+=a[z+2],f+=w&$e[u],z=3*(l+f),u=a[z]}break}if(0!=(64&u))return 0!=(32&u)?(k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,1):(c.Le="invalid literal/length code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,Ye);if(f+=a[z+2],f+=w&$e[u],z=3*(l+f),0===(u=a[z])){w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--;break}}else w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--}while(m>=258&&p>=10);return k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,0}e.init=(e,i,o,c,f,a)=>{t=0,u=e,w=i,r=o,h=c,s=f,d=a,n=null},e.ut=(e,y,m)=>{let b,g,k,v,S,z,C,x=0,_=0,A=0;for(A=y.nt,v=y.We,x=e.ot,_=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S;;)switch(t){case 0:if(z>=258&&v>=10&&(e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,m=p(u,w,r,h,s,d,e,y),A=y.nt,v=y.We,x=e.ot,_=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S,0!=m)){t=1==m?7:9;break}c=u,n=r,o=h,t=1;case 1:for(b=c;b>_;){if(0===v)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(A++))<<_,_+=8}if(g=3*(o+(x&$e[b])),x>>>=n[g+1],_-=n[g+1],k=n[g],0===k){f=n[g+2],t=6;break}if(0!=(16&k)){a=15&k,i=n[g+2],t=2;break}if(0==(64&k)){c=k,o=g/3+n[g+2];break}if(0!=(32&k)){t=7;break}return t=9,y.Le="invalid literal/length code",m=Ye,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);case 2:for(b=a;b>_;){if(0===v)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(A++))<<_,_+=8}i+=x&$e[b],x>>=b,_-=b,c=w,n=s,o=d,t=3;case 3:for(b=c;b>_;){if(0===v)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(A++))<<_,_+=8}if(g=3*(o+(x&$e[b])),x>>=n[g+1],_-=n[g+1],k=n[g],0!=(16&k)){a=15&k,l=n[g+2],t=4;break}if(0==(64&k)){c=k,o=g/3+n[g+2];break}return t=9,y.Le="invalid distance code",m=Ye,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);case 4:for(b=a;b>_;){if(0===v)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(A++))<<_,_+=8}l+=x&$e[b],x>>=b,_-=b,t=5;case 5:for(C=S-l;0>C;)C+=e.end;for(;0!==i;){if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);e.lt[S++]=e.lt[C++],z--,C==e.end&&(C=0),i--}t=0;break;case 6:if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);m=0,e.lt[S++]=f,z--,t=0;break;case 7:if(_>7&&(_-=8,v++,A--),e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,e.read!=e.write)return e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);t=8;case 8:return m=1,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);case 9:return m=Ye,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m);default:return m=Xe,e.ot=x,e.ct=_,y.We=v,y.qe+=A-y.nt,y.nt=A,e.write=S,e.wt(y,m)}},e.ht=()=>{}}ot.dt=(e,t,n,r)=>(e[0]=9,t[0]=5,n[0]=et,r[0]=tt,0);const ft=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function at(e,t){const n=this;let r,s=0,o=0,c=0,a=0;const l=[0],u=[0],w=new ct;let h=0,d=new f(4320);const p=new ot;n.ct=0,n.ot=0,n.lt=new i(t),n.end=t,n.read=0,n.write=0,n.reset=(e,t)=>{t&&(t[0]=0),6==s&&w.ht(e),s=0,n.ct=0,n.ot=0,n.read=n.write=0},n.reset(e,null),n.wt=(e,t)=>{let r,s,i;return s=e.rt,i=n.read,r=(i>n.write?n.end:n.write)-i,r>e.tt&&(r=e.tt),0!==r&&t==Ze&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r,i==n.end&&(i=0,n.write==n.end&&(n.write=0),r=n.write-i,r>e.tt&&(r=e.tt),0!==r&&t==Ze&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r),e.rt=s,n.read=i,t},n.ut=(e,t)=>{let i,f,y,m,b,g,k,v;for(m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g;;){let S,z,C,x,_,A,I,D;switch(s){case 0:for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}switch(i=7&f,h=1&i,i>>>1){case 0:f>>>=3,y-=3,i=7&y,f>>>=i,y-=i,s=1;break;case 1:S=[],z=[],C=[[]],x=[[]],ot.dt(S,z,C,x),w.init(S[0],z[0],C[0],0,x[0],0),f>>>=3,y-=3,s=6;break;case 2:f>>>=3,y-=3,s=3;break;case 3:return f>>>=3,y-=3,s=9,e.Le="invalid block type",t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}break;case 1:for(;32>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if((~f>>>16&65535)!=(65535&f))return s=9,e.Le="invalid stored block lengths",t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);o=65535&f,f=y=0,s=0!==o?2:0!==h?7:0;break;case 2:if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(0===k&&(g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k&&(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k)))return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(t=0,i=o,i>b&&(i=b),i>k&&(i=k),n.lt.set(e.je(m,i),g),m+=i,b-=i,g+=i,k-=i,0!=(o-=i))break;s=0!==h?7:0;break;case 3:for(;14>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(c=i=16383&f,(31&i)>29||(i>>5&31)>29)return s=9,e.Le="too many length or distance symbols",t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(i=258+(31&i)+(i>>5&31),!r||r.length<i)r=[];else for(v=0;i>v;v++)r[v]=0;f>>>=14,y-=14,a=0,s=4;case 4:for(;4+(c>>>10)>a;){for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}r[ft[a++]]=7&f,f>>>=3,y-=3}for(;19>a;)r[ft[a++]]=0;if(l[0]=7,i=p.st(r,l,u,d,e),0!=i)return(t=i)==Ye&&(r=null,s=9),n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);a=0,s=5;case 5:for(;i=c,258+(31&i)+(i>>5&31)>a;){let o,w;for(i=l[0];i>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(i=d[3*(u[0]+(f&$e[i]))+1],w=d[3*(u[0]+(f&$e[i]))+2],16>w)f>>>=i,y-=i,r[a++]=w;else{for(v=18==w?7:w-14,o=18==w?11:3;i+v>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(f>>>=i,y-=i,o+=f&$e[v],f>>>=v,y-=v,v=a,i=c,v+o>258+(31&i)+(i>>5&31)||16==w&&1>v)return r=null,s=9,e.Le="invalid bit length repeat",t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w=16==w?r[v-1]:0;do{r[v++]=w}while(0!=--o);a=v}}if(u[0]=-1,_=[],A=[],I=[],D=[],_[0]=9,A[0]=6,i=c,i=p.it(257+(31&i),1+(i>>5&31),r,_,A,I,D,d,e),0!=i)return i==Ye&&(r=null,s=9),t=i,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w.init(_[0],A[0],d,I[0],d,D[0]),s=6;case 6:if(n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,1!=(t=w.ut(n,e,t)))return n.wt(e,t);if(t=0,w.ht(e),m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g,0===h){s=0;break}s=7;case 7:if(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);s=8;case 8:return t=1,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);case 9:return t=Ye,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);default:return t=Xe,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}}},n.ht=e=>{n.reset(e,null),n.lt=null,d=null},n.yt=(e,t,r)=>{n.lt.set(e.subarray(t,t+r),0),n.read=n.write=r},n.bt=()=>1==s?1:0}const lt=13,ut=[0,0,255,255];function wt(){const e=this;function t(e){return e&&e.gt?(e.qe=e.Ge=0,e.Le=null,e.gt.mode=7,e.gt.kt.reset(e,null),0):Xe}e.mode=0,e.method=0,e.vt=[0],e.St=0,e.marker=0,e.zt=0,e.Ct=t=>(e.kt&&e.kt.ht(t),e.kt=null,0),e.xt=(n,r)=>(n.Le=null,e.kt=null,8>r||r>15?(e.Ct(n),Xe):(e.zt=r,n.gt.kt=new at(n,1<<r),t(n),0)),e._t=(e,t)=>{let n,r;if(!e||!e.gt||!e.et)return Xe;const s=e.gt;for(t=4==t?Ze:0,n=Ze;;)switch(s.mode){case 0:if(0===e.We)return n;if(n=t,e.We--,e.qe++,8!=(15&(s.method=e.ft(e.nt++)))){s.mode=lt,e.Le="unknown compression method",s.marker=5;break}if(8+(s.method>>4)>s.zt){s.mode=lt,e.Le="invalid win size",s.marker=5;break}s.mode=1;case 1:if(0===e.We)return n;if(n=t,e.We--,e.qe++,r=255&e.ft(e.nt++),((s.method<<8)+r)%31!=0){s.mode=lt,e.Le="incorrect header check",s.marker=5;break}if(0==(32&r)){s.mode=7;break}s.mode=2;case 2:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St=(255&e.ft(e.nt++))<<24&4278190080,s.mode=3;case 3:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<16&16711680,s.mode=4;case 4:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<8&65280,s.mode=5;case 5:return 0===e.We?n:(n=t,e.We--,e.qe++,s.St+=255&e.ft(e.nt++),s.mode=6,2);case 6:return s.mode=lt,e.Le="need dictionary",s.marker=0,Xe;case 7:if(n=s.kt.ut(e,n),n==Ye){s.mode=lt,s.marker=0;break}if(0==n&&(n=t),1!=n)return n;n=t,s.kt.reset(e,s.vt),s.mode=12;case 12:return e.We=0,1;case lt:return Ye;default:return Xe}},e.At=(e,t,n)=>{let r=0,s=n;if(!e||!e.gt||6!=e.gt.mode)return Xe;const i=e.gt;return s<1<<i.zt||(s=(1<<i.zt)-1,r=n-s),i.kt.yt(t,r,s),i.mode=7,0},e.It=e=>{let n,r,s,i,o;if(!e||!e.gt)return Xe;const c=e.gt;if(c.mode!=lt&&(c.mode=lt,c.marker=0),0===(n=e.We))return Ze;for(r=e.nt,s=c.marker;0!==n&&4>s;)e.ft(r)==ut[s]?s++:s=0!==e.ft(r)?0:4-s,r++,n--;return e.qe+=r-e.nt,e.nt=r,e.We=n,c.marker=s,4!=s?Ye:(i=e.qe,o=e.Ge,t(e),e.qe=i,e.Ge=o,c.mode=7,0)},e.Dt=e=>e&&e.gt&&e.gt.kt?e.gt.kt.bt():Xe}function ht(){}function dt(e){const t=new ht,n=e&&e.chunkSize?r.floor(2*e.chunkSize):131072,o=new i(n);let c=!1;t.xt(),t.$e=o,this.append=(e,r)=>{const f=[];let a,l,u=0,w=0,h=0;if(0!==e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,0!==t.We||c||(t.nt=0,c=!0),a=t._t(0),c&&a===Ze){if(0!==t.We)throw new s("inflating: bad input")}else if(0!==a&&1!==a)throw new s("inflating: "+t.Le);if((c||1===a)&&t.We===e.length)throw new s("inflating: bad input");t.rt&&(t.rt===n?f.push(new i(o)):f.push(o.subarray(0,t.rt))),h+=t.rt,r&&t.nt>0&&t.nt!=u&&(r(t.nt),u=t.nt)}while(t.We>0||0===t.tt);return f.length>1?(l=new i(h),f.forEach((e=>{l.set(e,w),w+=e.length}))):l=f[0]?new i(f[0]):new i,l}},this.flush=()=>{t.Ct()}}ht.prototype={xt(e){const t=this;return t.gt=new wt,e||(e=15),t.gt.xt(t,e)},_t(e){const t=this;return t.gt?t.gt._t(t,e):Xe},Ct(){const e=this;if(!e.gt)return Xe;const t=e.gt.Ct(e);return e.gt=null,t},It(){const e=this;return e.gt?e.gt.It(e):Xe},At(e,t){const n=this;return n.gt?n.gt.At(n,e,t):Xe},ft(e){return this.et[e]},je(e,t){return this.et.subarray(e,e+t)}},self.initCodec=()=>{self.Deflate=Qe,self.Inflate=dt};\n'
        ], {
            type: "text/javascript"
        }));
    e({
        workerScripts: {
            inflate: [
                t
            ],
            deflate: [
                t
            ]
        }
    });
}
const ERR_ITERATOR_COMPLETED_TOO_SOON = "Writer iterator completed too soon";
const HTTP_HEADER_CONTENT_TYPE = "Content-Type";
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const PROPERTY_NAME_WRITABLE = "writable";
class Stream {
    constructor(){
        this.size = 0;
    }
    init() {
        this.initialized = true;
    }
}
class Reader extends Stream {
    get readable() {
        const reader = this;
        const { chunkSize = DEFAULT_CHUNK_SIZE } = reader;
        const readable = new ReadableStream({
            start () {
                this.chunkOffset = 0;
            },
            async pull (controller) {
                const { offset = 0, size, diskNumberStart } = readable;
                const { chunkOffset } = this;
                controller.enqueue(await readUint8Array(reader, offset + chunkOffset, Math.min(chunkSize, size - chunkOffset), diskNumberStart));
                if (chunkOffset + chunkSize > size) {
                    controller.close();
                } else {
                    this.chunkOffset += chunkSize;
                }
            }
        });
        return readable;
    }
}
class BlobReader extends Reader {
    constructor(blob){
        super();
        Object.assign(this, {
            blob,
            size: blob.size
        });
    }
    async readUint8Array(offset, length) {
        const reader = this;
        const offsetEnd = offset + length;
        const blob = offset || offsetEnd < reader.size ? reader.blob.slice(offset, offsetEnd) : reader.blob;
        let arrayBuffer = await blob.arrayBuffer();
        if (arrayBuffer.byteLength > length) {
            arrayBuffer = arrayBuffer.slice(offset, offsetEnd);
        }
        return new Uint8Array(arrayBuffer);
    }
}
class BlobWriter extends Stream {
    constructor(contentType){
        super();
        const writer = this;
        const transformStream = new TransformStream();
        const headers = [];
        if (contentType) {
            headers.push([
                HTTP_HEADER_CONTENT_TYPE,
                contentType
            ]);
        }
        Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
            get () {
                return transformStream.writable;
            }
        });
        writer.blob = new Response(transformStream.readable, {
            headers
        }).blob();
    }
    getData() {
        return this.blob;
    }
}
class TextWriter extends BlobWriter {
    constructor(encoding){
        super(encoding);
        Object.assign(this, {
            encoding,
            utf8: !encoding || encoding.toLowerCase() == "utf-8"
        });
    }
    async getData() {
        const { encoding, utf8 } = this;
        const blob = await super.getData();
        if (blob.text && utf8) {
            return blob.text();
        } else {
            const reader = new FileReader();
            return new Promise((resolve, reject)=>{
                Object.assign(reader, {
                    onload: ({ target })=>resolve(target.result),
                    onerror: ()=>reject(reader.error)
                });
                reader.readAsText(blob, encoding);
            });
        }
    }
}
class Uint8ArrayReader extends Reader {
    constructor(array){
        super();
        Object.assign(this, {
            array,
            size: array.length
        });
    }
    readUint8Array(index, length) {
        return this.array.slice(index, index + length);
    }
}
class SplitDataReader extends Reader {
    constructor(readers){
        super();
        this.readers = readers;
    }
    async init() {
        const reader = this;
        const { readers } = reader;
        reader.lastDiskNumber = 0;
        reader.lastDiskOffset = 0;
        await Promise.all(readers.map(async (diskReader, indexDiskReader)=>{
            await diskReader.init();
            if (indexDiskReader != readers.length - 1) {
                reader.lastDiskOffset += diskReader.size;
            }
            reader.size += diskReader.size;
        }));
        super.init();
    }
    async readUint8Array(offset, length, diskNumber = 0) {
        const reader = this;
        const { readers } = this;
        let result;
        let currentDiskNumber = diskNumber;
        if (currentDiskNumber == -1) {
            currentDiskNumber = readers.length - 1;
        }
        let currentReaderOffset = offset;
        while(currentReaderOffset >= readers[currentDiskNumber].size){
            currentReaderOffset -= readers[currentDiskNumber].size;
            currentDiskNumber++;
        }
        const currentReader = readers[currentDiskNumber];
        const currentReaderSize = currentReader.size;
        if (currentReaderOffset + length <= currentReaderSize) {
            result = await readUint8Array(currentReader, currentReaderOffset, length);
        } else {
            const chunkLength = currentReaderSize - currentReaderOffset;
            result = new Uint8Array(length);
            result.set(await readUint8Array(currentReader, currentReaderOffset, chunkLength));
            result.set(await reader.readUint8Array(offset + chunkLength, length - chunkLength, diskNumber), chunkLength);
        }
        reader.lastDiskNumber = Math.max(currentDiskNumber, reader.lastDiskNumber);
        return result;
    }
}
class SplitDataWriter extends Stream {
    constructor(writerGenerator, maxSize = 4294967295){
        super();
        const zipWriter = this;
        Object.assign(zipWriter, {
            diskNumber: 0,
            diskOffset: 0,
            size: 0,
            maxSize,
            availableSize: maxSize
        });
        let diskSourceWriter, diskWritable, diskWriter;
        const writable = new WritableStream({
            async write (chunk) {
                const { availableSize } = zipWriter;
                if (!diskWriter) {
                    const { value: value1, done } = await writerGenerator.next();
                    if (done && !value1) {
                        throw new Error(ERR_ITERATOR_COMPLETED_TOO_SOON);
                    } else {
                        diskSourceWriter = value1;
                        diskSourceWriter.size = 0;
                        if (diskSourceWriter.maxSize) {
                            zipWriter.maxSize = diskSourceWriter.maxSize;
                        }
                        zipWriter.availableSize = zipWriter.maxSize;
                        await initStream(diskSourceWriter);
                        diskWritable = value1.writable;
                        diskWriter = diskWritable.getWriter();
                    }
                    await this.write(chunk);
                } else if (chunk.length >= availableSize) {
                    await writeChunk(chunk.slice(0, availableSize));
                    await closeDisk();
                    zipWriter.diskOffset += diskSourceWriter.size;
                    zipWriter.diskNumber++;
                    diskWriter = null;
                    await this.write(chunk.slice(availableSize));
                } else {
                    await writeChunk(chunk);
                }
            },
            async close () {
                await diskWriter.ready;
                await closeDisk();
            }
        });
        Object.defineProperty(zipWriter, PROPERTY_NAME_WRITABLE, {
            get () {
                return writable;
            }
        });
        async function writeChunk(chunk) {
            const chunkLength = chunk.length;
            if (chunkLength) {
                await diskWriter.ready;
                await diskWriter.write(chunk);
                diskSourceWriter.size += chunkLength;
                zipWriter.size += chunkLength;
                zipWriter.availableSize -= chunkLength;
            }
        }
        async function closeDisk() {
            diskWritable.size = diskSourceWriter.size;
            await diskWriter.close();
        }
    }
}
async function initStream(stream, initSize) {
    if (stream.init && !stream.initialized) {
        await stream.init(initSize);
    }
}
function initReader(reader) {
    if (Array.isArray(reader)) {
        reader = new SplitDataReader(reader);
    }
    if (reader instanceof ReadableStream) {
        reader = {
            readable: reader
        };
    }
    return reader;
}
function initWriter(writer) {
    if (writer.writable === UNDEFINED_VALUE && typeof writer.next == FUNCTION_TYPE) {
        writer = new SplitDataWriter(writer);
    }
    if (writer instanceof WritableStream) {
        writer = {
            writable: writer
        };
    }
    const { writable } = writer;
    if (writable.size === UNDEFINED_VALUE) {
        writable.size = 0;
    }
    const splitZipFile = writer instanceof SplitDataWriter;
    if (!splitZipFile) {
        Object.assign(writer, {
            diskNumber: 0,
            diskOffset: 0,
            availableSize: Infinity,
            maxSize: Infinity
        });
    }
    return writer;
}
function readUint8Array(reader, offset, size, diskNumber) {
    return reader.readUint8Array(offset, size, diskNumber);
}
const CP437 = "\0☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ".split("");
const VALID_CP437 = CP437.length == 256;
function decodeCP437(stringValue) {
    if (VALID_CP437) {
        let result = "";
        for(let indexCharacter = 0; indexCharacter < stringValue.length; indexCharacter++){
            result += CP437[stringValue[indexCharacter]];
        }
        return result;
    } else {
        return new TextDecoder().decode(stringValue);
    }
}
function decodeText(value1, encoding) {
    if (encoding && encoding.trim().toLowerCase() == "cp437") {
        return decodeCP437(value1);
    } else {
        return new TextDecoder(encoding).decode(value1);
    }
}
const PROPERTY_NAME_FILENAME = "filename";
const PROPERTY_NAME_RAW_FILENAME = "rawFilename";
const PROPERTY_NAME_COMMENT = "comment";
const PROPERTY_NAME_RAW_COMMENT = "rawComment";
const PROPERTY_NAME_UNCOMPPRESSED_SIZE = "uncompressedSize";
const PROPERTY_NAME_COMPPRESSED_SIZE = "compressedSize";
const PROPERTY_NAME_OFFSET = "offset";
const PROPERTY_NAME_DISK_NUMBER_START = "diskNumberStart";
const PROPERTY_NAME_LAST_MODIFICATION_DATE = "lastModDate";
const PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE = "rawLastModDate";
const PROPERTY_NAME_LAST_ACCESS_DATE = "lastAccessDate";
const PROPERTY_NAME_RAW_LAST_ACCESS_DATE = "rawLastAccessDate";
const PROPERTY_NAME_CREATION_DATE = "creationDate";
const PROPERTY_NAME_RAW_CREATION_DATE = "rawCreationDate";
const PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE = "internalFileAttribute";
const PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE = "externalFileAttribute";
const PROPERTY_NAME_MS_DOS_COMPATIBLE = "msDosCompatible";
const PROPERTY_NAME_ZIP64 = "zip64";
const PROPERTY_NAMES = [
    PROPERTY_NAME_FILENAME,
    PROPERTY_NAME_RAW_FILENAME,
    PROPERTY_NAME_COMPPRESSED_SIZE,
    PROPERTY_NAME_UNCOMPPRESSED_SIZE,
    PROPERTY_NAME_LAST_MODIFICATION_DATE,
    PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE,
    PROPERTY_NAME_COMMENT,
    PROPERTY_NAME_RAW_COMMENT,
    PROPERTY_NAME_LAST_ACCESS_DATE,
    PROPERTY_NAME_CREATION_DATE,
    PROPERTY_NAME_OFFSET,
    PROPERTY_NAME_DISK_NUMBER_START,
    PROPERTY_NAME_DISK_NUMBER_START,
    PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE,
    PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE,
    PROPERTY_NAME_MS_DOS_COMPATIBLE,
    PROPERTY_NAME_ZIP64,
    "directory",
    "bitFlag",
    "encrypted",
    "signature",
    "filenameUTF8",
    "commentUTF8",
    "compressionMethod",
    "version",
    "versionMadeBy",
    "extraField",
    "rawExtraField",
    "extraFieldZip64",
    "extraFieldUnicodePath",
    "extraFieldUnicodeComment",
    "extraFieldAES",
    "extraFieldNTFS",
    "extraFieldExtendedTimestamp"
];
class Entry {
    constructor(data){
        PROPERTY_NAMES.forEach((name)=>this[name] = data[name]);
    }
}
const ERR_BAD_FORMAT = "File format is not recognized";
const ERR_EOCDR_NOT_FOUND = "End of central directory not found";
const ERR_EOCDR_ZIP64_NOT_FOUND = "End of Zip64 central directory not found";
const ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = "End of Zip64 central directory locator not found";
const ERR_CENTRAL_DIRECTORY_NOT_FOUND = "Central directory header not found";
const ERR_LOCAL_FILE_HEADER_NOT_FOUND = "Local file header not found";
const ERR_EXTRAFIELD_ZIP64_NOT_FOUND = "Zip64 extra field not found";
const ERR_ENCRYPTED = "File contains encrypted entry";
const ERR_UNSUPPORTED_ENCRYPTION = "Encryption method not supported";
const ERR_UNSUPPORTED_COMPRESSION = "Compression method not supported";
const ERR_SPLIT_ZIP_FILE = "Split zip file";
const CHARSET_UTF8 = "utf-8";
const CHARSET_CP437 = "cp437";
const ZIP64_PROPERTIES = [
    [
        PROPERTY_NAME_UNCOMPPRESSED_SIZE,
        0xffffffff
    ],
    [
        PROPERTY_NAME_COMPPRESSED_SIZE,
        0xffffffff
    ],
    [
        PROPERTY_NAME_OFFSET,
        0xffffffff
    ],
    [
        PROPERTY_NAME_DISK_NUMBER_START,
        0xffff
    ]
];
const ZIP64_EXTRACTION = {
    [0xffff]: {
        getValue: getUint32,
        bytes: 4
    },
    [0xffffffff]: {
        getValue: getBigUint64,
        bytes: 8
    }
};
class ZipReader {
    constructor(reader, options = {}){
        Object.assign(this, {
            reader: initReader(reader),
            options,
            config: getConfiguration()
        });
    }
    async *getEntriesGenerator(options = {}) {
        const zipReader = this;
        let { reader } = zipReader;
        const { config } = zipReader;
        await initStream(reader);
        if (reader.size === UNDEFINED_VALUE || !reader.readUint8Array) {
            reader = new BlobReader(await new Response(reader.readable).blob());
            await initStream(reader);
        }
        if (reader.size < 22) {
            throw new Error(ERR_BAD_FORMAT);
        }
        reader.chunkSize = getChunkSize(config);
        const endOfDirectoryInfo = await seekSignature(reader, 0x06054b50, reader.size, 22, 0xffff * 16);
        if (!endOfDirectoryInfo) {
            const signatureArray = await readUint8Array(reader, 0, 4);
            const signatureView = getDataView(signatureArray);
            if (getUint32(signatureView) == 0x08074b50) {
                throw new Error(ERR_SPLIT_ZIP_FILE);
            } else {
                throw new Error(ERR_EOCDR_NOT_FOUND);
            }
        }
        const endOfDirectoryView = getDataView(endOfDirectoryInfo);
        let directoryDataLength = getUint32(endOfDirectoryView, 12);
        let directoryDataOffset = getUint32(endOfDirectoryView, 16);
        const commentOffset = endOfDirectoryInfo.offset;
        const commentLength = getUint16(endOfDirectoryView, 20);
        const appendedDataOffset = commentOffset + 22 + commentLength;
        let lastDiskNumber = getUint16(endOfDirectoryView, 4);
        const expectedLastDiskNumber = reader.lastDiskNumber || 0;
        let diskNumber = getUint16(endOfDirectoryView, 6);
        let filesLength = getUint16(endOfDirectoryView, 8);
        let prependedDataLength = 0;
        let startOffset = 0;
        if (directoryDataOffset == 0xffffffff || directoryDataLength == 0xffffffff || filesLength == 0xffff || diskNumber == 0xffff) {
            const endOfDirectoryLocatorArray = await readUint8Array(reader, endOfDirectoryInfo.offset - 20, 20);
            const endOfDirectoryLocatorView = getDataView(endOfDirectoryLocatorArray);
            if (getUint32(endOfDirectoryLocatorView, 0) != 0x07064b50) {
                throw new Error(ERR_EOCDR_ZIP64_NOT_FOUND);
            }
            directoryDataOffset = getBigUint64(endOfDirectoryLocatorView, 8);
            let endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, 56, -1);
            let endOfDirectoryView = getDataView(endOfDirectoryArray);
            const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - 20 - 56;
            if (getUint32(endOfDirectoryView, 0) != 0x06064b50 && directoryDataOffset != expectedDirectoryDataOffset) {
                const originalDirectoryDataOffset = directoryDataOffset;
                directoryDataOffset = expectedDirectoryDataOffset;
                prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
                endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH, -1);
                endOfDirectoryView = getDataView(endOfDirectoryArray);
            }
            if (getUint32(endOfDirectoryView, 0) != 0x06064b50) {
                throw new Error(ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND);
            }
            if (lastDiskNumber == 0xffff) {
                lastDiskNumber = getUint32(endOfDirectoryView, 16);
            }
            if (diskNumber == 0xffff) {
                diskNumber = getUint32(endOfDirectoryView, 20);
            }
            if (filesLength == 0xffff) {
                filesLength = getBigUint64(endOfDirectoryView, 32);
            }
            if (directoryDataLength == 0xffffffff) {
                directoryDataLength = getBigUint64(endOfDirectoryView, 40);
            }
            directoryDataOffset -= directoryDataLength;
        }
        if (expectedLastDiskNumber != lastDiskNumber) {
            throw new Error(ERR_SPLIT_ZIP_FILE);
        }
        if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
            throw new Error(ERR_BAD_FORMAT);
        }
        let offset = 0;
        let directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
        let directoryView = getDataView(directoryArray);
        if (directoryDataLength) {
            const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - directoryDataLength;
            if (getUint32(directoryView, offset) != 0x02014b50 && directoryDataOffset != expectedDirectoryDataOffset) {
                const originalDirectoryDataOffset = directoryDataOffset;
                directoryDataOffset = expectedDirectoryDataOffset;
                prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
                directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
                directoryView = getDataView(directoryArray);
            }
        }
        const expectedDirectoryDataLength = endOfDirectoryInfo.offset - directoryDataOffset - (reader.lastDiskOffset || 0);
        if (directoryDataLength != expectedDirectoryDataLength && expectedDirectoryDataLength) {
            directoryDataLength = expectedDirectoryDataLength;
            directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
            directoryView = getDataView(directoryArray);
        }
        if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
            throw new Error(ERR_BAD_FORMAT);
        }
        const filenameEncoding = getOptionValue(zipReader, options, "filenameEncoding");
        const commentEncoding = getOptionValue(zipReader, options, "commentEncoding");
        for(let indexFile = 0; indexFile < filesLength; indexFile++){
            const fileEntry = new ZipEntry(reader, config, zipReader.options);
            if (getUint32(directoryView, offset) != 0x02014b50) {
                throw new Error(ERR_CENTRAL_DIRECTORY_NOT_FOUND);
            }
            readCommonHeader(fileEntry, directoryView, offset + 6);
            const languageEncodingFlag = Boolean(fileEntry.bitFlag.languageEncodingFlag);
            const filenameOffset = offset + 46;
            const extraFieldOffset = filenameOffset + fileEntry.filenameLength;
            const commentOffset = extraFieldOffset + fileEntry.extraFieldLength;
            const versionMadeBy = getUint16(directoryView, offset + 4);
            const msDosCompatible = (versionMadeBy & 0) == 0;
            const rawFilename = directoryArray.subarray(filenameOffset, extraFieldOffset);
            const commentLength = getUint16(directoryView, offset + 32);
            const endOffset = commentOffset + commentLength;
            const rawComment = directoryArray.subarray(commentOffset, endOffset);
            const filenameUTF8 = languageEncodingFlag;
            const commentUTF8 = languageEncodingFlag;
            const directory = msDosCompatible && (getUint8(directoryView, offset + 38) & 0x10) == 0x10;
            const offsetFileEntry = getUint32(directoryView, offset + 42) + prependedDataLength;
            Object.assign(fileEntry, {
                versionMadeBy,
                msDosCompatible,
                compressedSize: 0,
                uncompressedSize: 0,
                commentLength,
                directory,
                offset: offsetFileEntry,
                diskNumberStart: getUint16(directoryView, offset + 34),
                internalFileAttribute: getUint16(directoryView, offset + 36),
                externalFileAttribute: getUint32(directoryView, offset + 38),
                rawFilename,
                filenameUTF8,
                commentUTF8,
                rawExtraField: directoryArray.subarray(extraFieldOffset, commentOffset)
            });
            const [filename, comment] = await Promise.all([
                decodeText(rawFilename, filenameUTF8 ? CHARSET_UTF8 : filenameEncoding || CHARSET_CP437),
                decodeText(rawComment, commentUTF8 ? CHARSET_UTF8 : commentEncoding || CHARSET_CP437)
            ]);
            Object.assign(fileEntry, {
                rawComment,
                filename,
                comment,
                directory: directory || filename.endsWith(DIRECTORY_SIGNATURE)
            });
            startOffset = Math.max(offsetFileEntry, startOffset);
            await readCommonFooter(fileEntry, fileEntry, directoryView, offset + 6);
            const entry = new Entry(fileEntry);
            entry.getData = (writer, options)=>fileEntry.getData(writer, entry, options);
            offset = endOffset;
            const { onprogress } = options;
            if (onprogress) {
                try {
                    await onprogress(indexFile + 1, filesLength, new Entry(fileEntry));
                } catch (_error) {}
            }
            yield entry;
        }
        const extractPrependedData = getOptionValue(zipReader, options, "extractPrependedData");
        const extractAppendedData = getOptionValue(zipReader, options, "extractAppendedData");
        if (extractPrependedData) {
            zipReader.prependedData = startOffset > 0 ? await readUint8Array(reader, 0, startOffset) : new Uint8Array();
        }
        zipReader.comment = commentLength ? await readUint8Array(reader, commentOffset + END_OF_CENTRAL_DIR_LENGTH, commentLength) : new Uint8Array();
        if (extractAppendedData) {
            zipReader.appendedData = appendedDataOffset < reader.size ? await readUint8Array(reader, appendedDataOffset, reader.size - appendedDataOffset) : new Uint8Array();
        }
        return true;
    }
    async getEntries(options = {}) {
        const entries = [];
        for await (const entry of this.getEntriesGenerator(options)){
            entries.push(entry);
        }
        return entries;
    }
    async close() {}
}
class ZipEntry {
    constructor(reader, config, options){
        Object.assign(this, {
            reader,
            config,
            options
        });
    }
    async getData(writer, fileEntry, options = {}) {
        const zipEntry = this;
        const { reader, offset, diskNumberStart, extraFieldAES, compressionMethod, config, bitFlag, signature, rawLastModDate, uncompressedSize, compressedSize } = zipEntry;
        const localDirectory = zipEntry.localDirectory = {};
        const dataArray = await readUint8Array(reader, offset, 30, diskNumberStart);
        const dataView = getDataView(dataArray);
        let password = getOptionValue(zipEntry, options, "password");
        password = password && password.length && password;
        if (extraFieldAES) {
            if (extraFieldAES.originalCompressionMethod != 0x63) {
                throw new Error(ERR_UNSUPPORTED_COMPRESSION);
            }
        }
        if (compressionMethod != 0x00 && compressionMethod != 0x08) {
            throw new Error(ERR_UNSUPPORTED_COMPRESSION);
        }
        if (getUint32(dataView, 0) != 0x04034b50) {
            throw new Error(ERR_LOCAL_FILE_HEADER_NOT_FOUND);
        }
        readCommonHeader(localDirectory, dataView, 4);
        localDirectory.rawExtraField = localDirectory.extraFieldLength ? await readUint8Array(reader, offset + 30 + localDirectory.filenameLength, localDirectory.extraFieldLength, diskNumberStart) : new Uint8Array();
        await readCommonFooter(zipEntry, localDirectory, dataView, 4);
        Object.assign(fileEntry, {
            lastAccessDate: localDirectory.lastAccessDate,
            creationDate: localDirectory.creationDate
        });
        const encrypted = zipEntry.encrypted && localDirectory.encrypted;
        const zipCrypto = encrypted && !extraFieldAES;
        if (encrypted) {
            if (!zipCrypto && extraFieldAES.strength === UNDEFINED_VALUE) {
                throw new Error(ERR_UNSUPPORTED_ENCRYPTION);
            } else if (!password) {
                throw new Error(ERR_ENCRYPTED);
            }
        }
        const dataOffset = offset + 30 + localDirectory.filenameLength + localDirectory.extraFieldLength;
        const size = compressedSize;
        const readable = reader.readable;
        Object.assign(readable, {
            diskNumberStart,
            offset: dataOffset,
            size
        });
        const signal = getOptionValue(zipEntry, options, "signal");
        const checkPasswordOnly = getOptionValue(zipEntry, options, "checkPasswordOnly");
        if (checkPasswordOnly) {
            writer = new WritableStream();
        }
        writer = initWriter(writer);
        await initStream(writer, uncompressedSize);
        const { writable } = writer;
        const { onstart, onprogress, onend } = options;
        const workerOptions = {
            options: {
                codecType: CODEC_INFLATE,
                password,
                zipCrypto,
                encryptionStrength: extraFieldAES && extraFieldAES.strength,
                signed: getOptionValue(zipEntry, options, "checkSignature"),
                passwordVerification: zipCrypto && (bitFlag.dataDescriptor ? rawLastModDate >>> 8 & 0xFF : signature >>> 24 & 0xFF),
                signature,
                compressed: compressionMethod != 0,
                encrypted,
                useWebWorkers: getOptionValue(zipEntry, options, "useWebWorkers"),
                useCompressionStream: getOptionValue(zipEntry, options, "useCompressionStream"),
                transferStreams: getOptionValue(zipEntry, options, "transferStreams"),
                checkPasswordOnly
            },
            config,
            streamOptions: {
                signal,
                size,
                onstart,
                onprogress,
                onend
            }
        };
        let outputSize = 0;
        try {
            ({ outputSize } = await runWorker1({
                readable,
                writable
            }, workerOptions));
        } catch (error) {
            if (!checkPasswordOnly || error.message != ERR_ABORT_CHECK_PASSWORD) {
                throw error;
            }
        } finally{
            const preventClose = getOptionValue(zipEntry, options, "preventClose");
            writable.size += outputSize;
            if (!preventClose && !writable.locked) {
                await writable.getWriter().close();
            }
        }
        return checkPasswordOnly ? undefined : writer.getData ? writer.getData() : writable;
    }
}
function readCommonHeader(directory, dataView, offset) {
    const rawBitFlag = directory.rawBitFlag = getUint16(dataView, offset + 2);
    const encrypted = (rawBitFlag & 0x01) == 0x01;
    const rawLastModDate = getUint32(dataView, offset + 6);
    Object.assign(directory, {
        encrypted,
        version: getUint16(dataView, offset),
        bitFlag: {
            level: (rawBitFlag & 0x06) >> 1,
            dataDescriptor: (rawBitFlag & 0x0008) == 0x0008,
            languageEncodingFlag: (rawBitFlag & 0x0800) == 0x0800
        },
        rawLastModDate,
        lastModDate: getDate(rawLastModDate),
        filenameLength: getUint16(dataView, offset + 22),
        extraFieldLength: getUint16(dataView, offset + 24)
    });
}
async function readCommonFooter(fileEntry, directory, dataView, offset) {
    const { rawExtraField } = directory;
    const extraField = directory.extraField = new Map();
    const rawExtraFieldView = getDataView(new Uint8Array(rawExtraField));
    let offsetExtraField = 0;
    try {
        while(offsetExtraField < rawExtraField.length){
            const type = getUint16(rawExtraFieldView, offsetExtraField);
            const size = getUint16(rawExtraFieldView, offsetExtraField + 2);
            extraField.set(type, {
                type,
                data: rawExtraField.slice(offsetExtraField + 4, offsetExtraField + 4 + size)
            });
            offsetExtraField += 4 + size;
        }
    } catch (_error) {}
    const compressionMethod = getUint16(dataView, offset + 4);
    Object.assign(directory, {
        signature: getUint32(dataView, offset + 10),
        uncompressedSize: getUint32(dataView, offset + 18),
        compressedSize: getUint32(dataView, offset + 14)
    });
    const extraFieldZip64 = extraField.get(0x0001);
    if (extraFieldZip64) {
        readExtraFieldZip64(extraFieldZip64, directory);
        directory.extraFieldZip64 = extraFieldZip64;
    }
    const extraFieldUnicodePath = extraField.get(0x7075);
    if (extraFieldUnicodePath) {
        await readExtraFieldUnicode(extraFieldUnicodePath, PROPERTY_NAME_FILENAME, PROPERTY_NAME_RAW_FILENAME, directory, fileEntry);
        directory.extraFieldUnicodePath = extraFieldUnicodePath;
    }
    const extraFieldUnicodeComment = extraField.get(0x6375);
    if (extraFieldUnicodeComment) {
        await readExtraFieldUnicode(extraFieldUnicodeComment, PROPERTY_NAME_COMMENT, PROPERTY_NAME_RAW_COMMENT, directory, fileEntry);
        directory.extraFieldUnicodeComment = extraFieldUnicodeComment;
    }
    const extraFieldAES = extraField.get(0x9901);
    if (extraFieldAES) {
        readExtraFieldAES(extraFieldAES, directory, compressionMethod);
        directory.extraFieldAES = extraFieldAES;
    } else {
        directory.compressionMethod = compressionMethod;
    }
    const extraFieldNTFS = extraField.get(0x000a);
    if (extraFieldNTFS) {
        readExtraFieldNTFS(extraFieldNTFS, directory);
        directory.extraFieldNTFS = extraFieldNTFS;
    }
    const extraFieldExtendedTimestamp = extraField.get(0x5455);
    if (extraFieldExtendedTimestamp) {
        readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory);
        directory.extraFieldExtendedTimestamp = extraFieldExtendedTimestamp;
    }
}
function readExtraFieldZip64(extraFieldZip64, directory) {
    directory.zip64 = true;
    const extraFieldView = getDataView(extraFieldZip64.data);
    const missingProperties = ZIP64_PROPERTIES.filter(([propertyName, max])=>directory[propertyName] == max);
    for(let indexMissingProperty = 0, offset = 0; indexMissingProperty < missingProperties.length; indexMissingProperty++){
        const [propertyName, max] = missingProperties[indexMissingProperty];
        if (directory[propertyName] == max) {
            const extraction = ZIP64_EXTRACTION[max];
            directory[propertyName] = extraFieldZip64[propertyName] = extraction.getValue(extraFieldView, offset);
            offset += extraction.bytes;
        } else if (extraFieldZip64[propertyName]) {
            throw new Error(ERR_EXTRAFIELD_ZIP64_NOT_FOUND);
        }
    }
}
async function readExtraFieldUnicode(extraFieldUnicode, propertyName, rawPropertyName, directory, fileEntry) {
    const extraFieldView = getDataView(extraFieldUnicode.data);
    const crc32 = new Crc32();
    crc32.append(fileEntry[rawPropertyName]);
    const dataViewSignature = getDataView(new Uint8Array(4));
    dataViewSignature.setUint32(0, crc32.get(), true);
    const signature = getUint32(extraFieldView, 1);
    Object.assign(extraFieldUnicode, {
        version: getUint8(extraFieldView, 0),
        [propertyName]: decodeText(extraFieldUnicode.data.subarray(5)),
        valid: !fileEntry.bitFlag.languageEncodingFlag && signature == getUint32(dataViewSignature, 0)
    });
    if (extraFieldUnicode.valid) {
        directory[propertyName] = extraFieldUnicode[propertyName];
        directory[propertyName + "UTF8"] = true;
    }
}
function readExtraFieldAES(extraFieldAES, directory, compressionMethod) {
    const extraFieldView = getDataView(extraFieldAES.data);
    const strength = getUint8(extraFieldView, 4);
    Object.assign(extraFieldAES, {
        vendorVersion: getUint8(extraFieldView, 0),
        vendorId: getUint8(extraFieldView, 2),
        strength,
        originalCompressionMethod: compressionMethod,
        compressionMethod: getUint16(extraFieldView, 5)
    });
    directory.compressionMethod = extraFieldAES.compressionMethod;
}
function readExtraFieldNTFS(extraFieldNTFS, directory) {
    const extraFieldView = getDataView(extraFieldNTFS.data);
    let offsetExtraField = 4;
    let tag1Data;
    try {
        while(offsetExtraField < extraFieldNTFS.data.length && !tag1Data){
            const tagValue = getUint16(extraFieldView, offsetExtraField);
            const attributeSize = getUint16(extraFieldView, offsetExtraField + 2);
            if (tagValue == 0x0001) {
                tag1Data = extraFieldNTFS.data.slice(offsetExtraField + 4, offsetExtraField + 4 + attributeSize);
            }
            offsetExtraField += 4 + attributeSize;
        }
    } catch (_error) {}
    try {
        if (tag1Data && tag1Data.length == 24) {
            const tag1View = getDataView(tag1Data);
            const rawLastModDate = tag1View.getBigUint64(0, true);
            const rawLastAccessDate = tag1View.getBigUint64(8, true);
            const rawCreationDate = tag1View.getBigUint64(16, true);
            Object.assign(extraFieldNTFS, {
                rawLastModDate,
                rawLastAccessDate,
                rawCreationDate
            });
            const lastModDate = getDateNTFS(rawLastModDate);
            const lastAccessDate = getDateNTFS(rawLastAccessDate);
            const creationDate = getDateNTFS(rawCreationDate);
            const extraFieldData = {
                lastModDate,
                lastAccessDate,
                creationDate
            };
            Object.assign(extraFieldNTFS, extraFieldData);
            Object.assign(directory, extraFieldData);
        }
    } catch (_error) {}
}
function readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory) {
    const extraFieldView = getDataView(extraFieldExtendedTimestamp.data);
    const flags = getUint8(extraFieldView, 0);
    const timeProperties = [];
    const timeRawProperties = [];
    if ((flags & 0x1) == 0x1) {
        timeProperties.push(PROPERTY_NAME_LAST_MODIFICATION_DATE);
        timeRawProperties.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE);
    }
    if ((flags & 0x2) == 0x2) {
        timeProperties.push(PROPERTY_NAME_LAST_ACCESS_DATE);
        timeRawProperties.push(PROPERTY_NAME_RAW_LAST_ACCESS_DATE);
    }
    if ((flags & 0x4) == 0x4) {
        timeProperties.push(PROPERTY_NAME_CREATION_DATE);
        timeRawProperties.push(PROPERTY_NAME_RAW_CREATION_DATE);
    }
    let offset = 1;
    timeProperties.forEach((propertyName, indexProperty)=>{
        if (extraFieldExtendedTimestamp.data.length >= offset + 4) {
            const time = getUint32(extraFieldView, offset);
            directory[propertyName] = extraFieldExtendedTimestamp[propertyName] = new Date(time * 1000);
            const rawPropertyName = timeRawProperties[indexProperty];
            extraFieldExtendedTimestamp[rawPropertyName] = time;
        }
        offset += 4;
    });
}
async function seekSignature(reader, signature, startOffset, minimumBytes, maximumLength) {
    const signatureArray = new Uint8Array(4);
    const signatureView = getDataView(signatureArray);
    setUint32(signatureView, 0, signature);
    const maximumBytes = minimumBytes + maximumLength;
    return await seek(minimumBytes) || await seek(Math.min(maximumBytes, startOffset));
    async function seek(length) {
        const offset = startOffset - length;
        const bytes = await readUint8Array(reader, offset, length);
        for(let indexByte = bytes.length - minimumBytes; indexByte >= 0; indexByte--){
            if (bytes[indexByte] == signatureArray[0] && bytes[indexByte + 1] == signatureArray[1] && bytes[indexByte + 2] == signatureArray[2] && bytes[indexByte + 3] == signatureArray[3]) {
                return {
                    offset: offset + indexByte,
                    buffer: bytes.slice(indexByte, indexByte + minimumBytes).buffer
                };
            }
        }
    }
}
function getOptionValue(zipReader, options, name) {
    return options[name] === UNDEFINED_VALUE ? zipReader.options[name] : options[name];
}
function getDate(timeRaw) {
    const date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;
    try {
        return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5, (time & 0x001F) * 2, 0);
    } catch (_error) {}
}
function getDateNTFS(timeRaw) {
    return new Date(Number(timeRaw / BigInt(10000) - BigInt(11644473600000)));
}
function getUint8(view, offset) {
    return view.getUint8(offset);
}
function getUint16(view, offset) {
    return view.getUint16(offset, true);
}
function getUint32(view, offset) {
    return view.getUint32(offset, true);
}
function getBigUint64(view, offset) {
    return Number(view.getBigUint64(offset, true));
}
function setUint32(view, offset, value1) {
    view.setUint32(offset, value1, true);
}
function getDataView(array) {
    return new DataView(array.buffer);
}
new Uint8Array([
    0x07,
    0x00,
    0x02,
    0x00,
    0x41,
    0x45,
    0x03,
    0x00,
    0x00
]);
const importMeta2 = {
    url: "https://deno.land/x/zipjs@v2.7.17/lib/zip-fs.js",
    main: false
};
let baseURL;
try {
    baseURL = importMeta2.url;
} catch (_error) {}
configure({
    baseURL
});
e(configure);
configure({
    Deflate: ZipDeflate,
    Inflate: ZipInflate
});
const BusinessTypes = {
    A25: "General Capacity Information",
    A29: "Already allocated capacity (AAC)",
    A43: "Requested capacity (without price)",
    A46: "System Operator redispatching",
    A53: "Planned maintenance",
    A54: "Unplanned outage",
    A85: "Internal redispatch",
    A95: "Frequency containment reserve",
    A96: "Automatic frequency restoration reserve",
    A97: "Manual frequency restoration reserve",
    A98: "Replacement reserve",
    B01: "Interconnector network evolution",
    B02: "Interconnector network dismantling",
    B03: "Counter trade",
    B04: "Congestion costs",
    B05: "Capacity allocated (including price)",
    B07: "Auction revenue",
    B08: "Total nominated capacity",
    B09: "Net position",
    B10: "Congestion income",
    B11: "Production unit",
    B33: "Area Control Error",
    B74: "Offer",
    B75: "Need",
    B95: "Procured capacity",
    C22: "Shared Balancing Reserve Capacity",
    C23: "Share of reserve capacity",
    C24: "Actual reserve capacity"
};
const ISO8601DurToSec = (pt)=>{
    pt = pt.toUpperCase().trim();
    switch(pt){
        case "PT60M":
            return 3600;
        case "PT30M":
            return 1800;
        case "PT15M":
            return 900;
        case "PT1M":
            return 60;
        case "P1D":
            return 86400;
    }
    const iso8601DurationRegex = /(-)?P(?:([.,\d]+)Y)?(?:([.,\d]+)M)?(?:([.,\d]+)W)?(?:([.,\d]+)D)?T(?:([.,\d]+)H)?(?:([.,\d]+)M)?(?:([.,\d]+)S)?/;
    const matches = pt.match(iso8601DurationRegex);
    if (matches === null) {
        throw new Error("Could not parse ISO8601 duration string '" + pt + "'");
    } else if (parseFloat(matches[2]) > 0 || parseFloat(matches[3]) > 0 || parseFloat(matches[4]) > 0 || parseFloat(matches[5]) > 0) {
        throw new Error("Could not parse ISO8601 duration string '" + pt + "', only days and smaller specifiers supported in this implementation.");
    } else {
        return ((matches[6] === undefined ? 0 : parseFloat(matches[6]) * 3600) + (matches[7] === undefined ? 0 : parseFloat(matches[7])) * 60 + (matches[8] === undefined ? 0 : parseFloat(matches[8]))) * (matches[1] === undefined ? 1 : -1);
    }
};
const ProcessTypes = {
    A01: "Day ahead",
    A02: "Intra day incremental",
    A16: "Realised",
    A18: "Intraday total",
    A31: "Week ahead",
    A32: "Month ahead",
    A33: "Year ahead",
    A39: "Synchronisation process",
    A40: "Intraday process",
    A46: "Replacement reserve",
    A47: "Manual frequency restoration reserve",
    A51: "Automatic frequency restoration reserve",
    A52: "Frequency containment reserve",
    A56: "Frequency restoration reserve",
    A60: "Scheduled activation mFRR",
    A61: "Direct activation mFRR",
    A67: "Central Selection aFRR",
    A68: "Local Selection aFRR"
};
const ParsePeriod = (period)=>{
    const baseDate = Date.parse(period.timeInterval.start), baseEndDate = Date.parse(period.timeInterval.end), periodLengthS = ISO8601DurToSec(period.resolution), periodLengthSSafe = periodLengthS || 1;
    const outputPeriod = {
        startDate: new Date(baseDate),
        endDate: new Date(baseEndDate),
        points: [],
        resolution: period.resolution,
        resolutionSeconds: periodLengthSSafe
    };
    const points = Array.isArray(period.Point) ? period.Point : [
        period.Point
    ];
    for(let i = 0; i < points.length; i++){
        const currentPos = points[i].position - 1, nextPos = points[i + 1] ? points[i + 1].position - 1 : undefined;
        const outputPoint = {
            startDate: new Date(baseDate + currentPos * periodLengthSSafe * 1000),
            endDate: nextPos ? new Date(baseDate + nextPos * periodLengthSSafe * 1000) : new Date(baseEndDate),
            position: points[i].position,
            constraintTimeSeries: points[i].Constraint_TimeSeries
        };
        if (points[i]["price.amount"]) {
            outputPoint.price = points[i]["price.amount"];
        }
        if (points[i].quantity) {
            outputPoint.quantity = points[i].quantity;
        }
        outputPeriod.points.push(outputPoint);
    }
    return outputPeriod;
};
const ParseBaseDocument = (d)=>{
    const document = {
        mRID: d.mRID,
        revision: d.revisionNumber,
        created: d.createdDateTime ? new Date(Date.parse(d.createdDateTime)) : void 0,
        documentType: d.type,
        documentTypeDescription: d.type ? DocumentTypes[d.type] : void 0,
        processType: d["process.processType"],
        processTypeDescription: d["process.processType"] ? ProcessTypes[d["process.processType"]] : void 0,
        senderMarketParticipantId: d["sender_MarketParticipant.mRID"]?.["#text"],
        senderMarketParticipantRoleType: d["sender_MarketParticipant.marketRole.type"],
        receiverMarketParticipantId: d["receiver_MarketParticipant.mRID"]?.["#text"],
        receiverMarketParticipantRoleType: d["receiver_MarketParticipant.marketRole.type"]
    };
    return document;
};
const ParsePublication = (d)=>{
    if (!d.TimeSeries) {
        throw new Error("Publication document invalid, missing TimeSeries");
    }
    const tsArray = Array.isArray(d.TimeSeries) ? d.TimeSeries : [
        d.TimeSeries
    ];
    let timeInterval = void 0;
    if (d["period.timeInterval"]?.start && d["period.timeInterval"].end) {
        timeInterval = {
            start: new Date(Date.parse(d["period.timeInterval"]?.start)),
            end: new Date(Date.parse(d["period.timeInterval"]?.end))
        };
    }
    const document = Object.assign(ParseBaseDocument(d), {
        rootType: "publication",
        timeInterval,
        timeseries: []
    });
    for (const ts of tsArray){
        const tsEntry = {
            currency: ts["currency_Unit.name"],
            priceMeasureUnit: ts["price_Measure_Unit.name"],
            quantityMeasureUnit: ts["quantity_Measure_Unit.name"],
            curveType: ts.curveType,
            businessType: ts.businessType,
            inDomain: ts["in_Domain.mRID"]?.["#text"],
            outDomain: ts["out_Domain.mRID"]?.["#text"],
            auctionId: ts["auction.mRID"],
            auctionType: ts["auction.type"],
            auctionCategory: ts["auction.category"],
            contractMarketAgreementType: ts["contract_MarketAgreement.type"],
            classificationSequenceAICPosition: ts["classificationSequence_AttributeInstanceComponent.position"],
            businessTypeDescription: ts.businessType ? BusinessTypes[ts.businessType] : void 0,
            periods: []
        };
        const periodArray = Array.isArray(ts.Period) ? ts.Period : ts.Period ? [
            ts.Period
        ] : [];
        for (const inputPeriod of periodArray){
            tsEntry.periods?.push(ParsePeriod(inputPeriod));
        }
        document.timeseries.push(tsEntry);
    }
    return document;
};
const PsrTypes = {
    A03: "Mixed",
    A04: "Generation",
    A05: "Load",
    B01: "Biomass",
    B02: "Fossil Brown coal/Lignite",
    B03: "Fossil Coal-derived gas",
    B04: "Fossil Gas",
    B05: "Fossil Hard coal",
    B06: "Fossil Oil",
    B07: "Fossil Oil shale",
    B08: "Fossil Peat",
    B09: "Geothermal",
    B10: "Hydro Pumped Storage",
    B11: "Hydro Run-of-river and poundage",
    B12: "Hydro Water Reservoir",
    B13: "Marine",
    B14: "Nuclear",
    B15: "Other renewable",
    B16: "Solar",
    B17: "Waste",
    B18: "Wind Offshore",
    B19: "Wind Onshore",
    B20: "Other",
    B21: "AC Link",
    B22: "DC Link",
    B23: "Substation",
    B24: "Transformer"
};
const ParseGL = (d)=>{
    if (!d.TimeSeries) {
        throw new Error("GL document invalid, missing TimeSeries");
    }
    const tsArray = Array.isArray(d.TimeSeries) ? d.TimeSeries : [
        d.TimeSeries
    ];
    let timeInterval = void 0;
    if (d["time_Period.timeInterval"]?.start && d["time_Period.timeInterval"].end) {
        timeInterval = {
            start: new Date(Date.parse(d["time_Period.timeInterval"]?.start)),
            end: new Date(Date.parse(d["time_Period.timeInterval"]?.end))
        };
    }
    const document = Object.assign(ParseBaseDocument(d), {
        rootType: "gl",
        timeInterval,
        timeseries: []
    });
    for (const ts of tsArray){
        const tsEntry = {
            outBiddingZone: ts["outBiddingZone_Domain.mRID"]?.["#text"],
            inBiddingZone: ts["inBiddingZone_Domain.mRID"]?.["#text"],
            curveType: ts.curveType,
            objectAggregation: ts.objectAggregation,
            mktPsrType: ts.MktPSRType?.psrType,
            businessType: ts.businessType,
            businessTypeDescription: ts.businessType ? BusinessTypes[ts.businessType] : void 0,
            mktPsrTypeDescription: ts.MktPSRType?.psrType ? PsrTypes[ts.MktPSRType?.psrType] : void 0,
            quantityMeasureUnit: ts["quantity_Measure_Unit.name"],
            periods: []
        };
        const periodArray = Array.isArray(ts.Period) ? ts.Period : ts.Period ? [
            ts.Period
        ] : [];
        for (const inputPeriod of periodArray){
            tsEntry.periods?.push(ParsePeriod(inputPeriod));
        }
        document.timeseries.push(tsEntry);
    }
    return document;
};
const ParseUnavailability = (d)=>{
    if (!d.TimeSeries) {
        throw new Error("Unavalibility document invalid, missing TimeSeries");
    }
    const tsArray = Array.isArray(d.TimeSeries) ? d.TimeSeries : [
        d.TimeSeries
    ];
    let timeInterval = void 0;
    if (d["unavailability_Time_Period.timeInterval"]?.start && d["unavailability_Time_Period.timeInterval"].end) {
        timeInterval = {
            start: new Date(Date.parse(d["unavailability_Time_Period.timeInterval"]?.start)),
            end: new Date(Date.parse(d["unavailability_Time_Period.timeInterval"]?.end))
        };
    }
    const document = Object.assign(ParseBaseDocument(d), {
        rootType: "unavailability",
        timeInterval,
        timeseries: []
    });
    for (const outage of tsArray){
        let startDate;
        if (outage["start_DateAndOrTime.date"]) {
            if (outage["start_DateAndOrTime.time"]) {
                startDate = new Date(Date.parse(outage["start_DateAndOrTime.date"] + "T" + outage["start_DateAndOrTime.time"]));
            } else {
                startDate = new Date(Date.parse(outage["start_DateAndOrTime.date"] + "T00:00:00Z"));
            }
        }
        let endDate;
        if (outage["end_DateAndOrTime.date"]) {
            if (outage["end_DateAndOrTime.time"]) {
                endDate = new Date(Date.parse(outage["end_DateAndOrTime.date"] + "T" + outage["start_DateAndOrTime.time"]));
            } else {
                endDate = new Date(Date.parse(outage["end_DateAndOrTime.date"] + "T00:00:00Z"));
            }
        }
        const ts = Object.assign(ParseBaseDocument(d), {
            startDate: startDate,
            endDate: endDate,
            rootType: "unavailability",
            resourceName: outage["production_RegisteredResource.name"],
            resourceLocation: outage["production_RegisteredResource.location.name"],
            businessType: outage.businessType,
            businessTypeDescription: outage.businessType ? BusinessTypes[outage.businessType] : void 0,
            psrName: outage["production_RegisteredResource.pSRType.powerSystemResources.name"],
            psrNominalPowerUnit: outage["production_RegisteredResource.pSRType.powerSystemResources.nominalP"] ? outage["production_RegisteredResource.pSRType.powerSystemResources.nominalP"]["@unit"] : void 0,
            psrNominalPower: outage["production_RegisteredResource.pSRType.powerSystemResources.nominalP"] ? outage["production_RegisteredResource.pSRType.powerSystemResources.nominalP"]["#text"] : "0",
            psrType: outage["production_RegisteredResource.pSRType.psrType"] ? PsrTypes[outage["production_RegisteredResource.pSRType.psrType"]] : void 0,
            reasonCode: outage.Reason?.code,
            reasonText: outage.Reason?.text,
            periods: []
        });
        const availablePeriodArray = Array.isArray(outage.Available_Period) ? outage.Available_Period : outage.Available_Period ? [
            outage.Available_Period
        ] : [];
        for (const avail of availablePeriodArray){
            ts.periods?.push(ParsePeriod(avail));
        }
        document.timeseries.push(ts);
    }
    return document;
};
const ParseConfiguration = (d)=>{
    if (!d.TimeSeries) {
        throw new Error("Unavalibility document invalid, missing TimeSeries");
    }
    const tsArray = Array.isArray(d.TimeSeries) ? d.TimeSeries : [
        d.TimeSeries
    ];
    const document = Object.assign(ParseBaseDocument(d), {
        rootType: "configuration",
        timeseries: []
    });
    for (const configuration of tsArray){
        let implementationDate;
        if (configuration["implementation_DateAndOrTime.date"]) {
            if (configuration["implementation_DateAndOrTime.time"]) {
                implementationDate = new Date(Date.parse(configuration["implementation_DateAndOrTime.date"] + "T" + configuration["implementation_DateAndOrTime.time"]));
            } else {
                implementationDate = new Date(Date.parse(configuration["implementation_DateAndOrTime.date"] + "T00:00:00Z"));
            }
        }
        const ts = Object.assign(ParseBaseDocument(d), {
            implementationDate,
            businessType: configuration.businessType,
            businessTypeDescription: configuration.businessType ? BusinessTypes[configuration.businessType] : void 0,
            biddingZoneDomain: configuration["biddingZone_Domain.mRID"]?.["#text"],
            registeredResourceId: configuration["registeredResource.mRID"]?.["#text"],
            registeredResourceName: configuration["registeredResource.name"],
            registeredResourceLocation: configuration["registeredResource.location.name"],
            controlAreaDomain: configuration.ControlArea_Domain?.mRID?.["#text"],
            providerMarketParticipant: configuration["Provider_MarketParticipant"]?.mRID?.["#text"],
            psrType: configuration.MktPSRType?.psrType,
            psrHighvoltageLimit: configuration.MktPSRType?.["production_PowerSystemResources.highVoltageLimit"]?.["#text"],
            psrHighvoltageLimitUnit: configuration.MktPSRType?.["production_PowerSystemResources.highVoltageLimit"]?.["@unit"],
            psrNominalPower: configuration.MktPSRType?.["nominalIP_PowerSystemResources.nominalP"]?.["#text"],
            psrNominalPowerUnit: configuration.MktPSRType?.["nominalIP_PowerSystemResources.nominalP"]?.["@unit"],
            generatingUnit: []
        });
        if (configuration.GeneratingUnit_PowerSystemResources?.length) {
            for (const gu of configuration.GeneratingUnit_PowerSystemResources){
                const guResult = {
                    nominalPower: gu.nominalP?.["#text"],
                    nominalPowerUnit: gu.nominalP?.["@unit"],
                    name: gu.name,
                    locationName: gu["generatingUnit_Location.name"],
                    psrType: gu["generatingUnit_PSRType.psrType"],
                    id: gu.mRID?.["#text"]
                };
                ts.generatingUnit?.push(guResult);
            }
        }
        document.timeseries.push(ts);
    }
    return document;
};
const ParseTransmissionNetwork = (d)=>{
    if (!d.TimeSeries) {
        throw new Error("TransmissionNetwork document invalid, missing TimeSeries");
    }
    const tsArray = Array.isArray(d.TimeSeries) ? d.TimeSeries : [
        d.TimeSeries
    ];
    let timeInterval = void 0;
    if (d["period.timeInterval"]?.start && d["period.timeInterval"].end) {
        timeInterval = {
            start: new Date(Date.parse(d["period.timeInterval"]?.start)),
            end: new Date(Date.parse(d["period.timeInterval"]?.end))
        };
    }
    const document = Object.assign(ParseBaseDocument(d), {
        rootType: "transmissionnetwork",
        timeInterval,
        timeseries: []
    });
    for (const ts of tsArray){
        let endDate;
        if (ts["end_DateAndOrTime.date"]) {
            if (ts["end_DateAndOrTime.time"]) {
                endDate = new Date(Date.parse(ts["end_DateAndOrTime.date"] + "T" + ts["end_DateAndOrTime.time"]));
            } else {
                endDate = new Date(Date.parse(ts["end_DateAndOrTime.date"] + "T00:00:00Z"));
            }
        }
        const tsEntry = {
            endDate: endDate,
            quantityMeasureUnit: ts["quantity_Measure_Unit.name"],
            curveType: ts.curveType,
            businessType: ts.businessType,
            inDomain: ts["in_Domain.mRID"]?.["#text"],
            outDomain: ts["out_Domain.mRID"]?.["#text"],
            businessTypeDescription: ts.businessType ? BusinessTypes[ts.businessType] : void 0,
            assetRegisteredResourceId: ts.Asset_RegisteredResource?.mRID?.["#text"],
            assetRegisteredResourcePsrType: ts.Asset_RegisteredResource?.["pSRType.psrType"],
            assetRegisteredResourcePsrTypeDescription: ts.Asset_RegisteredResource?.["pSRType.psrType"] ? PsrTypes[ts.Asset_RegisteredResource?.["pSRType.psrType"]] : void 0,
            assetRegisteredResourceLocationName: ts.Asset_RegisteredResource?.["location.name"],
            periods: []
        };
        const periodArray = Array.isArray(ts.Period) ? ts.Period : ts.Period ? [
            ts.Period
        ] : [];
        for (const inputPeriod of periodArray){
            tsEntry.periods?.push(ParsePeriod(inputPeriod));
        }
        document.timeseries.push(tsEntry);
    }
    return document;
};
const ParseBalancing = (d)=>{
    if (!d.TimeSeries) {
        throw new Error("Balancing document invalid, missing TimeSeries");
    }
    const tsArray = Array.isArray(d.TimeSeries) ? d.TimeSeries : [
        d.TimeSeries
    ];
    let timeInterval = void 0;
    if (d["period.timeInterval"]?.start && d["period.timeInterval"].end) {
        timeInterval = {
            start: new Date(Date.parse(d["period.timeInterval"]?.start)),
            end: new Date(Date.parse(d["period.timeInterval"]?.end))
        };
    }
    const document = Object.assign(ParseBaseDocument(d), {
        rootType: "balancing",
        areaDomainId: d["area_Domain.mRID"]?.["#text"],
        timeInterval,
        timeseries: []
    });
    for (const ts of tsArray){
        const tsEntry = {
            quantityMeasureUnit: ts["quantity_Measure_Unit.name"],
            curveType: ts.curveType,
            businessType: ts.businessType,
            flowDirection: ts["flowDirection.direction"],
            businessTypeDescription: ts.businessType ? BusinessTypes[ts.businessType] : void 0,
            periods: []
        };
        const periodArray = Array.isArray(ts.Period) ? ts.Period : ts.Period ? [
            ts.Period
        ] : [];
        for (const inputPeriod of periodArray){
            tsEntry.periods?.push(ParsePeriod(inputPeriod));
        }
        document.timeseries.push(tsEntry);
    }
    return document;
};
const ParseCriticalNetworkElement = (d)=>{
    if (!d.TimeSeries) {
        throw new Error("CriticalNetworkElement document invalid, missing TimeSeries");
    }
    const tsArray = Array.isArray(d.TimeSeries) ? d.TimeSeries : [
        d.TimeSeries
    ];
    let timeInterval = void 0;
    if (d["time_Period.timeInterval"]?.start && d["time_Period.timeInterval"].end) {
        timeInterval = {
            start: new Date(Date.parse(d["time_Period.timeInterval"]?.start)),
            end: new Date(Date.parse(d["time_Period.timeInterval"]?.end))
        };
    }
    const document = Object.assign(ParseBaseDocument(d), {
        rootType: "criticalnetworkelement",
        timeInterval,
        timeseries: []
    });
    for (const ts of tsArray){
        const tsEntry = {
            curveType: ts.curveType,
            businessType: ts.businessType,
            businessTypeDescription: ts.businessType ? BusinessTypes[ts.businessType] : void 0,
            periods: []
        };
        const periodArray = Array.isArray(ts.Period) ? ts.Period : ts.Period ? [
            ts.Period
        ] : [];
        for (const inputPeriod of periodArray){
            tsEntry.periods?.push(ParsePeriod(inputPeriod));
        }
        document.timeseries.push(tsEntry);
    }
    return document;
};
const ParseDocument = (xmlDocument)=>{
    const parser = new Ct({
        ignoreAttributes: false,
        attributeNamePrefix: "@"
    });
    const doc = parser.parse(xmlDocument);
    if (doc.Publication_MarketDocument) {
        return ParsePublication(doc.Publication_MarketDocument);
    } else if (doc.GL_MarketDocument) {
        return ParseGL(doc.GL_MarketDocument);
    } else if (doc.Unavailability_MarketDocument) {
        return ParseUnavailability(doc.Unavailability_MarketDocument);
    } else if (doc.Configuration_MarketDocument) {
        return ParseConfiguration(doc.Configuration_MarketDocument);
    } else if (doc.TransmissionNetwork_MarketDocument) {
        return ParseTransmissionNetwork(doc.TransmissionNetwork_MarketDocument);
    } else if (doc.Balancing_MarketDocument) {
        return ParseBalancing(doc.Balancing_MarketDocument);
    } else if (doc.CriticalNetworkElement_MarketDocument) {
        return ParseCriticalNetworkElement(doc.CriticalNetworkElement_MarketDocument);
    } else if (doc.Acknowledgement_MarketDocument) {
        const invalidRootNode = doc.Acknowledgement_MarketDocument;
        throw new Error(`Request failed. Code '${invalidRootNode.Reason.code}', Reason '${invalidRootNode.Reason.text}'`);
    } else {
        throw new Error("Unknown XML document structure received");
    }
};
const ENTSOE_ENDPOINT = "https://web-api.tp.entsoe.eu/api";
const ComposeQuery = (securityToken, params, force)=>{
    const query = new URLSearchParams({
        securityToken
    });
    if (!(params.documentType in DocumentTypes) && !force) {
        throw new Error("Invalid document type requested");
    } else {
        query.append("DocumentType", params.documentType);
    }
    if (params.processType !== undefined) {
        if (!(params.processType in ProcessTypes) && !force) {
            throw new Error("Invalid process type requested");
        } else {
            query.append("ProcessType", params.processType);
        }
    }
    if (params.businessType !== undefined) {
        if (!(params.businessType in BusinessTypes) && !force) {
            throw new Error("Invalid business type requested");
        } else {
            query.append("BusinessType", params.businessType);
        }
    }
    if (params.psrType !== undefined) {
        if (!(params.psrType in PsrTypes) && !force) {
            throw new Error("Invalid psr type requested");
        } else {
            query.append("PsrType", params.psrType);
        }
    }
    if (params.inDomain) {
        if (!(params.inDomain in Areas) && !force) {
            throw new Error("inDomain not valid");
        } else {
            query.append("In_Domain", params.inDomain);
        }
    }
    if (params.inBiddingZoneDomain) {
        if (!(params.inBiddingZoneDomain in Areas) && !force) {
            throw new Error("inBiddingZoneDomain not valid");
        } else {
            query.append("InBiddingZone_Domain", params.inBiddingZoneDomain);
        }
    }
    if (params.biddingZoneDomain) {
        if (!(params.biddingZoneDomain in Areas) && !force) {
            throw new Error("biddingZoneDomain not valid");
        } else {
            query.append("BiddingZone_Domain", params.biddingZoneDomain);
        }
    }
    if (params.offset !== void 0) {
        if (params.offset > 5000) {
            throw new Error("Offset too large");
        }
        if (params.offset < 0) {
            throw new Error("Offset too small");
        }
        query.append("offset", params.offset.toString());
    }
    if (params.outDomain) {
        if (!(params.outDomain in Areas) && !force) {
            throw new Error("outDomain not valid");
        } else {
            query.append("Out_Domain", params.outDomain);
        }
    }
    if (params.outBiddingZoneDomain) {
        if (!(params.outBiddingZoneDomain in Areas) && !force) {
            throw new Error("outBiddingZoneDomain not valid");
        } else {
            query.append("OutBiddingZone_Domain", params.outBiddingZoneDomain);
        }
    }
    if (params.contractMarketAgreementType) {
        query.append("Contract_MarketAgreement.Type", params.contractMarketAgreementType);
    }
    if (params.auctionType) {
        query.append("Auction.Type", params.auctionType);
    }
    if (params.classificationSequenceAICPosition) {
        query.append("ClassificationSequence_AttributeInstanceComponent.Position", params.classificationSequenceAICPosition);
    }
    if (params.auctionCategory) {
        query.append("Auction.Category", params.auctionCategory);
    }
    if (params.connectingDomain) {
        query.append("connecting_Domain", params.connectingDomain);
    }
    if (params.standardMarketProduct) {
        query.append("Standard_MarketProduct", params.standardMarketProduct);
    }
    if (params.originalMarketProduct) {
        query.append("Original_MarketProduct", params.originalMarketProduct);
    }
    if (params.registeredResource) {
        query.append("registeredResource", params.registeredResource);
    }
    if (params.acquiringDomain) {
        query.append("Acquiring_Domain", params.acquiringDomain);
    }
    if (params.mRID) {
        query.append("mRID", params.mRID);
    }
    if (params.docStatus) {
        query.append("DocStatus", params.docStatus);
    }
    if (params.startDateTimeUpdate) {
        if (!(params.startDateTimeUpdate instanceof Date && !isNaN(params.startDateTimeUpdate.getTime()))) {
            throw new Error("startDateTimeUpdate not valid, should be Date object");
        }
        if (!(params.endDateTimeUpdate instanceof Date && !isNaN(params.endDateTimeUpdate.getTime()))) {
            throw new Error("endDateTimeUpdate not valid, should be Date object");
        }
        const timeInterval = `${params.startDateTimeUpdate.toISOString()}/${params.endDateTimeUpdate.toISOString()}`;
        query.append("TimeIntervalUpdate", timeInterval);
    }
    if (params.startDateTime) {
        if (!(params.startDateTime instanceof Date && !isNaN(params.startDateTime.getTime()))) {
            throw new Error("startDateTime not valid, should be Date object");
        }
        if (!(params.endDateTime instanceof Date && !isNaN(params.endDateTime.getTime()))) {
            throw new Error("endDateTime not valid, should be Date object");
        }
        const timeInterval = `${params.startDateTime.toISOString()}/${params.endDateTime.toISOString()}`;
        query.append("TimeInterval", timeInterval);
    }
    if (params.implementationDateAndOrTime) {
        if (typeof params.implementationDateAndOrTime !== "string") {
            throw new Error("implementationDateAndOrTime not valid, should be string in ISO8601 format");
        }
        query.append("Implementation_DateAndOrTime", params.implementationDateAndOrTime);
    }
    if (!params.startDateTime && !params.startDateTimeUpdate && !params.implementationDateAndOrTime && !force) {
        throw new Error("startDateTime, startDateTimeUpdate or implementationDateAndOrTime must be specified");
    }
    return query;
};
const Query = async (securityToken, params)=>{
    const query = ComposeQuery(securityToken, params);
    const result = await fetch(`${ENTSOE_ENDPOINT}?${query}`);
    if (result.status === 401) {
        throw new Error("401 Unauthorized. Missing or invalid security token.");
    }
    const documents = [];
    if (result.headers.get("content-type")?.includes("xml") || !result.headers.has("content-type")) {
        documents.push(await ParseDocument(await result.text()));
    } else if (result.headers.get("content-type") === "application/zip") {
        let zipReader;
        try {
            const zipDataReader = new Uint8ArrayReader(new Uint8Array(await result.arrayBuffer()));
            zipReader = new ZipReader(zipDataReader, {
                useWebWorkers: false
            });
            for (const xmlFileEntry of (await zipReader.getEntries())){
                const stringDataWriter = new TextWriter();
                if (typeof xmlFileEntry.getData !== "function") break;
                await xmlFileEntry.getData(stringDataWriter);
                const xmlFileData = await stringDataWriter.getData();
                const result = await ParseDocument(xmlFileData);
                if (result) documents.push(result);
            }
        } finally{
            await zipReader?.close();
        }
    }
    return documents;
};
const QueryPublication = async (securityToken, params)=>{
    const result = await Query(securityToken, params);
    if (result && Array.isArray(result) && result.length && result[0].rootType === "publication") return result;
    if (result && Array.isArray(result) && result.length && result[0].rootType !== "publication") {
        throw new Error("Got " + result[0].rootType + " when expecting publication document");
    }
    return [];
};
const EntsoeSpotprice = async (area, startDate, endDate)=>{
    const output = [];
    let result = [];
    try {
        result = await QueryPublication(Deno.env.get("API_TOKEN") || "", {
            documentType: "A44",
            inDomain: Area(area),
            outDomain: Area(area),
            startDateTime: startDate,
            endDateTime: endDate
        });
    } catch (_e) {}
    if (result?.length) {
        try {
            for (const ts of result[0].timeseries){
                if (ts.periods) {
                    for (const period of ts.periods){
                        for (const p of period.points){
                            if (p.price !== undefined) {
                                output.push({
                                    startTime: p.startDate,
                                    endTime: p.endDate,
                                    interval: period.resolution,
                                    areaCode: area,
                                    spotPrice: p.price,
                                    unit: "EUR/MWh"
                                });
                            }
                        }
                    }
                }
            }
        } catch (_e) {
            console.error(_e);
        }
    }
    return output;
};
const osType3 = (()=>{
    const { Deno: Deno1 } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator: navigator1 } = globalThis;
    if (navigator1?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows3 = osType3 === "windows";
const CHAR_FORWARD_SLASH3 = 47;
function assertPath3(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator3(code) {
    return code === 47;
}
function isPathSeparator3(code) {
    return isPosixPathSeparator3(code) || code === 92;
}
function isWindowsDeviceRoot3(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString3(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH3;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format3(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (base === sep) return dir;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS3 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace3(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS3[c] ?? c;
    });
}
function lastPathSegment3(path, isSep, start = 0) {
    let matchedNonSeparator = false;
    let end = path.length;
    for(let i = path.length - 1; i >= start; --i){
        if (isSep(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                start = i + 1;
                break;
            }
        } else if (!matchedNonSeparator) {
            matchedNonSeparator = true;
            end = i + 1;
        }
    }
    return path.slice(start, end);
}
function stripTrailingSeparators3(segment, isSep) {
    if (segment.length <= 1) {
        return segment;
    }
    let end = segment.length;
    for(let i = segment.length - 1; i > 0; i--){
        if (isSep(segment.charCodeAt(i))) {
            end = i;
        } else {
            break;
        }
    }
    return segment.slice(0, end);
}
function stripSuffix3(name, suffix) {
    if (suffix.length >= name.length) {
        return name;
    }
    const lenDiff = name.length - suffix.length;
    for(let i = suffix.length - 1; i >= 0; --i){
        if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
            return name;
        }
    }
    return name.slice(0, -suffix.length);
}
class DenoStdInternalError2 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert3(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError2(msg);
    }
}
const sep7 = "\\";
const delimiter9 = ";";
function resolve9(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1 } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath3(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator3(code)) {
                isAbsolute = true;
                if (isPathSeparator3(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator3(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator3(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator3(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot3(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator3(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator3(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString3(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator3);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize12(path) {
    assertPath3(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator3(code)) {
            isAbsolute = true;
            if (isPathSeparator3(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator3(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator3(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator3(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot3(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator3(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator3(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString3(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator3);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator3(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute9(path) {
    assertPath3(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator3(code)) {
        return true;
    } else if (isWindowsDeviceRoot3(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator3(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join12(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath3(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert3(firstPart != null);
    if (isPathSeparator3(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator3(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator3(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator3(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize12(joined);
}
function relative9(from, to) {
    assertPath3(from);
    assertPath3(to);
    if (from === to) return "";
    const fromOrig = resolve9(from);
    const toOrig = resolve9(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath9(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve9(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot3(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname9(path) {
    assertPath3(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator3(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator3(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator3(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator3(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator3(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot3(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator3(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator3(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator3(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return stripTrailingSeparators3(path.slice(0, end), isPosixPathSeparator3);
}
function basename9(path, suffix = "") {
    assertPath3(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    let start = 0;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot3(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    const lastSegment = lastPathSegment3(path, isPathSeparator3, start);
    const strippedSegment = stripTrailingSeparators3(lastSegment, isPathSeparator3);
    return suffix ? stripSuffix3(strippedSegment, suffix) : strippedSegment;
}
function extname9(path) {
    assertPath3(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot3(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator3(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format10(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format3("\\", pathObject);
}
function parse10(path) {
    assertPath3(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator3(code)) {
            rootEnd = 1;
            if (isPathSeparator3(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator3(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator3(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator3(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot3(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator3(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            ret.base = "\\";
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator3(code)) {
        ret.root = ret.dir = path;
        ret.base = "\\";
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator3(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    ret.base = ret.base || "\\";
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl9(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl9(path) {
    if (!isAbsolute9(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace3(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod11 = {
    sep: sep7,
    delimiter: delimiter9,
    resolve: resolve9,
    normalize: normalize12,
    isAbsolute: isAbsolute9,
    join: join12,
    relative: relative9,
    toNamespacedPath: toNamespacedPath9,
    dirname: dirname9,
    basename: basename9,
    extname: extname9,
    format: format10,
    parse: parse10,
    fromFileUrl: fromFileUrl9,
    toFileUrl: toFileUrl9
};
const sep8 = "/";
const delimiter10 = ":";
function resolve10(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1 } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath3(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = isPosixPathSeparator3(path.charCodeAt(0));
    }
    resolvedPath = normalizeString3(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator3);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize13(path) {
    assertPath3(path);
    if (path.length === 0) return ".";
    const isAbsolute = isPosixPathSeparator3(path.charCodeAt(0));
    const trailingSeparator = isPosixPathSeparator3(path.charCodeAt(path.length - 1));
    path = normalizeString3(path, !isAbsolute, "/", isPosixPathSeparator3);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute10(path) {
    assertPath3(path);
    return path.length > 0 && isPosixPathSeparator3(path.charCodeAt(0));
}
function join13(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath3(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize13(joined);
}
function relative10(from, to) {
    assertPath3(from);
    assertPath3(to);
    if (from === to) return "";
    from = resolve10(from);
    to = resolve10(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (!isPosixPathSeparator3(from.charCodeAt(fromStart))) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (!isPosixPathSeparator3(to.charCodeAt(toStart))) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (isPosixPathSeparator3(to.charCodeAt(toStart + i))) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (isPosixPathSeparator3(from.charCodeAt(fromStart + i))) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (isPosixPathSeparator3(fromCode)) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || isPosixPathSeparator3(from.charCodeAt(i))) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (isPosixPathSeparator3(to.charCodeAt(toStart))) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath10(path) {
    return path;
}
function dirname10(path) {
    if (path.length === 0) return ".";
    let end = -1;
    let matchedNonSeparator = false;
    for(let i = path.length - 1; i >= 1; --i){
        if (isPosixPathSeparator3(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                end = i;
                break;
            }
        } else {
            matchedNonSeparator = true;
        }
    }
    if (end === -1) {
        return isPosixPathSeparator3(path.charCodeAt(0)) ? "/" : ".";
    }
    return stripTrailingSeparators3(path.slice(0, end), isPosixPathSeparator3);
}
function basename10(path, suffix = "") {
    assertPath3(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    const lastSegment = lastPathSegment3(path, isPosixPathSeparator3);
    const strippedSegment = stripTrailingSeparators3(lastSegment, isPosixPathSeparator3);
    return suffix ? stripSuffix3(strippedSegment, suffix) : strippedSegment;
}
function extname10(path) {
    assertPath3(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator3(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format11(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format3("/", pathObject);
}
function parse11(path) {
    assertPath3(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = isPosixPathSeparator3(path.charCodeAt(0));
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator3(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        ret.base = ret.base || "/";
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) {
        ret.dir = stripTrailingSeparators3(path.slice(0, startPart - 1), isPosixPathSeparator3);
    } else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl10(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl10(path) {
    if (!isAbsolute10(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace3(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod12 = {
    sep: sep8,
    delimiter: delimiter10,
    resolve: resolve10,
    normalize: normalize13,
    isAbsolute: isAbsolute10,
    join: join13,
    relative: relative10,
    toNamespacedPath: toNamespacedPath10,
    dirname: dirname10,
    basename: basename10,
    extname: extname10,
    format: format11,
    parse: parse11,
    fromFileUrl: fromFileUrl10,
    toFileUrl: toFileUrl10
};
const path6 = isWindows3 ? mod11 : mod12;
const { join: join14, normalize: normalize14 } = path6;
const path7 = isWindows3 ? mod11 : mod12;
const { basename: basename11, delimiter: delimiter11, dirname: dirname11, extname: extname11, format: format12, fromFileUrl: fromFileUrl11, isAbsolute: isAbsolute11, join: join15, normalize: normalize15, parse: parse12, relative: relative11, resolve: resolve11, sep: sep9, toFileUrl: toFileUrl11, toNamespacedPath: toNamespacedPath11 } = path7;
function getFileInfoType1(fileInfo) {
    return fileInfo.isFile ? "file" : fileInfo.isDirectory ? "dir" : fileInfo.isSymlink ? "symlink" : undefined;
}
async function ensureDir1(dir) {
    try {
        const fileInfo = await Deno.lstat(dir);
        if (!fileInfo.isDirectory) {
            throw new Error(`Ensure path exists, expected 'dir', got '${getFileInfoType1(fileInfo)}'`);
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            await Deno.mkdir(dir, {
                recursive: true
            });
            return;
        }
        throw err;
    }
}
new Deno.errors.AlreadyExists("dest already exists.");
var EOL3;
(function(EOL) {
    EOL["LF"] = "\n";
    EOL["CRLF"] = "\r\n";
})(EOL3 || (EOL3 = {}));
const hexTable = new TextEncoder().encode("0123456789abcdef");
function encode(src) {
    const dst = new Uint8Array(src.length * 2);
    for(let i = 0; i < dst.length; i++){
        const v = src[i];
        dst[i * 2] = hexTable[v >> 4];
        dst[i * 2 + 1] = hexTable[v & 0x0f];
    }
    return dst;
}
const { Deno: Deno3 } = globalThis;
const noColor1 = typeof Deno3?.noColor === "boolean" ? Deno3.noColor : true;
let enabled1 = !noColor1;
function code1(open, close) {
    return {
        open: `\x1b[${open.join(";")}m`,
        close: `\x1b[${close}m`,
        regexp: new RegExp(`\\x1b\\[${close}m`, "g")
    };
}
function run1(str, code) {
    return enabled1 ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;
}
function green1(str) {
    return run1(str, code1([
        32
    ], 39));
}
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");
const encoder2 = new TextEncoder();
const decoder2 = new TextDecoder();
function baseUrlToFilename(url) {
    const out = [];
    const protocol = url.protocol.replace(":", "");
    out.push(protocol);
    switch(protocol){
        case "http":
        case "https":
            {
                const host = url.hostname;
                const hostPort = url.port;
                out.push(hostPort ? `${host}_PORT${hostPort}` : host);
                break;
            }
        case "file":
        case "data":
        case "blob":
            break;
        default:
            throw new TypeError(`Don't know how to create cache name for protocol: ${protocol}`);
    }
    return join15(...out);
}
function stringToURL(url) {
    return url.startsWith("file://") || url.startsWith("http://") || url.startsWith("https://") ? new URL(url) : toFileUrl11(resolve11(url));
}
async function hash1(value1) {
    return decoder2.decode(encode(new Uint8Array(await crypto.subtle.digest("SHA-256", encoder2.encode(value1)))));
}
async function urlToFilename(url) {
    const cacheFilename = baseUrlToFilename(url);
    const hashedFilename = await hash1(url.pathname + url.search);
    return join15(cacheFilename, hashedFilename);
}
async function isFile(filePath) {
    try {
        const stats = await Deno.lstat(filePath);
        return stats.isFile;
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err;
    }
}
function homeDir() {
    switch(Deno.build.os){
        case "windows":
            return Deno.env.get("USERPROFILE");
        case "linux":
        case "darwin":
            return Deno.env.get("HOME");
        default:
            throw Error("unreachable");
    }
}
function cacheDir() {
    if (Deno.build.os === "darwin") {
        const home = homeDir();
        if (home) {
            return join15(home, "Library/Caches");
        }
    } else if (Deno.build.os === "linux") {
        const cacheHome = Deno.env.get("XDG_CACHE_HOME");
        if (cacheHome) {
            return cacheHome;
        } else {
            const home = homeDir();
            if (home) {
                return join15(home, ".cache");
            }
        }
    } else {
        return Deno.env.get("LOCALAPPDATA");
    }
}
function denoCacheDir() {
    const dd = Deno.env.get("DENO_DIR");
    let root;
    if (dd) {
        root = normalize15(isAbsolute11(dd) ? dd : join15(Deno.cwd(), dd));
    } else {
        const cd = cacheDir();
        if (cd) {
            root = join15(cd, "deno");
        } else {
            const hd = homeDir();
            if (hd) {
                root = join15(hd, ".deno");
            }
        }
    }
    return root;
}
const defaultExtensions = {
    darwin: "dylib",
    linux: "so",
    windows: "dll"
};
const defaultPrefixes = {
    darwin: "lib",
    linux: "lib",
    windows: ""
};
function getCrossOption(record) {
    if (record === undefined) {
        return;
    }
    if ("darwin" in record || "linux" in record || "windows" in record) {
        const subrecord = record[Deno.build.os];
        if (subrecord && typeof subrecord === "object" && ("x86_64" in subrecord || "aarch64" in subrecord)) {
            return subrecord[Deno.build.arch];
        } else {
            return subrecord;
        }
    }
    if ("x86_64" in record || "aarch64" in record) {
        const subrecord = record[Deno.build.arch];
        if (subrecord && typeof subrecord === "object" && ("darwin" in subrecord || "linux" in subrecord || "windows" in subrecord)) {
            return subrecord[Deno.build.os];
        } else {
            return subrecord;
        }
    }
}
function createDownloadURL(options) {
    if (typeof options === "string" || options instanceof URL) {
        options = {
            url: options
        };
    }
    options.extensions ??= defaultExtensions;
    options.prefixes ??= defaultPrefixes;
    for(const key in options.extensions){
        const os = key;
        if (options.extensions[os] !== undefined) {
            options.extensions[os] = options.extensions[os].replace(/\.?(.+)/, "$1");
        }
    }
    let url;
    if (options.url instanceof URL) {
        url = options.url;
    } else if (typeof options.url === "string") {
        url = stringToURL(options.url);
    } else {
        const tmpUrl = getCrossOption(options.url);
        if (tmpUrl === undefined) {
            throw new TypeError(`An URL for the "${Deno.build.os}-${Deno.build.arch}" target was not provided.`);
        }
        if (typeof tmpUrl === "string") {
            url = stringToURL(tmpUrl);
        } else {
            url = tmpUrl;
        }
    }
    if ("name" in options && !Object.values(options.extensions).includes(extname11(url.pathname))) {
        if (!url.pathname.endsWith("/")) {
            url.pathname = `${url.pathname}/`;
        }
        const prefix = getCrossOption(options.prefixes) ?? "";
        const suffix = getCrossOption(options.suffixes) ?? "";
        const extension = options.extensions[Deno.build.os];
        if (options.name === undefined) {
            throw new TypeError(`Expected the "name" property for an automatically assembled URL.`);
        }
        const filename = `${prefix}${options.name}${suffix}.${extension}`;
        url = new URL(filename, url);
    }
    return url;
}
async function ensureCacheLocation(location = "deno") {
    if (location === "deno") {
        const dir = denoCacheDir();
        if (dir === undefined) {
            throw new Error("Could not get the deno cache directory, try using another CacheLocation in the plug options.");
        }
        location = join15(dir, "plug");
    } else if (location === "cache") {
        const dir = cacheDir();
        if (dir === undefined) {
            throw new Error("Could not get the cache directory, try using another CacheLocation in the plug options.");
        }
        location = join15(dir, "plug");
    } else if (location === "cwd") {
        location = join15(Deno.cwd(), "plug");
    } else if (location === "tmp") {
        location = await Deno.makeTempDir({
            prefix: "plug"
        });
    } else if (typeof location === "string" && location.startsWith("file://")) {
        location = fromFileUrl11(location);
    } else if (location instanceof URL) {
        if (location?.protocol !== "file:") {
            throw new TypeError("Cannot use any other protocol than file:// for an URL cache location.");
        }
        location = fromFileUrl11(location);
    }
    location = resolve11(normalize15(location));
    await ensureDir1(location);
    return location;
}
async function download(options) {
    const location = (typeof options === "object" && "location" in options ? options.location : undefined) ?? "deno";
    const setting = (typeof options === "object" && "cache" in options ? options.cache : undefined) ?? "use";
    const [url, directory] = await Promise.all([
        createDownloadURL(options),
        ensureCacheLocation(location)
    ]);
    const cacheBasePath = join15(directory, await urlToFilename(url));
    const cacheFilePath = `${cacheBasePath}${extname11(url.pathname)}`;
    const cacheMetaPath = `${cacheBasePath}.metadata.json`;
    const cached = setting === "use" ? await isFile(cacheFilePath) : setting === "only" || setting !== "reloadAll";
    await ensureDir1(dirname11(cacheBasePath));
    if (!cached) {
        const meta = {
            url
        };
        switch(url.protocol){
            case "http:":
            case "https:":
                {
                    console.log(`${green1("Downloading")} ${url}`);
                    const response = await fetch(url.toString());
                    if (!response.ok) {
                        if (response.status === 404) {
                            throw new Error(`Could not find ${url}`);
                        } else {
                            throw new Deno.errors.Http(`${response.status} ${response.statusText}`);
                        }
                    }
                    await Deno.writeFile(cacheFilePath, new Uint8Array(await response.arrayBuffer()));
                    break;
                }
            case "file:":
                {
                    console.log(`${green1("Copying")} ${url}`);
                    await Deno.copyFile(fromFileUrl11(url), cacheFilePath);
                    if (Deno.build.os !== "windows") {
                        await Deno.chmod(cacheFilePath, 0o644);
                    }
                    break;
                }
            default:
                {
                    throw new TypeError(`Cannot fetch to cache using the "${url.protocol}" protocol`);
                }
        }
        await Deno.writeTextFile(cacheMetaPath, JSON.stringify(meta));
    }
    if (!await isFile(cacheFilePath)) {
        throw new Error(`Could not find "${url}" in cache.`);
    }
    return cacheFilePath;
}
async function dlopen(options, symbols) {
    return Deno.dlopen(await download(options), symbols);
}
const __default = JSON.parse("{\n  \"name\": \"sqlite3\",\n  \"version\": \"0.9.1\",\n  \"github\": \"https://github.com/denodrivers/sqlite3\",\n\n  \"tasks\": {\n    \"test\": \"deno test --unstable -A test/test.ts\",\n    \"build\": \"deno run -A --unstable scripts/build.ts\",\n    \"bench-deno\": \"deno run -A --unstable bench/bench_deno.js 50 1000000\",\n    \"bench-deno-ffi\": \"deno run -A --unstable bench/bench_deno_ffi.js 50 1000000\",\n    \"bench-deno-wasm\": \"deno run -A --unstable bench/bench_deno_wasm.js 50 1000000\",\n    \"bench-node\": \"node bench/bench_node.js 50 1000000\",\n    \"bench-bun\": \"bun run bench/bench_bun.js 50 1000000\",\n    \"bench-bun-ffi\": \"bun run bench/bench_bun_ffi.js 50 1000000\",\n    \"bench-c\": \"./bench/bench 50 1000000\",\n    \"bench-python\": \"python ./bench/bench_python.py\",\n    \"bench:northwind\": \"deno bench -A --unstable bench/northwind/deno.js\",\n    \"bench-wasm:northwind\": \"deno run -A --unstable bench/northwind/deno_wasm.js\",\n    \"bench-node:northwind\": \"node bench/northwind/node.mjs\",\n    \"bench-bun:northwind\": \"bun run bench/northwind/bun.js\"\n  },\n\n  \"lint\": {\n    \"rules\": {\n      \"exclude\": [\n        \"camelcase\",\n        \"no-explicit-any\"\n      ],\n      \"include\": [\n        \"explicit-function-return-type\",\n        \"eqeqeq\",\n        \"explicit-module-boundary-types\"\n      ]\n    }\n  }\n}");
const importMeta3 = {
    url: "https://deno.land/x/sqlite3@0.9.1/src/ffi.ts",
    main: false
};
const symbols = {
    sqlite3_open_v2: {
        parameters: [
            "buffer",
            "buffer",
            "i32",
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_close_v2: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_changes: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_total_changes: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_last_insert_rowid: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_get_autocommit: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_prepare_v2: {
        parameters: [
            "pointer",
            "buffer",
            "i32",
            "buffer",
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_reset: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_clear_bindings: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_step: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_step_cb: {
        name: "sqlite3_step",
        callback: true,
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_column_count: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_column_type: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "i32"
    },
    sqlite3_column_text: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "pointer"
    },
    sqlite3_finalize: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_exec: {
        parameters: [
            "pointer",
            "buffer",
            "pointer",
            "pointer",
            "buffer"
        ],
        result: "i32"
    },
    sqlite3_free: {
        parameters: [
            "pointer"
        ],
        result: "void"
    },
    sqlite3_column_int: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "i32"
    },
    sqlite3_column_double: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "f64"
    },
    sqlite3_column_blob: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "pointer"
    },
    sqlite3_column_bytes: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "i32"
    },
    sqlite3_column_name: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "pointer"
    },
    sqlite3_column_decltype: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "u64"
    },
    sqlite3_bind_parameter_index: {
        parameters: [
            "pointer",
            "buffer"
        ],
        result: "i32"
    },
    sqlite3_bind_text: {
        parameters: [
            "pointer",
            "i32",
            "buffer",
            "i32",
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_bind_blob: {
        parameters: [
            "pointer",
            "i32",
            "buffer",
            "i32",
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_bind_double: {
        parameters: [
            "pointer",
            "i32",
            "f64"
        ],
        result: "i32"
    },
    sqlite3_bind_int: {
        parameters: [
            "pointer",
            "i32",
            "i32"
        ],
        result: "i32"
    },
    sqlite3_bind_int64: {
        parameters: [
            "pointer",
            "i32",
            "i64"
        ],
        result: "i32"
    },
    sqlite3_bind_null: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "i32"
    },
    sqlite3_expanded_sql: {
        parameters: [
            "pointer"
        ],
        result: "pointer"
    },
    sqlite3_bind_parameter_count: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_complete: {
        parameters: [
            "buffer"
        ],
        result: "i32"
    },
    sqlite3_sourceid: {
        parameters: [],
        result: "pointer"
    },
    sqlite3_libversion: {
        parameters: [],
        result: "pointer"
    },
    sqlite3_blob_open: {
        parameters: [
            "pointer",
            "buffer",
            "buffer",
            "buffer",
            "i64",
            "i32",
            "buffer"
        ],
        result: "i32"
    },
    sqlite3_blob_read: {
        parameters: [
            "pointer",
            "buffer",
            "i32",
            "i32"
        ],
        result: "i32"
    },
    sqlite3_blob_write: {
        parameters: [
            "pointer",
            "buffer",
            "i32",
            "i32"
        ],
        result: "i32"
    },
    sqlite3_blob_bytes: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_blob_close: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_sql: {
        parameters: [
            "pointer"
        ],
        result: "pointer"
    },
    sqlite3_stmt_readonly: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_bind_parameter_name: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "pointer"
    },
    sqlite3_errmsg: {
        parameters: [
            "pointer"
        ],
        result: "pointer"
    },
    sqlite3_errstr: {
        parameters: [
            "i32"
        ],
        result: "pointer"
    },
    sqlite3_column_int64: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "i64"
    },
    sqlite3_backup_init: {
        parameters: [
            "pointer",
            "buffer",
            "pointer",
            "buffer"
        ],
        result: "pointer"
    },
    sqlite3_backup_step: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "i32"
    },
    sqlite3_backup_finish: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_backup_remaining: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_backup_pagecount: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_create_function: {
        parameters: [
            "pointer",
            "buffer",
            "i32",
            "i32",
            "pointer",
            "pointer",
            "pointer",
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_result_blob: {
        parameters: [
            "pointer",
            "buffer",
            "i32",
            "isize"
        ],
        result: "void"
    },
    sqlite3_result_double: {
        parameters: [
            "pointer",
            "f64"
        ],
        result: "void"
    },
    sqlite3_result_error: {
        parameters: [
            "pointer",
            "buffer",
            "i32"
        ],
        result: "void"
    },
    sqlite3_result_int: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "void"
    },
    sqlite3_result_int64: {
        parameters: [
            "pointer",
            "i64"
        ],
        result: "void"
    },
    sqlite3_result_null: {
        parameters: [
            "pointer"
        ],
        result: "void"
    },
    sqlite3_result_text: {
        parameters: [
            "pointer",
            "buffer",
            "i32",
            "isize"
        ],
        result: "void"
    },
    sqlite3_value_type: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_value_blob: {
        parameters: [
            "pointer"
        ],
        result: "pointer"
    },
    sqlite3_value_double: {
        parameters: [
            "pointer"
        ],
        result: "f64"
    },
    sqlite3_value_int: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_value_int64: {
        parameters: [
            "pointer"
        ],
        result: "i64"
    },
    sqlite3_value_text: {
        parameters: [
            "pointer"
        ],
        result: "pointer"
    },
    sqlite3_value_bytes: {
        parameters: [
            "pointer"
        ],
        result: "i32"
    },
    sqlite3_aggregate_context: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "pointer"
    },
    sqlite3_enable_load_extension: {
        parameters: [
            "pointer",
            "i32"
        ],
        result: "i32"
    },
    sqlite3_load_extension: {
        parameters: [
            "pointer",
            "buffer",
            "buffer",
            "buffer"
        ],
        result: "i32"
    },
    sqlite3_initialize: {
        parameters: [],
        result: "i32"
    }
};
let lib;
function tryGetEnv(key) {
    try {
        return Deno.env.get(key);
    } catch (e) {
        if (e instanceof Deno.errors.PermissionDenied) {
            return undefined;
        }
        throw e;
    }
}
try {
    const customPath = tryGetEnv("DENO_SQLITE_PATH");
    const sqliteLocal = tryGetEnv("DENO_SQLITE_LOCAL");
    if (sqliteLocal === "1") {
        lib = Deno.dlopen(new URL(`../build/${Deno.build.os === "windows" ? "" : "lib"}sqlite3${Deno.build.arch !== "x86_64" ? `_${Deno.build.arch}` : ""}.${Deno.build.os === "windows" ? "dll" : Deno.build.os === "darwin" ? "dylib" : "so"}`, importMeta3.url), symbols).symbols;
    } else if (customPath) {
        lib = Deno.dlopen(customPath, symbols).symbols;
    } else {
        lib = (await dlopen({
            name: __default.name,
            url: `${__default.github}/releases/download/${__default.version}/`,
            suffixes: {
                aarch64: "_aarch64"
            }
        }, symbols)).symbols;
    }
} catch (e) {
    if (e instanceof Deno.errors.PermissionDenied) {
        throw e;
    }
    throw new Error("Failed to load SQLite3 Dynamic Library", {
        cause: e
    });
}
const init = lib.sqlite3_initialize();
if (init !== 0) {
    throw new Error(`Failed to initialize SQLite3: ${init}`);
}
const osType4 = (()=>{
    const { Deno: Deno1 } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator: navigator1 } = globalThis;
    if (navigator1?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows4 = osType4 === "windows";
const CHAR_FORWARD_SLASH4 = 47;
function assertPath4(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator4(code) {
    return code === 47;
}
function isPathSeparator4(code) {
    return isPosixPathSeparator4(code) || code === 92;
}
function isWindowsDeviceRoot4(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString4(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH4;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format4(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (base === sep) return dir;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS4 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace4(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS4[c] ?? c;
    });
}
function lastPathSegment4(path, isSep, start = 0) {
    let matchedNonSeparator = false;
    let end = path.length;
    for(let i = path.length - 1; i >= start; --i){
        if (isSep(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                start = i + 1;
                break;
            }
        } else if (!matchedNonSeparator) {
            matchedNonSeparator = true;
            end = i + 1;
        }
    }
    return path.slice(start, end);
}
function stripTrailingSeparators4(segment, isSep) {
    if (segment.length <= 1) {
        return segment;
    }
    let end = segment.length;
    for(let i = segment.length - 1; i > 0; i--){
        if (isSep(segment.charCodeAt(i))) {
            end = i;
        } else {
            break;
        }
    }
    return segment.slice(0, end);
}
function stripSuffix4(name, suffix) {
    if (suffix.length >= name.length) {
        return name;
    }
    const lenDiff = name.length - suffix.length;
    for(let i = suffix.length - 1; i >= 0; --i){
        if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
            return name;
        }
    }
    return name.slice(0, -suffix.length);
}
class DenoStdInternalError3 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert4(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError3(msg);
    }
}
const sep10 = "\\";
const delimiter12 = ";";
function resolve12(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1 } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath4(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator4(code)) {
                isAbsolute = true;
                if (isPathSeparator4(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator4(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator4(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator4(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot4(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator4(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator4(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString4(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator4);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize16(path) {
    assertPath4(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator4(code)) {
            isAbsolute = true;
            if (isPathSeparator4(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator4(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator4(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator4(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot4(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator4(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator4(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString4(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator4);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator4(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute12(path) {
    assertPath4(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator4(code)) {
        return true;
    } else if (isWindowsDeviceRoot4(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator4(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join16(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath4(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert4(firstPart != null);
    if (isPathSeparator4(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator4(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator4(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator4(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize16(joined);
}
function relative12(from, to) {
    assertPath4(from);
    assertPath4(to);
    if (from === to) return "";
    const fromOrig = resolve12(from);
    const toOrig = resolve12(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath12(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve12(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot4(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname12(path) {
    assertPath4(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator4(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator4(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator4(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator4(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator4(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot4(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator4(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator4(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator4(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return stripTrailingSeparators4(path.slice(0, end), isPosixPathSeparator4);
}
function basename12(path, suffix = "") {
    assertPath4(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    let start = 0;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot4(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    const lastSegment = lastPathSegment4(path, isPathSeparator4, start);
    const strippedSegment = stripTrailingSeparators4(lastSegment, isPathSeparator4);
    return suffix ? stripSuffix4(strippedSegment, suffix) : strippedSegment;
}
function extname12(path) {
    assertPath4(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot4(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator4(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format13(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format4("\\", pathObject);
}
function parse13(path) {
    assertPath4(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator4(code)) {
            rootEnd = 1;
            if (isPathSeparator4(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator4(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator4(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator4(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot4(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator4(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            ret.base = "\\";
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator4(code)) {
        ret.root = ret.dir = path;
        ret.base = "\\";
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator4(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    ret.base = ret.base || "\\";
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl12(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl12(path) {
    if (!isAbsolute12(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace4(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod13 = {
    sep: sep10,
    delimiter: delimiter12,
    resolve: resolve12,
    normalize: normalize16,
    isAbsolute: isAbsolute12,
    join: join16,
    relative: relative12,
    toNamespacedPath: toNamespacedPath12,
    dirname: dirname12,
    basename: basename12,
    extname: extname12,
    format: format13,
    parse: parse13,
    fromFileUrl: fromFileUrl12,
    toFileUrl: toFileUrl12
};
const sep11 = "/";
const delimiter13 = ":";
function resolve13(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1 } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath4(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = isPosixPathSeparator4(path.charCodeAt(0));
    }
    resolvedPath = normalizeString4(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator4);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize17(path) {
    assertPath4(path);
    if (path.length === 0) return ".";
    const isAbsolute = isPosixPathSeparator4(path.charCodeAt(0));
    const trailingSeparator = isPosixPathSeparator4(path.charCodeAt(path.length - 1));
    path = normalizeString4(path, !isAbsolute, "/", isPosixPathSeparator4);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute13(path) {
    assertPath4(path);
    return path.length > 0 && isPosixPathSeparator4(path.charCodeAt(0));
}
function join17(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath4(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize17(joined);
}
function relative13(from, to) {
    assertPath4(from);
    assertPath4(to);
    if (from === to) return "";
    from = resolve13(from);
    to = resolve13(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (!isPosixPathSeparator4(from.charCodeAt(fromStart))) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (!isPosixPathSeparator4(to.charCodeAt(toStart))) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (isPosixPathSeparator4(to.charCodeAt(toStart + i))) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (isPosixPathSeparator4(from.charCodeAt(fromStart + i))) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (isPosixPathSeparator4(fromCode)) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || isPosixPathSeparator4(from.charCodeAt(i))) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (isPosixPathSeparator4(to.charCodeAt(toStart))) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath13(path) {
    return path;
}
function dirname13(path) {
    if (path.length === 0) return ".";
    let end = -1;
    let matchedNonSeparator = false;
    for(let i = path.length - 1; i >= 1; --i){
        if (isPosixPathSeparator4(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                end = i;
                break;
            }
        } else {
            matchedNonSeparator = true;
        }
    }
    if (end === -1) {
        return isPosixPathSeparator4(path.charCodeAt(0)) ? "/" : ".";
    }
    return stripTrailingSeparators4(path.slice(0, end), isPosixPathSeparator4);
}
function basename13(path, suffix = "") {
    assertPath4(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    const lastSegment = lastPathSegment4(path, isPosixPathSeparator4);
    const strippedSegment = stripTrailingSeparators4(lastSegment, isPosixPathSeparator4);
    return suffix ? stripSuffix4(strippedSegment, suffix) : strippedSegment;
}
function extname13(path) {
    assertPath4(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator4(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format14(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format4("/", pathObject);
}
function parse14(path) {
    assertPath4(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = isPosixPathSeparator4(path.charCodeAt(0));
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator4(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        ret.base = ret.base || "/";
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) {
        ret.dir = stripTrailingSeparators4(path.slice(0, startPart - 1), isPosixPathSeparator4);
    } else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl13(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl13(path) {
    if (!isAbsolute13(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace4(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod14 = {
    sep: sep11,
    delimiter: delimiter13,
    resolve: resolve13,
    normalize: normalize17,
    isAbsolute: isAbsolute13,
    join: join17,
    relative: relative13,
    toNamespacedPath: toNamespacedPath13,
    dirname: dirname13,
    basename: basename13,
    extname: extname13,
    format: format14,
    parse: parse14,
    fromFileUrl: fromFileUrl13,
    toFileUrl: toFileUrl13
};
const path8 = isWindows4 ? mod13 : mod14;
const { join: join18, normalize: normalize18 } = path8;
const path9 = isWindows4 ? mod13 : mod14;
const { basename: basename14, delimiter: delimiter14, dirname: dirname14, extname: extname14, format: format15, fromFileUrl: fromFileUrl14, isAbsolute: isAbsolute14, join: join19, normalize: normalize19, parse: parse15, relative: relative14, resolve: resolve14, sep: sep12, toFileUrl: toFileUrl14, toNamespacedPath: toNamespacedPath14 } = path9;
const SQLITE3_OPEN_READONLY = 0x00000001;
const SQLITE3_OPEN_READWRITE = 0x00000002;
const SQLITE3_OPEN_CREATE = 0x00000004;
const SQLITE3_OPEN_MEMORY = 0x00000080;
const { sqlite3_errmsg, sqlite3_errstr } = lib;
const encoder3 = new TextEncoder();
function toCString(str) {
    return encoder3.encode(str + "\0");
}
class SqliteError extends Error {
    code;
    name;
    constructor(code = 1, message = "Unknown Error"){
        super(`${code}: ${message}`);
        this.code = code;
        this.name = "SqliteError";
    }
}
function unwrap(code, db) {
    if (code === 0) return;
    if (code === 21) {
        throw new SqliteError(code, "SQLite3 API misuse");
    } else if (db !== undefined) {
        const errmsg = sqlite3_errmsg(db);
        if (errmsg === null) throw new SqliteError(code);
        throw new Error(Deno.UnsafePointerView.getCString(sqlite3_errmsg(db)));
    } else {
        throw new SqliteError(code, Deno.UnsafePointerView.getCString(sqlite3_errstr(code)));
    }
}
Deno.UnsafePointerView.getArrayBuffer;
const readCstr = Deno.UnsafePointerView.getCString;
const { sqlite3_prepare_v2, sqlite3_reset, sqlite3_clear_bindings, sqlite3_step, sqlite3_column_count, sqlite3_column_type, sqlite3_column_text, sqlite3_finalize, sqlite3_column_int64, sqlite3_column_double, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_name, sqlite3_expanded_sql, sqlite3_bind_parameter_count, sqlite3_bind_int, sqlite3_bind_int64, sqlite3_bind_text, sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_parameter_index, sqlite3_sql, sqlite3_stmt_readonly, sqlite3_bind_parameter_name, sqlite3_changes, sqlite3_column_int, sqlite3_step_cb } = lib;
const STATEMENTS = new Map();
const emptyStringBuffer = new Uint8Array(1);
const statementFinalizer = new FinalizationRegistry((ptr)=>{
    if (STATEMENTS.has(ptr)) {
        sqlite3_finalize(ptr);
        STATEMENTS.delete(ptr);
    }
});
function getColumn(handle, i, int64) {
    const ty = sqlite3_column_type(handle, i);
    if (ty === 1 && !int64) return sqlite3_column_int(handle, i);
    switch(ty){
        case 3:
            {
                const ptr = sqlite3_column_text(handle, i);
                if (ptr === null) return null;
                return readCstr(ptr, 0);
            }
        case 1:
            {
                return sqlite3_column_int64(handle, i);
            }
        case 2:
            {
                return sqlite3_column_double(handle, i);
            }
        case 4:
            {
                const ptr = sqlite3_column_blob(handle, i);
                const bytes = sqlite3_column_bytes(handle, i);
                return new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(ptr, bytes).slice(0));
            }
        default:
            {
                return null;
            }
    }
}
class Statement {
    db;
    #handle;
    #finalizerToken;
    #bound;
    #hasNoArgs;
    #unsafeConcurrency;
    callback;
    get unsafeHandle() {
        return this.#handle;
    }
    get expandedSql() {
        return readCstr(sqlite3_expanded_sql(this.#handle));
    }
    get sql() {
        return readCstr(sqlite3_sql(this.#handle));
    }
    get readonly() {
        return sqlite3_stmt_readonly(this.#handle) !== 0;
    }
    run(...args) {
        return this.#runWithArgs(...args);
    }
    values(...args) {
        return this.#valuesWithArgs(...args);
    }
    all(...args) {
        return this.#allWithArgs(...args);
    }
    #bindParameterCount;
    get bindParameterCount() {
        return this.#bindParameterCount;
    }
    constructor(db, sql){
        this.db = db;
        this.#bound = false;
        this.#hasNoArgs = false;
        this.callback = false;
        this.#bindRefs = new Set();
        this.#rowObject = {};
        const pHandle = new Uint32Array(2);
        unwrap(sqlite3_prepare_v2(db.unsafeHandle, toCString(sql), sql.length, pHandle, null), db.unsafeHandle);
        this.#handle = Deno.UnsafePointer.create(pHandle[0] + 2 ** 32 * pHandle[1]);
        STATEMENTS.set(this.#handle, db.unsafeHandle);
        this.#unsafeConcurrency = db.unsafeConcurrency;
        this.#finalizerToken = {
            handle: this.#handle
        };
        statementFinalizer.register(this, this.#handle, this.#finalizerToken);
        if ((this.#bindParameterCount = sqlite3_bind_parameter_count(this.#handle)) === 0) {
            this.#hasNoArgs = true;
            this.all = this.#allNoArgs;
            this.values = this.#valuesNoArgs;
            this.run = this.#runNoArgs;
            this.value = this.#valueNoArgs;
            this.get = this.#getNoArgs;
        }
    }
    enableCallback() {
        this.callback = true;
        return this;
    }
    bindParameterName(i) {
        return readCstr(sqlite3_bind_parameter_name(this.#handle, i));
    }
    bindParameterIndex(name) {
        if (name[0] !== ":" && name[0] !== "@" && name[0] !== "$") {
            name = ":" + name;
        }
        return sqlite3_bind_parameter_index(this.#handle, toCString(name));
    }
    #begin() {
        sqlite3_reset(this.#handle);
        if (!this.#bound && !this.#hasNoArgs) {
            sqlite3_clear_bindings(this.#handle);
            this.#bindRefs.clear();
        }
    }
    #bindRefs;
    #bind(i, param) {
        switch(typeof param){
            case "number":
                {
                    if (Number.isInteger(param)) {
                        if (Number.isSafeInteger(param) && param >= -(2 ** 31) && param < 2 ** 31) {
                            unwrap(sqlite3_bind_int(this.#handle, i + 1, param));
                        } else {
                            unwrap(sqlite3_bind_int64(this.#handle, i + 1, BigInt(param)));
                        }
                    } else {
                        unwrap(sqlite3_bind_double(this.#handle, i + 1, param));
                    }
                    break;
                }
            case "string":
                {
                    if (param === "") {
                        unwrap(sqlite3_bind_text(this.#handle, i + 1, emptyStringBuffer, 0, null));
                    } else {
                        const str = new TextEncoder().encode(param);
                        this.#bindRefs.add(str);
                        unwrap(sqlite3_bind_text(this.#handle, i + 1, str, str.byteLength, null));
                    }
                    break;
                }
            case "object":
                {
                    if (param === null) {} else if (param instanceof Uint8Array) {
                        this.#bindRefs.add(param);
                        unwrap(sqlite3_bind_blob(this.#handle, i + 1, param, param.byteLength, null));
                    } else if (param instanceof Date) {
                        const cstring = toCString(param.toISOString());
                        this.#bindRefs.add(cstring);
                        unwrap(sqlite3_bind_text(this.#handle, i + 1, cstring, -1, null));
                    } else {
                        throw new Error(`Value of unsupported type: ${Deno.inspect(param)}`);
                    }
                    break;
                }
            case "bigint":
                {
                    unwrap(sqlite3_bind_int64(this.#handle, i + 1, param));
                    break;
                }
            case "boolean":
                unwrap(sqlite3_bind_int(this.#handle, i + 1, param ? 1 : 0));
                break;
            default:
                {
                    throw new Error(`Value of unsupported type: ${Deno.inspect(param)}`);
                }
        }
    }
    bind(...params) {
        this.#bindAll(params);
        this.#bound = true;
        return this;
    }
    #bindAll(params) {
        if (this.#bound) throw new Error("Statement already bound to values");
        if (typeof params[0] === "object" && params[0] !== null && !(params[0] instanceof Uint8Array) && !(params[0] instanceof Date)) {
            params = params[0];
        }
        if (Array.isArray(params)) {
            for(let i = 0; i < params.length; i++){
                this.#bind(i, params[i]);
            }
        } else {
            for (const [name, param] of Object.entries(params)){
                const i = this.bindParameterIndex(name);
                if (i === 0) {
                    throw new Error(`No such parameter "${name}"`);
                }
                this.#bind(i - 1, param);
            }
        }
    }
    #runNoArgs() {
        const handle = this.#handle;
        this.#begin();
        let status;
        if (this.callback) {
            status = sqlite3_step_cb(handle);
        } else {
            status = sqlite3_step(handle);
        }
        if (status !== 100 && status !== 101) {
            unwrap(status, this.db.unsafeHandle);
        }
        sqlite3_reset(handle);
        return sqlite3_changes(this.db.unsafeHandle);
    }
    #runWithArgs(...params) {
        const handle = this.#handle;
        this.#begin();
        this.#bindAll(params);
        let status;
        if (this.callback) {
            status = sqlite3_step_cb(handle);
        } else {
            status = sqlite3_step(handle);
        }
        if (!this.#hasNoArgs && !this.#bound && params.length) {
            this.#bindRefs.clear();
        }
        if (status !== 100 && status !== 101) {
            unwrap(status, this.db.unsafeHandle);
        }
        sqlite3_reset(handle);
        return sqlite3_changes(this.db.unsafeHandle);
    }
    #valuesNoArgs() {
        const handle = this.#handle;
        const callback = this.callback;
        this.#begin();
        const columnCount = sqlite3_column_count(handle);
        const result = [];
        const getRowArray = new Function("getColumn", `
      return function(h) {
        return [${Array.from({
            length: columnCount
        }).map((_, i)=>`getColumn(h, ${i}, ${this.db.int64})`).join(", ")}];
      };
      `)(getColumn);
        let status;
        if (callback) {
            status = sqlite3_step_cb(handle);
        } else {
            status = sqlite3_step(handle);
        }
        while(status === 100){
            result.push(getRowArray(handle));
            if (callback) {
                status = sqlite3_step_cb(handle);
            } else {
                status = sqlite3_step(handle);
            }
        }
        if (status !== 101) {
            unwrap(status, this.db.unsafeHandle);
        }
        sqlite3_reset(handle);
        return result;
    }
    #valuesWithArgs(...params) {
        const handle = this.#handle;
        const callback = this.callback;
        this.#begin();
        this.#bindAll(params);
        const columnCount = sqlite3_column_count(handle);
        const result = [];
        const getRowArray = new Function("getColumn", `
      return function(h) {
        return [${Array.from({
            length: columnCount
        }).map((_, i)=>`getColumn(h, ${i}, ${this.db.int64})`).join(", ")}];
      };
      `)(getColumn);
        let status;
        if (callback) {
            status = sqlite3_step_cb(handle);
        } else {
            status = sqlite3_step(handle);
        }
        while(status === 100){
            result.push(getRowArray(handle));
            if (callback) {
                status = sqlite3_step_cb(handle);
            } else {
                status = sqlite3_step(handle);
            }
        }
        if (!this.#hasNoArgs && !this.#bound && params.length) {
            this.#bindRefs.clear();
        }
        if (status !== 101) {
            unwrap(status, this.db.unsafeHandle);
        }
        sqlite3_reset(handle);
        return result;
    }
    #rowObjectFn;
    getRowObject() {
        if (!this.#rowObjectFn || !this.#unsafeConcurrency) {
            const columnNames = this.columnNames();
            const getRowObject = new Function("getColumn", `
        return function(h) {
          return {
            ${columnNames.map((name, i)=>`"${name}": getColumn(h, ${i}, ${this.db.int64})`).join(",\n")}
          };
        };
        `)(getColumn);
            this.#rowObjectFn = getRowObject;
        }
        return this.#rowObjectFn;
    }
    #allNoArgs() {
        const handle = this.#handle;
        const callback = this.callback;
        this.#begin();
        const getRowObject = this.getRowObject();
        const result = [];
        let status;
        if (callback) {
            status = sqlite3_step_cb(handle);
        } else {
            status = sqlite3_step(handle);
        }
        while(status === 100){
            result.push(getRowObject(handle));
            if (callback) {
                status = sqlite3_step_cb(handle);
            } else {
                status = sqlite3_step(handle);
            }
        }
        if (status !== 101) {
            unwrap(status, this.db.unsafeHandle);
        }
        sqlite3_reset(handle);
        return result;
    }
    #allWithArgs(...params) {
        const handle = this.#handle;
        const callback = this.callback;
        this.#begin();
        this.#bindAll(params);
        const getRowObject = this.getRowObject();
        const result = [];
        let status;
        if (callback) {
            status = sqlite3_step_cb(handle);
        } else {
            status = sqlite3_step(handle);
        }
        while(status === 100){
            result.push(getRowObject(handle));
            if (callback) {
                status = sqlite3_step_cb(handle);
            } else {
                status = sqlite3_step(handle);
            }
        }
        if (!this.#hasNoArgs && !this.#bound && params.length) {
            this.#bindRefs.clear();
        }
        if (status !== 101) {
            unwrap(status, this.db.unsafeHandle);
        }
        sqlite3_reset(handle);
        return result;
    }
    value(...params) {
        const handle = this.#handle;
        const int64 = this.db.int64;
        const arr = new Array(sqlite3_column_count(handle));
        sqlite3_reset(handle);
        if (!this.#hasNoArgs && !this.#bound) {
            sqlite3_clear_bindings(handle);
            this.#bindRefs.clear();
            if (params.length) {
                this.#bindAll(params);
            }
        }
        let status;
        if (this.callback) {
            status = sqlite3_step_cb(handle);
        } else {
            status = sqlite3_step(handle);
        }
        if (!this.#hasNoArgs && !this.#bound && params.length) {
            this.#bindRefs.clear();
        }
        if (status === 100) {
            for(let i = 0; i < arr.length; i++){
                arr[i] = getColumn(handle, i, int64);
            }
            sqlite3_reset(this.#handle);
            return arr;
        } else if (status === 101) {
            return;
        } else {
            unwrap(status, this.db.unsafeHandle);
        }
    }
    #valueNoArgs() {
        const handle = this.#handle;
        const int64 = this.db.int64;
        const cc = sqlite3_column_count(handle);
        const arr = new Array(cc);
        sqlite3_reset(handle);
        let status;
        if (this.callback) {
            status = sqlite3_step_cb(handle);
        } else {
            status = sqlite3_step(handle);
        }
        if (status === 100) {
            for(let i = 0; i < cc; i++){
                arr[i] = getColumn(handle, i, int64);
            }
            sqlite3_reset(this.#handle);
            return arr;
        } else if (status === 101) {
            return;
        } else {
            unwrap(status, this.db.unsafeHandle);
        }
    }
    #columnNames;
    #rowObject;
    columnNames() {
        if (!this.#columnNames || !this.#unsafeConcurrency) {
            const columnCount = sqlite3_column_count(this.#handle);
            const columnNames = new Array(columnCount);
            for(let i = 0; i < columnCount; i++){
                columnNames[i] = readCstr(sqlite3_column_name(this.#handle, i));
            }
            this.#columnNames = columnNames;
            this.#rowObject = {};
            for (const name of columnNames){
                this.#rowObject[name] = undefined;
            }
        }
        return this.#columnNames;
    }
    get(...params) {
        const handle = this.#handle;
        const int64 = this.db.int64;
        const columnNames = this.columnNames();
        const row = {};
        sqlite3_reset(handle);
        if (!this.#hasNoArgs && !this.#bound) {
            sqlite3_clear_bindings(handle);
            this.#bindRefs.clear();
            if (params.length) {
                this.#bindAll(params);
            }
        }
        let status;
        if (this.callback) {
            status = sqlite3_step_cb(handle);
        } else {
            status = sqlite3_step(handle);
        }
        if (!this.#hasNoArgs && !this.#bound && params.length) {
            this.#bindRefs.clear();
        }
        if (status === 100) {
            for(let i = 0; i < columnNames.length; i++){
                row[columnNames[i]] = getColumn(handle, i, int64);
            }
            sqlite3_reset(this.#handle);
            return row;
        } else if (status === 101) {
            return;
        } else {
            unwrap(status, this.db.unsafeHandle);
        }
    }
    #getNoArgs() {
        const handle = this.#handle;
        const int64 = this.db.int64;
        const columnNames = this.columnNames();
        const row = this.#rowObject;
        sqlite3_reset(handle);
        let status;
        if (this.callback) {
            status = sqlite3_step_cb(handle);
        } else {
            status = sqlite3_step(handle);
        }
        if (status === 100) {
            for(let i = 0; i < columnNames?.length; i++){
                row[columnNames[i]] = getColumn(handle, i, int64);
            }
            sqlite3_reset(handle);
            return row;
        } else if (status === 101) {
            return;
        } else {
            unwrap(status, this.db.unsafeHandle);
        }
    }
    finalize() {
        if (!STATEMENTS.has(this.#handle)) return;
        this.#bindRefs.clear();
        statementFinalizer.unregister(this.#finalizerToken);
        STATEMENTS.delete(this.#handle);
        unwrap(sqlite3_finalize(this.#handle));
    }
    toString() {
        return readCstr(sqlite3_expanded_sql(this.#handle));
    }
    *[Symbol.iterator]() {
        this.#begin();
        const getRowObject = this.getRowObject();
        let status;
        if (this.callback) {
            status = sqlite3_step_cb(this.#handle);
        } else {
            status = sqlite3_step(this.#handle);
        }
        while(status === 100){
            yield getRowObject(this.#handle);
            if (this.callback) {
                status = sqlite3_step_cb(this.#handle);
            } else {
                status = sqlite3_step(this.#handle);
            }
        }
        if (status !== 101) {
            unwrap(status, this.db.unsafeHandle);
        }
        sqlite3_reset(this.#handle);
    }
}
const { sqlite3_blob_open, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_read, sqlite3_blob_write } = lib;
class SQLBlob {
    #handle;
    constructor(db, options){
        options = Object.assign({
            readonly: true,
            db: "main"
        }, options);
        const pHandle = new Uint32Array(2);
        unwrap(sqlite3_blob_open(db.unsafeHandle, toCString(options.db ?? "main"), toCString(options.table), toCString(options.column), options.row, options.readonly === false ? 1 : 0, pHandle));
        this.#handle = Deno.UnsafePointer.create(pHandle[0] + 2 ** 32 * pHandle[1]);
    }
    get byteLength() {
        return sqlite3_blob_bytes(this.#handle);
    }
    readSync(offset, p) {
        unwrap(sqlite3_blob_read(this.#handle, p, p.byteLength, offset));
    }
    writeSync(offset, p) {
        unwrap(sqlite3_blob_write(this.#handle, p, p.byteLength, offset));
    }
    close() {
        unwrap(sqlite3_blob_close(this.#handle));
    }
    get readable() {
        const length = this.byteLength;
        let offset = 0;
        return new ReadableStream({
            type: "bytes",
            pull: (ctx)=>{
                try {
                    const byob = ctx.byobRequest;
                    if (byob) {
                        const toRead = Math.min(length - offset, byob.view.byteLength);
                        this.readSync(offset, byob.view.subarray(0, toRead));
                        offset += toRead;
                        byob.respond(toRead);
                    } else {
                        const toRead = Math.min(length - offset, ctx.desiredSize || 1024 * 16);
                        if (toRead === 0) {
                            ctx.close();
                            return;
                        }
                        const buffer = new Uint8Array(toRead);
                        this.readSync(offset, buffer);
                        offset += toRead;
                        ctx.enqueue(buffer);
                    }
                } catch (e) {
                    ctx.error(e);
                    ctx.byobRequest?.respond(0);
                }
            }
        });
    }
    get writable() {
        const length = this.byteLength;
        let offset = 0;
        return new WritableStream({
            write: (chunk, ctx)=>{
                if (offset + chunk.byteLength > length) {
                    ctx.error(new Error("Write exceeds blob length"));
                    return;
                }
                this.writeSync(offset, chunk);
                offset += chunk.byteLength;
            }
        });
    }
    *[Symbol.iterator]() {
        const length = this.byteLength;
        let offset = 0;
        while(offset < length){
            const toRead = Math.min(length - offset, 1024 * 16);
            const buffer = new Uint8Array(toRead);
            this.readSync(offset, buffer);
            offset += toRead;
            yield buffer;
        }
    }
    [Symbol.for("Deno.customInspect")]() {
        return `SQLite3.Blob(0x${this.byteLength.toString(16)})`;
    }
}
const { sqlite3_open_v2, sqlite3_close_v2, sqlite3_changes: sqlite3_changes1, sqlite3_total_changes, sqlite3_last_insert_rowid, sqlite3_get_autocommit, sqlite3_exec, sqlite3_free, sqlite3_libversion, sqlite3_sourceid, sqlite3_complete, sqlite3_finalize: sqlite3_finalize1, sqlite3_result_blob, sqlite3_result_double, sqlite3_result_error, sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_double, sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type, sqlite3_create_function, sqlite3_result_int, sqlite3_aggregate_context, sqlite3_enable_load_extension, sqlite3_load_extension } = lib;
readCstr(sqlite3_libversion());
readCstr(sqlite3_sourceid());
class Database {
    #path;
    #handle;
    #open = true;
    #enableLoadExtension = false;
    int64;
    unsafeConcurrency;
    get open() {
        return this.#open;
    }
    get unsafeHandle() {
        return this.#handle;
    }
    get path() {
        return this.#path;
    }
    get changes() {
        return sqlite3_changes1(this.#handle);
    }
    get totalChanges() {
        return sqlite3_total_changes(this.#handle);
    }
    get lastInsertRowId() {
        return Number(sqlite3_last_insert_rowid(this.#handle));
    }
    get autocommit() {
        return sqlite3_get_autocommit(this.#handle) === 1;
    }
    get inTransaction() {
        return this.#open && !this.autocommit;
    }
    get enableLoadExtension() {
        return this.#enableLoadExtension;
    }
    set enableLoadExtension(enabled) {
        const result = sqlite3_enable_load_extension(this.#handle, Number(enabled));
        unwrap(result, this.#handle);
        this.#enableLoadExtension = enabled;
    }
    constructor(path, options = {}){
        this.#path = path instanceof URL ? fromFileUrl14(path) : path;
        let flags = 0;
        this.int64 = options.int64 ?? false;
        this.unsafeConcurrency = options.unsafeConcurrency ?? false;
        if (options.flags !== undefined) {
            flags = options.flags;
        } else {
            if (options.memory) {
                flags |= SQLITE3_OPEN_MEMORY;
            }
            if (options.readonly ?? false) {
                flags |= SQLITE3_OPEN_READONLY;
            } else {
                flags |= SQLITE3_OPEN_READWRITE;
            }
            if ((options.create ?? true) && !options.readonly) {
                flags |= SQLITE3_OPEN_CREATE;
            }
        }
        const pHandle = new Uint32Array(2);
        const result = sqlite3_open_v2(toCString(this.#path), pHandle, flags, null);
        this.#handle = Deno.UnsafePointer.create(pHandle[0] + 2 ** 32 * pHandle[1]);
        if (result !== 0) sqlite3_close_v2(this.#handle);
        unwrap(result);
        if (options.enableLoadExtension) {
            this.enableLoadExtension = options.enableLoadExtension;
        }
    }
    prepare(sql) {
        return new Statement(this, sql);
    }
    openBlob(options) {
        return new SQLBlob(this, options);
    }
    exec(sql, ...params) {
        if (params.length === 0) {
            const pErr = new Uint32Array(2);
            sqlite3_exec(this.#handle, toCString(sql), null, null, new Uint8Array(pErr.buffer));
            const errPtr = Deno.UnsafePointer.create(pErr[0] + 2 ** 32 * pErr[1]);
            if (errPtr !== null) {
                const err = readCstr(errPtr);
                sqlite3_free(errPtr);
                throw new Error(err);
            }
            return sqlite3_changes1(this.#handle);
        }
        const stmt = this.prepare(sql);
        stmt.run(...params);
        return sqlite3_changes1(this.#handle);
    }
    run(sql, ...params) {
        return this.exec(sql, ...params);
    }
    transaction(fn) {
        const controller = getController(this);
        const properties = {
            default: {
                value: wrapTransaction(fn, this, controller.default)
            },
            deferred: {
                value: wrapTransaction(fn, this, controller.deferred)
            },
            immediate: {
                value: wrapTransaction(fn, this, controller.immediate)
            },
            exclusive: {
                value: wrapTransaction(fn, this, controller.exclusive)
            },
            database: {
                value: this,
                enumerable: true
            }
        };
        Object.defineProperties(properties.default.value, properties);
        Object.defineProperties(properties.deferred.value, properties);
        Object.defineProperties(properties.immediate.value, properties);
        Object.defineProperties(properties.exclusive.value, properties);
        return properties.default.value;
    }
    #callbacks = new Set();
    function(name, fn, options) {
        const cb = new Deno.UnsafeCallback({
            parameters: [
                "pointer",
                "i32",
                "pointer"
            ],
            result: "void"
        }, (ctx, nArgs, pArgs)=>{
            const argptr = new Deno.UnsafePointerView(pArgs);
            const args = [];
            for(let i = 0; i < nArgs; i++){
                const arg = Deno.UnsafePointer.create(Number(argptr.getBigUint64(i * 8)));
                const type = sqlite3_value_type(arg);
                switch(type){
                    case 1:
                        args.push(sqlite3_value_int64(arg));
                        break;
                    case 2:
                        args.push(sqlite3_value_double(arg));
                        break;
                    case 3:
                        args.push(new TextDecoder().decode(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_text(arg), sqlite3_value_bytes(arg)))));
                        break;
                    case 4:
                        args.push(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_blob(arg), sqlite3_value_bytes(arg))));
                        break;
                    case 5:
                        args.push(null);
                        break;
                    default:
                        throw new Error(`Unknown type: ${type}`);
                }
            }
            let result;
            try {
                result = fn(...args);
            } catch (err) {
                const buf = new TextEncoder().encode(err.message);
                sqlite3_result_error(ctx, buf, buf.byteLength);
                return;
            }
            if (result === undefined || result === null) {
                sqlite3_result_null(ctx);
            } else if (typeof result === "boolean") {
                sqlite3_result_int(ctx, result ? 1 : 0);
            } else if (typeof result === "number") {
                if (Number.isSafeInteger(result)) sqlite3_result_int64(ctx, result);
                else sqlite3_result_double(ctx, result);
            } else if (typeof result === "bigint") {
                sqlite3_result_int64(ctx, result);
            } else if (typeof result === "string") {
                const buffer = new TextEncoder().encode(result);
                sqlite3_result_text(ctx, buffer, buffer.byteLength, 0);
            } else if (result instanceof Uint8Array) {
                sqlite3_result_blob(ctx, result, result.length, -1);
            } else {
                const buffer = new TextEncoder().encode(`Invalid return value: ${Deno.inspect(result)}`);
                sqlite3_result_error(ctx, buffer, buffer.byteLength);
            }
        });
        let flags = 1;
        if (options?.deterministic) {
            flags |= 0x000000800;
        }
        if (options?.directOnly) {
            flags |= 0x000080000;
        }
        if (options?.subtype) {
            flags |= 0x000100000;
        }
        if (options?.directOnly) {
            flags |= 0x000200000;
        }
        const err = sqlite3_create_function(this.#handle, toCString(name), options?.varargs ? -1 : fn.length, flags, null, cb.pointer, null, null);
        unwrap(err, this.#handle);
        this.#callbacks.add(cb);
    }
    aggregate(name, options) {
        const contexts = new Map();
        const cb = new Deno.UnsafeCallback({
            parameters: [
                "pointer",
                "i32",
                "pointer"
            ],
            result: "void"
        }, (ctx, nArgs, pArgs)=>{
            const aggrCtx = sqlite3_aggregate_context(ctx, 8);
            const aggrPtr = Deno.UnsafePointer.value(aggrCtx);
            let aggregate;
            if (contexts.has(aggrPtr)) {
                aggregate = contexts.get(aggrPtr);
            } else {
                aggregate = typeof options.start === "function" ? options.start() : options.start;
                contexts.set(aggrPtr, aggregate);
            }
            const argptr = new Deno.UnsafePointerView(pArgs);
            const args = [];
            for(let i = 0; i < nArgs; i++){
                const arg = Deno.UnsafePointer.create(Number(argptr.getBigUint64(i * 8)));
                const type = sqlite3_value_type(arg);
                switch(type){
                    case 1:
                        args.push(sqlite3_value_int64(arg));
                        break;
                    case 2:
                        args.push(sqlite3_value_double(arg));
                        break;
                    case 3:
                        args.push(new TextDecoder().decode(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_text(arg), sqlite3_value_bytes(arg)))));
                        break;
                    case 4:
                        args.push(new Uint8Array(Deno.UnsafePointerView.getArrayBuffer(sqlite3_value_blob(arg), sqlite3_value_bytes(arg))));
                        break;
                    case 5:
                        args.push(null);
                        break;
                    default:
                        throw new Error(`Unknown type: ${type}`);
                }
            }
            let result;
            try {
                result = options.step(aggregate, ...args);
            } catch (err) {
                const buf = new TextEncoder().encode(err.message);
                sqlite3_result_error(ctx, buf, buf.byteLength);
                return;
            }
            contexts.set(aggrPtr, result);
        });
        const cbFinal = new Deno.UnsafeCallback({
            parameters: [
                "pointer"
            ],
            result: "void"
        }, (ctx)=>{
            const aggrCtx = sqlite3_aggregate_context(ctx, 0);
            const aggrPtr = Deno.UnsafePointer.value(aggrCtx);
            const aggregate = contexts.get(aggrPtr);
            contexts.delete(aggrPtr);
            let result;
            try {
                result = options.final ? options.final(aggregate) : aggregate;
            } catch (err) {
                const buf = new TextEncoder().encode(err.message);
                sqlite3_result_error(ctx, buf, buf.byteLength);
                return;
            }
            if (result === undefined || result === null) {
                sqlite3_result_null(ctx);
            } else if (typeof result === "boolean") {
                sqlite3_result_int(ctx, result ? 1 : 0);
            } else if (typeof result === "number") {
                if (Number.isSafeInteger(result)) sqlite3_result_int64(ctx, result);
                else sqlite3_result_double(ctx, result);
            } else if (typeof result === "bigint") {
                sqlite3_result_int64(ctx, result);
            } else if (typeof result === "string") {
                const buffer = new TextEncoder().encode(result);
                sqlite3_result_text(ctx, buffer, buffer.byteLength, 0);
            } else if (result instanceof Uint8Array) {
                sqlite3_result_blob(ctx, result, result.length, -1);
            } else {
                const buffer = new TextEncoder().encode(`Invalid return value: ${Deno.inspect(result)}`);
                sqlite3_result_error(ctx, buffer, buffer.byteLength);
            }
        });
        let flags = 1;
        if (options?.deterministic) {
            flags |= 0x000000800;
        }
        if (options?.directOnly) {
            flags |= 0x000080000;
        }
        if (options?.subtype) {
            flags |= 0x000100000;
        }
        if (options?.directOnly) {
            flags |= 0x000200000;
        }
        const err = sqlite3_create_function(this.#handle, toCString(name), options?.varargs ? -1 : options.step.length - 1, flags, null, null, cb.pointer, cbFinal.pointer);
        unwrap(err, this.#handle);
        this.#callbacks.add(cb);
        this.#callbacks.add(cbFinal);
    }
    loadExtension(file, entryPoint) {
        if (!this.enableLoadExtension) {
            throw new Error("Extension loading is not enabled");
        }
        const pzErrMsg = new Uint32Array(2);
        const result = sqlite3_load_extension(this.#handle, toCString(file), entryPoint ? toCString(entryPoint) : null, pzErrMsg);
        const pzErrPtr = Deno.UnsafePointer.create(pzErrMsg[0] + 2 ** 32 * pzErrMsg[1]);
        if (pzErrPtr !== null) {
            const pzErr = readCstr(pzErrPtr);
            sqlite3_free(pzErrPtr);
            throw new Error(pzErr);
        }
        unwrap(result, this.#handle);
    }
    close() {
        if (!this.#open) return;
        for (const [stmt, db] of STATEMENTS){
            if (db === this.#handle) {
                sqlite3_finalize1(stmt);
                STATEMENTS.delete(stmt);
            }
        }
        for (const cb of this.#callbacks){
            cb.close();
        }
        unwrap(sqlite3_close_v2(this.#handle));
        this.#open = false;
    }
    [Symbol.for("Deno.customInspect")]() {
        return `SQLite3.Database { path: ${this.path} }`;
    }
}
const controllers = new WeakMap();
const getController = (db)=>{
    let controller = controllers.get(db);
    if (!controller) {
        const shared = {
            commit: db.prepare("COMMIT"),
            rollback: db.prepare("ROLLBACK"),
            savepoint: db.prepare("SAVEPOINT `\t_bs3.\t`"),
            release: db.prepare("RELEASE `\t_bs3.\t`"),
            rollbackTo: db.prepare("ROLLBACK TO `\t_bs3.\t`")
        };
        controllers.set(db, controller = {
            default: Object.assign({
                begin: db.prepare("BEGIN")
            }, shared),
            deferred: Object.assign({
                begin: db.prepare("BEGIN DEFERRED")
            }, shared),
            immediate: Object.assign({
                begin: db.prepare("BEGIN IMMEDIATE")
            }, shared),
            exclusive: Object.assign({
                begin: db.prepare("BEGIN EXCLUSIVE")
            }, shared)
        });
    }
    return controller;
};
const wrapTransaction = (fn, db, { begin, commit, rollback, savepoint, release, rollbackTo })=>function sqliteTransaction() {
        const { apply } = Function.prototype;
        let before, after, undo;
        if (db.inTransaction) {
            before = savepoint;
            after = release;
            undo = rollbackTo;
        } else {
            before = begin;
            after = commit;
            undo = rollback;
        }
        before.run();
        try {
            const result = apply.call(fn, this, arguments);
            after.run();
            return result;
        } catch (ex) {
            if (!db.autocommit) {
                undo.run();
                if (undo !== rollback) after.run();
            }
            throw ex;
        }
    };
const osType5 = (()=>{
    const { Deno: Deno1 } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator: navigator1 } = globalThis;
    if (navigator1?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows5 = osType5 === "windows";
const CHAR_FORWARD_SLASH5 = 47;
function assertPath5(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator5(code) {
    return code === 47;
}
function isPathSeparator5(code) {
    return isPosixPathSeparator5(code) || code === 92;
}
function isWindowsDeviceRoot5(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString5(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH5;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function stripTrailingSeparators5(segment, isSep) {
    if (segment.length <= 1) {
        return segment;
    }
    let end = segment.length;
    for(let i = segment.length - 1; i > 0; i--){
        if (isSep(segment.charCodeAt(i))) {
            end = i;
        } else {
            break;
        }
    }
    return segment.slice(0, end);
}
function posixResolve(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1 } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath5(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = isPosixPathSeparator5(path.charCodeAt(0));
    }
    resolvedPath = normalizeString5(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator5);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function windowsResolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1 } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath5(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator5(code)) {
                isAbsolute = true;
                if (isPathSeparator5(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator5(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator5(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator5(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot5(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator5(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator5(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString5(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator5);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function assertArg(path) {
    assertPath5(path);
    if (path.length === 0) return ".";
}
function posixNormalize(path) {
    assertArg(path);
    const isAbsolute = isPosixPathSeparator5(path.charCodeAt(0));
    const trailingSeparator = isPosixPathSeparator5(path.charCodeAt(path.length - 1));
    path = normalizeString5(path, !isAbsolute, "/", isPosixPathSeparator5);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function windowsNormalize(path) {
    assertArg(path);
    const len = path.length;
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator5(code)) {
            isAbsolute = true;
            if (isPathSeparator5(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator5(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator5(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator5(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot5(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator5(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator5(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString5(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator5);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator5(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function windowsIsAbsolute(path) {
    assertPath5(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator5(code)) {
        return true;
    } else if (isWindowsDeviceRoot5(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator5(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function posixIsAbsolute(path) {
    assertPath5(path);
    return path.length > 0 && isPosixPathSeparator5(path.charCodeAt(0));
}
class AssertionError1 extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function assert5(expr, msg = "") {
    if (!expr) {
        throw new AssertionError1(msg);
    }
}
function posixJoin(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath5(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return posixNormalize(joined);
}
function windowsJoin(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < paths.length; ++i){
        const path = paths[i];
        assertPath5(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert5(firstPart != null);
    if (isPathSeparator5(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator5(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator5(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator5(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return windowsNormalize(joined);
}
function assertArgs(from, to) {
    assertPath5(from);
    assertPath5(to);
    if (from === to) return "";
}
function posixRelative(from, to) {
    assertArgs(from, to);
    from = posixResolve(from);
    to = posixResolve(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (!isPosixPathSeparator5(from.charCodeAt(fromStart))) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (!isPosixPathSeparator5(to.charCodeAt(toStart))) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (isPosixPathSeparator5(to.charCodeAt(toStart + i))) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (isPosixPathSeparator5(from.charCodeAt(fromStart + i))) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (isPosixPathSeparator5(fromCode)) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || isPosixPathSeparator5(from.charCodeAt(i))) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (isPosixPathSeparator5(to.charCodeAt(toStart))) ++toStart;
        return to.slice(toStart);
    }
}
function windowsRelative(from, to) {
    assertArgs(from, to);
    const fromOrig = windowsResolve(from);
    const toOrig = windowsResolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function posixToNamespacedPath(path) {
    return path;
}
function windowsToNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = windowsResolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot5(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function assertArg1(path) {
    assertPath5(path);
    if (path.length === 0) return ".";
}
function posixDirname(path) {
    assertArg1(path);
    let end = -1;
    let matchedNonSeparator = false;
    for(let i = path.length - 1; i >= 1; --i){
        if (isPosixPathSeparator5(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                end = i;
                break;
            }
        } else {
            matchedNonSeparator = true;
        }
    }
    if (end === -1) {
        return isPosixPathSeparator5(path.charCodeAt(0)) ? "/" : ".";
    }
    return stripTrailingSeparators5(path.slice(0, end), isPosixPathSeparator5);
}
function windowsDirname(path) {
    assertArg1(path);
    const len = path.length;
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator5(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator5(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator5(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator5(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator5(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot5(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator5(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator5(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator5(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return stripTrailingSeparators5(path.slice(0, end), isPosixPathSeparator5);
}
function stripSuffix5(name, suffix) {
    if (suffix.length >= name.length) {
        return name;
    }
    const lenDiff = name.length - suffix.length;
    for(let i = suffix.length - 1; i >= 0; --i){
        if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
            return name;
        }
    }
    return name.slice(0, -suffix.length);
}
function lastPathSegment5(path, isSep, start = 0) {
    let matchedNonSeparator = false;
    let end = path.length;
    for(let i = path.length - 1; i >= start; --i){
        if (isSep(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                start = i + 1;
                break;
            }
        } else if (!matchedNonSeparator) {
            matchedNonSeparator = true;
            end = i + 1;
        }
    }
    return path.slice(start, end);
}
function assertArgs1(path, suffix) {
    assertPath5(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
}
function posixBasename(path, suffix = "") {
    assertArgs1(path, suffix);
    const lastSegment = lastPathSegment5(path, isPosixPathSeparator5);
    const strippedSegment = stripTrailingSeparators5(lastSegment, isPosixPathSeparator5);
    return suffix ? stripSuffix5(strippedSegment, suffix) : strippedSegment;
}
function windowsBasename(path, suffix = "") {
    assertArgs1(path, suffix);
    let start = 0;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot5(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    const lastSegment = lastPathSegment5(path, isPathSeparator5, start);
    const strippedSegment = stripTrailingSeparators5(lastSegment, isPathSeparator5);
    return suffix ? stripSuffix5(strippedSegment, suffix) : strippedSegment;
}
function posixExtname(path) {
    assertPath5(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator5(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function windowsExtname(path) {
    assertPath5(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot5(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator5(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function _format5(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (base === sep) return dir;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
function assertArg2(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
}
function posixFormat(pathObject) {
    assertArg2(pathObject);
    return _format5("/", pathObject);
}
function windowsFormat(pathObject) {
    assertArg2(pathObject);
    return _format5("\\", pathObject);
}
function posixParse(path) {
    assertPath5(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = isPosixPathSeparator5(path.charCodeAt(0));
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator5(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        ret.base = ret.base || "/";
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) {
        ret.dir = stripTrailingSeparators5(path.slice(0, startPart - 1), isPosixPathSeparator5);
    } else if (isAbsolute) ret.dir = "/";
    return ret;
}
function windowsParse(path) {
    assertPath5(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator5(code)) {
            rootEnd = 1;
            if (isPathSeparator5(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator5(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator5(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator5(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot5(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator5(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            ret.base = "\\";
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator5(code)) {
        ret.root = ret.dir = path;
        ret.base = "\\";
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator5(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    ret.base = ret.base || "\\";
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function assertArg3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return url;
}
function posixFromFileUrl(url) {
    url = assertArg3(url);
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function windowsFromFileUrl(url) {
    url = assertArg3(url);
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
const WHITESPACE_ENCODINGS5 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace5(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS5[c] ?? c;
    });
}
function posixToFileUrl(path) {
    if (!posixIsAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace5(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
function windowsToFileUrl(path) {
    if (!windowsIsAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace5(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const sep13 = "\\";
const delimiter15 = ";";
const mod15 = {
    resolve: windowsResolve,
    normalize: windowsNormalize,
    isAbsolute: windowsIsAbsolute,
    join: windowsJoin,
    relative: windowsRelative,
    toNamespacedPath: windowsToNamespacedPath,
    dirname: windowsDirname,
    basename: windowsBasename,
    extname: windowsExtname,
    format: windowsFormat,
    parse: windowsParse,
    fromFileUrl: windowsFromFileUrl,
    toFileUrl: windowsToFileUrl,
    sep: sep13,
    delimiter: delimiter15
};
const sep14 = "/";
const delimiter16 = ":";
const mod16 = {
    resolve: posixResolve,
    normalize: posixNormalize,
    isAbsolute: posixIsAbsolute,
    join: posixJoin,
    relative: posixRelative,
    toNamespacedPath: posixToNamespacedPath,
    dirname: posixDirname,
    basename: posixBasename,
    extname: posixExtname,
    format: posixFormat,
    parse: posixParse,
    fromFileUrl: posixFromFileUrl,
    toFileUrl: posixToFileUrl,
    sep: sep14,
    delimiter: delimiter16
};
function resolve15(...pathSegments) {
    return isWindows5 ? windowsResolve(...pathSegments) : posixResolve(...pathSegments);
}
const path10 = isWindows5 ? mod15 : mod16;
const { join: join20, normalize: normalize20 } = path10;
isWindows5 ? mod15.delimiter : mod16.delimiter;
async function openDatabase(options) {
    const path = resolve15(Deno.cwd(), "./db/"), fileName = resolve15(path, "main.db");
    await Deno.mkdir(path, {
        recursive: true
    });
    const database = new Database(fileName, options);
    return database;
}
let level = "normal";
const log = (type, t)=>{
    if (type == "debug" && level != "debug") return;
    let fn;
    if (type === "log") fn = console.log;
    else if (type === "info") fn = console.info;
    else if (type === "error") fn = console.error;
    else if (type === "debug") fn = console.debug;
    else throw new Error("Invalid log type, cannot log: " + t);
    if (fn) {
        if (false) {
            fn(new Date().toLocaleString("sv-SE"), "Backend:", t);
        } else {
            fn(t);
        }
    }
};
const sleep1 = (ms)=>new Promise((r)=>setTimeout(r, ms));
const tm = new PupTelemetry();
const database = await openDatabase({
    int64: true,
    readonly: false
});
const startDate = new Date(Date.parse("2020-12-31T12:00:00Z"));
const DailyPriceUpdate = async ()=>{
    log("info", `Scheduled data update started`);
    try {
        const dateToday = new Date(), dateTomorrow = new Date(), dateFirstOfMonth = new Date();
        dateTomorrow.setDate(dateTomorrow.getDate() + 1);
        dateFirstOfMonth.setDate(1);
        dateTomorrow.setHours(23, 0, 0, 0);
        dateFirstOfMonth.setHours(0, 0, 0, 0);
        dateToday.setHours(0, 0, 0, 0);
        for (const country of countries){
            for (const area of country.areas){
                let currentPeriod;
                const maxPeriodResult = database.prepare("SELECT MAX(period) as mp FROM spotprice WHERE country=(?) AND area=(?)").values(country.id, area.name);
                currentPeriod = new Date(maxPeriodResult[0][0] && typeof maxPeriodResult[0][0] === "number" ? new Date(maxPeriodResult[0][0]) : startDate);
                let errored = false;
                if (currentPeriod != startDate) currentPeriod.setDate(currentPeriod.getDate() + 1);
                currentPeriod.setHours(0, 0, 0, 0);
                while(currentPeriod.getTime() < dateTomorrow.getTime() && !errored){
                    currentPeriod.setHours(0, 0, 0, 0);
                    let endOfPeriod = new Date(currentPeriod);
                    endOfPeriod.setMonth(endOfPeriod.getMonth() + 1);
                    endOfPeriod = new Date(endOfPeriod);
                    endOfPeriod.setDate(endOfPeriod.getDate() - 1);
                    endOfPeriod.setHours(23, 45, 0, 0);
                    endOfPeriod = new Date(Math.min(endOfPeriod.getTime(), dateTomorrow.getTime()));
                    log("info", `Getting ${area.id} ${currentPeriod.toLocaleString()} ${endOfPeriod.toLocaleString()}`);
                    try {
                        const result = await EntsoeSpotprice(area.id, currentPeriod, endOfPeriod), preparedQuery = database.prepare("INSERT INTO spotprice (country, area, spotprice, period, interval) VALUES (?,?,?,?,?)");
                        const runTransaction = database.transaction((data)=>{
                            for (const item of data){
                                preparedQuery.run(...item);
                            }
                        });
                        if (result.length) {
                            log("info", `Got ${result.length} rows`);
                            const transaction = [];
                            for (const row of result){
                                transaction.push([
                                    country.id,
                                    area.name,
                                    row.spotPrice,
                                    row.startTime.getTime(),
                                    row.interval
                                ]);
                            }
                            runTransaction(transaction);
                            currentPeriod = endOfPeriod;
                            currentPeriod.setDate(currentPeriod.getDate() + 1);
                        } else {
                            log("info", `No new data for ${area.id}`);
                            errored = true;
                        }
                    } catch (e) {
                        log("error", `entsoe request failed ${e}`);
                        errored = true;
                    }
                    await sleep1(2000);
                }
            }
        }
        log("info", `Cleaning up.`);
        database.exec("DELETE FROM spotprice WHERE id NOT IN (SELECT MAX(id) FROM spotprice GROUP BY area,country,period,interval)");
        if (database.totalChanges) {
            log("info", `Deleted ${database.totalChanges} duplicate rows.`);
        }
    } catch (e) {
        log("error", `Error occured while updating data, skipping. Error: ${e}`);
    }
    log("info", `Scheduled data update done`);
    tm.emit("spotweb-main-1", "clear_cache", {
        cache: "spotprices"
    });
    tm.emit("spotweb-main-2", "clear_cache", {
        cache: "spotprices"
    });
    tm.emit("spotweb-main-3", "clear_cache", {
        cache: "spotprices"
    });
    database.close();
    Deno.exit(0);
};
DailyPriceUpdate();
